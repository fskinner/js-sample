(function(window,document,undefined){'use strict':function minErr(module,ErrorConstructor) { ErrorConstructor = ErrorConstructor || Error;return function() { var code = arguments[0],prefix = '[' + (module ? module + ':':'') + code + '] ',template = arguments[1],templateArgs = arguments,message,i;:message = prefix + template.replace(/\{\d+\}/g,function(match){:var index = +match.slice(1,-1),arg;:if(index + 2 < templateArgs.length) { return toDebugString(templateArgs[index + 2])}); message = message+'\nhttp://errors.angularjs.org/1.3.11/'+(module ? module+'/' : '')+code; for (i = 2; i < arguments.length; i++){message = message + (i == 2 ? '?':'&') + 'p' + (i - 2) + '=' + encodeURIComponent(toDebugString(arguments[i]))}//////////////////////////////////// var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/; // The name of a form control's ValidityState property.
// This is used so that it's possible for internal tests to create mock ValidityStates. var VALIDITY_STATE_PROPERTY = 'validity'; var lowercase = function(string){return isString(string) ? string.toLowerCase():string}; var hasOwnProperty = Object.prototype.hasOwnProperty; var uppercase = function(string){return isString(string) ? string.toUpperCase():string}; var manualLowercase = function(s){:return isString(s) ? s.replace(/[A-Z]/g,function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32)}; var manualUppercase = function(s){:return isString(s) ? s.replace(/[a-z]/g,function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32)}* Providing 'undefined' or 'null' values for `obj` will not throw a TypeError,; // String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
if ('i' !== 'I'.toLowerCase()) {
  lowercase = manualLowercase;
  uppercase = manualUppercase;
}


var
    msie,             // holds major version number for IE, or NaN if UA is not IE.
    jqLite,           // delay binding since jQuery could be loaded after us.
    jQuery,           // delay binding
    slice             = [].slice,
    splice            = [].splice,
    push              = [].push,
    toString          = Object.prototype.toString,
    ngMinErr          = minErr('ng'),

    /** @name angular */
    angular           = window.angular || (window.angular = {}),
    angularModule,
    uid               = 0;

/**
 * documentMode is an IE-only property
 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
 */
msie = document.documentMode;


/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }

  var length = obj.length;

  if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
    return true;
  }

  return isString(obj) || isArray(obj) || length === 0 ||
         typeof length === 'number' && length > 0 && (length - 1) in obj;
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @module ng
 * @kind function
 *
 * @description
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
 * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`
 * is the value of an object property or an array element, `key` is the object property key or
 * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.
 *
 * It is worth noting that `.forEach` does not iterate over inherited properties because it filters
 * using the `hasOwnProperty` method.
 *
 * Unlike ES262's * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),but rather just * return the value provided. * ```js var values ={name:'misko',gender:'male'}; var log = []; angular.forEach(values,function(value,key){:this.push(key + ': ' + value)}Reference to `obj`. */ function forEach(obj,iterator,context){:var key,length;:if(obj) { if(isFunction(obj)) { for(key in obj) { // Need to check if hasOwnProperty exists,// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function if(key != 'prototype' && key != 'length' && key != 'name' &&(!obj.hasOwnProperty || obj.hasOwnProperty(key))) { iterator.call(context,obj[key],key,obj)}else if (isArray(obj) || isArrayLike(obj)){:var isPrimitive = typeof obj !== 'object';:for(key = 0,length = obj.length;:key < length;:key++) { if(isPrimitive || key in obj) { iterator.call(context,obj[key],key,obj)}else if (obj.forEach && obj.forEach !== forEach){:obj.forEach(iterator,context,obj)}function sortedKeys(obj){:return Object.keys(obj).sort()}function forEachSorted(obj,iterator,context){:var keys = sortedKeys(obj);:for(var i = 0;:i < keys.length;:i++) { iterator.call(context,obj[keys[i]],keys[i])}function reverseParams(iteratorFn){:return function(value,key) { iteratorFn(key,value)}function nextUid(){:return ++uid}function setHashKey(obj,h){:if(h) { obj.$$hashKey = h}function extend(dst){:var h = dst.$$hashKey;:for(var i = 1,ii = arguments.length;:i < ii;:i++) { var obj = arguments[i];:if(obj) { var keys = Object.keys(obj);:for(var j = 0,jj = keys.length;:j < jj;:j++) { var key = keys[j];:dst[key]= obj[key]}function int(str){:return parseInt(str,10)}function inherit(parent,extra){:return extend(Object.create(parent),extra)}noop.$inject = []; function identity($){:return $}identity.$inject = []; function valueFn(value){:return function() {return value}function isUndefined(value){:return typeof value === 'undefined'}function isDefined(value){:return typeof value !== 'undefined'}function isObject(value){// http://jsperf.com/isobject4 return value !== null && typeof value === 'object'}function isString(value){:return typeof value === 'string'}function isNumber(value){:return typeof value === 'number'}function isDate(value){:return toString.call(value) === '[object Date]'}var isArray = Array.isArray; function isFunction(value){:return typeof value === 'function'}function isRegExp(value){:return toString.call(value) === '[object RegExp]'}function isWindow(obj){:return obj && obj.window === obj}function isScope(obj){:return obj && obj.$evalAsync && obj.$watch}function isFile(obj){:return toString.call(obj) === '[object File]'}function isFormData(obj){:return toString.call(obj) === '[object FormData]'}function isBlob(obj){:return toString.call(obj) === '[object Blob]'}function isBoolean(value){:return typeof value === 'boolean'}function isPromiseLike(obj){:return obj && isFunction(obj.then)}var trim = function(value){return isString(value) ? value.trim():value}; // Copied from: // http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021 // Prereq: s is a string. var escapeForRegexp = function(s){:return s.replace(/([-()\[\]{}; function isElement(node){:return !!(node &&(node.nodeName // we are a direct element ||(node.prop && node.attr && node.find)));:// we have an on and find method part of jQuery API}function makeMap(str){:var obj = {}function nodeName_(element){:return lowercase(element.nodeName ||(element[0]&& element[0].nodeName))}function includes(array,obj){:return Array.prototype.indexOf.call(array,obj) != -1}function arrayRemove(array,value){:var index = array.indexOf(value);:if(index >= 0) array.splice(index,1);:return value}function copy(source,destination,stackSource,stackDest){:if(isWindow(source) || isScope(source)) { throw ngMinErr('cpws',"Can't copy! Making copies of Window or Scope instances is not supported.")}if (!destination){:destination = source;:if(source) { if(isArray(source)) { destination = copy(source[],stackSource,stackDest)}else if (isDate(source)){:destination = new Date(source.getTime())}else if (isRegExp(source)){:destination = new RegExp(source.source,source.toString().match(/[^\/]*$/)[0]);:destination.lastIndex = source.lastIndex}else if (isObject(source)){:var emptyObject = Object.create(Object.getPrototypeOf(source));:destination = copy(source,emptyObject,stackSource,stackDest)}var result; if (isArray(source)){:destination.length = 0;:for(var i = 0;:i < source.length;:i++) { result = copy(source[i],null,stackSource,stackDest);:if(isObject(source[i])) { stackSource.push(source[i]);:stackDest.push(result)}for (var key in source){:if(source.hasOwnProperty(key)) { result = copy(source[key],null,stackSource,stackDest);:if(isObject(source[key])) { stackSource.push(source[key]);:stackDest.push(result)}function shallowCopy(src,dst){:if(isArray(src)) { dst = dst ||[];:for(var i = 0,ii = src.length;:i < ii;:i++) { dst[i]= src[i]}else if (isObject(src)){:dst = dst || {}; for (var key in src){:if(!(key.charAt(0) === '$' && key.charAt(1) === '$')) { dst[key]= src[key]}function equals(o1,o2){:if(o1 === o2) return true;:if(o1 === null || o2 === null) return false;:if(o1 !== o1 && o2 !== o2) return true;:// NaN === NaN var t1 = typeof o1,t2 = typeof o2,length,key,keySet;:if(t1 == t2) { if(t1 == 'object') { if(isArray(o1)) { if(!isArray(o2)) return false;:if((length = o1length) == o2length) { for(key = 0;:key < length;:key++) { if(!equals(o1[key],o2[key])) return false}else if (isDate(o1)){:if(!isDate(o2)) return false;:return equals(o1getTime(),o2getTime())}else if (isRegExp(o1) && isRegExp(o2)){:return o1toString() == o2toString()}; for (key in o1){:if(key.charAt(0) === '$' || isFunction(o1[key])) continue;:if(!equals(o1[key],o2[key])) return false;:keySet[key]= true}for (key in o2){:if(!keySet.hasOwnProperty(key) && key.charAt(0) !== '$' && o2[key]!== undefined && !isFunction(o2[key])) return false}var csp = function(){:if(isDefined(csp.isActive_)) return csp.isActive_;:var active = !!(document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));:if(!active) { try { new Function('')}; function concat(array1,array2,index){:return array1concat(slice.call(array2,index))}function sliceArgs(args,startIndex){:return slice.call(args,startIndex || 0)}function bind(self,fn){:var curryArgs = arguments.length > 2 ? sliceArgs(arguments,2)[];if(isFunction(fn) && !(fn instanceof RegExp)) { return curryArgs.length ? function() { return arguments.length ? fn.apply(self,concat(curryArgs,arguments,0)):fn.apply(self,curryArgs)}: function(){return arguments.length ? fn.apply(self,arguments):fn.call(self)}else{// in IE,native methods are not functions so they cannot be bound(note:they don't need to be)
    return fn;
  }
}


function toJsonReplacer(key, value) {
  var val = value;

  if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
    val = undefined;
  } else if (isWindow(value)) {
    val = '$WINDOW';
  } else if (value &&  document === value) {
    val = '$DOCUMENT';
  } else if (isScope(value)) {
    val = '$SCOPE';
  }

  return val;
}


/**
 * @ngdoc function
 * @name angular.toJson
 * @module ng
 * @kind function
 *
 * @description
 * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
 * stripped since angular uses this notation internally.
 *
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
 * @param {boolean|number=} pretty If set to true, the JSON output will contain newlines and whitespace.
 *    If set to an integer, the JSON output will contain that many spaces per indentation (the default is 2).
 * @returns {string|undefined} JSON-ified string representing `obj`.
 */
function toJson(obj, pretty) {
  if (typeof obj === 'undefined') return undefined;
  if (!isNumber(pretty)) {
    pretty = pretty ? 2 : null;
  }
  return JSON.stringify(obj, toJsonReplacer, pretty);
}


/**
 * @ngdoc function
 * @name angular.fromJson
 * @module ng
 * @kind function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|string|number} Deserialized JSON string.
 */
function fromJson(json) {
  return isString(json)
      ? JSON.parse(json)
      : json;
}


/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
  element = jqLite(element).clone();
  try {
    // turns out IE does not let you set .html() on elements which
    // are not allowed to have children. So we just ignore it.
    element.empty();
  } catch (e) {}
  var elemHtml = jqLite('<div>').append(element).html();
  try {
    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
  } catch (e) {
    return lowercase(elemHtml);
  }

}


/////////////////////////////////////////////////

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @private
 * @param str value potential URI component to check.
 * @returns {boolean} True if `value` can be decoded
 * with the decodeURIComponent function.
 */
function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch (e) {
    // Ignore any invalid uri component
  }
}


/**
 * Parses an escaped url query string into key-value pairs.
 * @returns {Object.<string,boolean|Array>}
 */
function parseKeyValue(/**string*/keyValue) {
  var obj = {}, key_value, key;
  forEach((keyValue || "").split('&'), function(keyValue) {
    if (keyValue) {
      key_value = keyValue.replace(/\+/g,'%20').split('=');
      key = tryDecodeURIComponent(key_value[0]);
      if (isDefined(key)) {
        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
        if (!hasOwnProperty.call(obj, key)) {
          obj[key] = val;
        } else if (isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key],val];
        }
      }
    }
  });
  return obj;
}

function toKeyValue(obj) {
  var parts = [];
  forEach(obj, function(value, key) {
    if (isArray(value)) {
      forEach(value, function(arrayValue) {
        parts.push(encodeUriQuery(key, true) +
                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
      });
    } else {
    parts.push(encodeUriQuery(key, true) +
               (value === true ? '' : '=' + encodeUriQuery(value, true)));
    }
  });
  return parts.length ? parts.join('&') : '';
}


/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow * http://www.ietf.org/rfc/rfc3986txt with regards to the character set(pchar) allowed in path * segments:* segment = *pchar * pchar = unreserved / pct-encoded / sub-delims / ":" / "@" * pct-encoded = "%" HEXDIG HEXDIG * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~" * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" * / "*" / "+" / "," / ";" / "=" */ function encodeUriSegment(val) { return encodeUriQuery(val,true). replace(/%26/gi,'&'). replace(/%3D/gi,'='). replace(/%2B/gi,'+')}function encodeUriQuery(val,pctEncodeSpaces){return encodeURIComponent(val). replace(/%40/gi,'@'). replace(/%3A/gi,':'). replace(/%24/g,'$'). replace(/%2C/gi,','). replace(/%3B/gi,';'). replace(/%20/g(pctEncodeSpaces ? '%20':'+'))}'data-ng-''ng:''x-ng-']; function getNgAttribute(element,ngAttr)var ngAttrPrefixes = ['ng-'{:var attr,i,ii = ngAttrPrefixes.length;:element = jqLite(element);:for(i = 0;:i < ii;:++i) { attr = ngAttrPrefixes[i]+ ngAttr;:if(isString(attr = element.attr(attr))) { return attr}function angularInit(element,bootstrap){:var appElement,module,config = {}; // The element `element` has priority over any other element forEach(ngAttrPrefixes,function(prefix){:var name = prefix + 'app';:if(!appElement && element.hasAttribute && element.hasAttribute(name)) { appElement = element;:module = element.getAttribute(name)}); forEach(ngAttrPrefixes,function(prefix){:var name = prefix + 'app';:var candidate;:if(!appElement &&(candidate = element.querySelector('[' + name.replace(':','\\:') + ']'))) { appElement = candidate;:module = candidate.getAttribute(name)}); if (appElement){:config.strictDi = getNgAttribute(appElement,"strict-di") !== null;:bootstrap(appElement,module ?[module[],config)}function bootstrap(element,modules,config){:if(!isObject(config)) config = {}; var defaultConfig ={strictDi:false}; config = extend(defaultConfig,config); var doBootstrap = function(){:element = jqLite(element);if(element.injector()) { var tag =(element[0]=== document) ? 'document':startingTag(element);://Encode angle brackets to prevent input from being sanitized to empty string #8683 throw ngMinErr('btstrpd',"App Already Bootstrapped with this Element '{0}'",tag.replace(/</,'&lt;').replace(/>/,'&gt;'))}modules = modules || []; modules.unshift(['$provide',function($provide){:$provide.value('$rootElement',element)}]); if (config.debugInfoEnabled){:// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.
      modules.push(['$compileProvider', function($compileProvider) {
        $compileProvider.debugInfoEnabled(true);
      }]);
    }

    modules.unshift('ng');
    var injector = createInjector(modules, config.strictDi);
    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
       function bootstrapApply(scope, element, compile, injector) {
        scope.$apply(function() {
          element.data('$injector', injector);
          compile(element)(scope);
        });
      }]
    );
    return injector;
  };

  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
    config.debugInfoEnabled = true;
    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
  }

  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    doBootstrap();
  };
}

/**
 * @ngdoc function
 * @name angular.reloadWithDebugInfo
 * @module ng
 * @description
 * Use this function to reload the current application with debug information turned on.
 * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.
 *
 * See {@link ng.$compileProvider#debugInfoEnabled} for more.
 */
function reloadWithDebugInfo() {
  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
  window.location.reload();
}

/**
 * @name angular.getTestability
 * @module ng
 * @description
 * Get the testability service for the instance of Angular on the given
 * element.
 * @param {DOMElement} element DOM element which is the root of angular application.
 */
function getTestability(rootElement) {
  var injector = angular.element(rootElement).injector();
  if (!injector) {
    throw ngMinErr('test',
      'no injector found for element argument to getTestability');
  }
  return injector.get('$$testability');
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator) {
  separator = separator || '_';
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}

var bindJQueryFired = false;
var skipDestroyOnNextJQueryCleanData;
function bindJQuery() {
  var originalCleanData;

  if (bindJQueryFired) {
    return;
  }

  // bind to jQuery if present;
  jQuery = window.jQuery;
  // Use jQuery if it exists with proper functionality, otherwise default to us.
  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.
  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older
  // versions. It will not work for sure with jQuery <1.7, though.
  if (jQuery && jQuery.fn.on) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });

    // All nodes removed from the DOM via various jQuery APIs like .remove()
    // are passed through jQuery.cleanData. Monkey-patch this method to fire
    // the $destroy event on all removed nodes.
    originalCleanData = jQuery.cleanData;
    jQuery.cleanData = function(elems) {
      var events;
      if (!skipDestroyOnNextJQueryCleanData) {
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
          events = jQuery._data(elem, "events");
          if (events && events.$destroy) {
            jQuery(elem).triggerHandler('$destroy');
          }
        }
      } else {
        skipDestroyOnNextJQueryCleanData = false;
      }
      originalCleanData(elems);
    };
  } else {
    jqLite = JQLite;
  }

  angular.element = jqLite;

  // Prevent double-proxying.
  bindJQueryFired = true;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}?'), (reason || "required"));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, 'not a function,got ' +
      (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
  return arg;
}

/**
 * throw error if the name given is hasOwnProperty
 * @param  {String} name    the name to test
 * @param  {String} context the context in which the name is used, such as module or directive
 */
function assertNotHasOwnProperty(name, context) {
  if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
  }
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {String} path path to traverse
 * @param {boolean} [bindFnToScope=true]
 * @returns {Object} value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split('.');
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array} array like object
 * @returns {jqLite} jqLite collection containing the nodes
 */
function getBlockNodes(nodes) {
  // TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
  //             collection, otherwise update the original collection.
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  do {
    node = node.nextSibling;
    if (!node) break;
    blockNodes.push(node);
  } while (node !== endNode);

  return jqLite(blockNodes);
}


/**
 * Creates a new object without a prototype. This object is useful for lookup without having to
 * guard against prototypically inherited properties via hasOwnProperty.
 *
 * Related micro-benchmarks:
 * - http://jsperf.com/object-create2
 * - http://jsperf.com/proto-map-lookup/2
 * - http://jsperf.com/for-in-vs-object-keys2
 *
 * @returns {Object}
 */
function createMap() {
  return Object.create(null);
}

var NODE_TYPE_ELEMENT = 1;
var NODE_TYPE_TEXT = 3;
var NODE_TYPE_COMMENT = 8;
var NODE_TYPE_DOCUMENT = 9;
var NODE_TYPE_DOCUMENT_FRAGMENT = 11;

/**
 * @ngdoc type
 * @name angular.Module
 * @module ng
 * @description
 *
 * Interface for configuring angular {@link angular.module modules}.
 */

function setupModuleLoader(window) {

  var $injectorMinErr = minErr('$injector');
  var ngMinErr = minErr('ng');

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  var angular = ensure(window, 'angular', Object);

  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
  angular.$$minErr = angular.$$minErr || minErr;

  return ensure(angular, 'module', function() {
    /** @type {Object.<string, angular.Module>} */
    var modules = {};

    /**
     * @ngdoc function
     * @name angular.module
     * @module ng
     * @description
     *
     * The `angular.module` is a global place for creating, registering and retrieving Angular
     * modules.
     * All modules (angular core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     * When passed two or more arguments, a new module is created.  If passed only one argument, an
     * existing module (the name passed as the first argument to `module`) is retrieved.
     *
     *
     * # Module
     *
     * A module is a collection of services, directives, controllers, filters, and configuration information.
     * `angular.module` is used to configure the {@link auto.$injector $injector}.
     *
     * ```js
     * // Create a new module
     * var myModule = angular.module('myModule', []);
     *
     * // register a new service
     * myModule.value('appName', 'MyCoolApp');
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(['$locationProvider', function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * }]);
     * ```
     *
     * Then you can create an injector and load your modules like this:
     *
     * ```js
     * var injector = angular.injector(['ng', 'myModule'])
     * ```
     *
     * However it's more likely that you'll just use
     * {@link ng.directive:ngApp ngApp} or
     * {@link angular.bootstrap} to simplify this process for you.
     *
     * @param {!string} name The name of the module to create or retrieve.
     * @param {!Array.<string>=} requires If specified then new module is being created. If
     *        unspecified then the module is being retrieved for further configuration.
     * @param {Function=} configFn Optional configuration function for the module. Same as
     *        {@link angular.Module#config Module#config()}.
     * @returns {module} new module with the {@link angular.Module} api.
     */
    return function module(name, requires, configFn) {
      var assertNotHasOwnProperty = function(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', 'hasOwnProperty is not a valid,name', context);
        }
      };

      assertNotHasOwnProperty(name, 'module');
      if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw $injectorMinErr('nomod', "Module '{:0}; function publishExternalAPI(angular){extend(angular,{ 'bootstrap':bootstrap,'copy':copy,'extend':extend,'equals':equals,'element':jqLite,'forEach':forEach,'injector':createInjector,'noop':noop,'bind':bind,'toJson':toJson,'fromJson':fromJson,'identity':identity,'isUndefined':isUndefined,'isDefined':isDefined,'isString':isString,'isFunction':isFunction,'isObject':isObject,'isNumber':isNumber,'isElement':isElement,'isArray':isArray,'version':version,'isDate':isDate,'lowercase':lowercase,'uppercase':uppercase,'callbacks':{counter:0}); angularModule = setupModuleLoader(window); try{:angularModule('ngLocale')}angularModule('ng',['ngLocale'],['$provide',function ngModule($provide){// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it. $provide.provider({ $$sanitizeUri:$$SanitizeUriProvider}); $provide.provider('$compile',$CompileProvider). directive({a:htmlAnchorDirective,input:inputDirective,textarea:inputDirective,form:formDirective,script:scriptDirective,select:selectDirective,style:styleDirective,option:optionDirective,ngBind:ngBindDirective,ngBindHtml:ngBindHtmlDirective,ngBindTemplate:ngBindTemplateDirective,ngClass:ngClassDirective,ngClassEven:ngClassEvenDirective,ngClassOdd:ngClassOddDirective,ngCloak:ngCloakDirective,ngController:ngControllerDirective,ngForm:ngFormDirective,ngHide:ngHideDirective,ngIf:ngIfDirective,ngInclude:ngIncludeDirective,ngInit:ngInitDirective,ngNonBindable:ngNonBindableDirective,ngPluralize:ngPluralizeDirective,ngRepeat:ngRepeatDirective,ngShow:ngShowDirective,ngStyle:ngStyleDirective,ngSwitch:ngSwitchDirective,ngSwitchWhen:ngSwitchWhenDirective,ngSwitchDefault:ngSwitchDefaultDirective,ngOptions:ngOptionsDirective,ngTransclude:ngTranscludeDirective,ngModel:ngModelDirective,ngList:ngListDirective,ngChange:ngChangeDirective,pattern:patternDirective,ngPattern:patternDirective,required:requiredDirective,ngRequired:requiredDirective,minlength:minlengthDirective,ngMinlength:minlengthDirective,maxlength:maxlengthDirective,ngMaxlength:maxlengthDirective,ngValue:ngValueDirective,ngModelOptions:ngModelOptionsDirective}). directive({ngInclude:ngIncludeFillContentDirective}). directive(ngAttributeAliasDirectives). directive(ngEventDirectives); $provide.provider({$anchorScroll:$AnchorScrollProvider,$animate:$AnimateProvider,$browser:$BrowserProvider,$cacheFactory:$CacheFactoryProvider,$controller:$ControllerProvider,$document:$DocumentProvider,$exceptionHandler:$ExceptionHandlerProvider,$filter:$FilterProvider,$interpolate:$InterpolateProvider,$interval:$IntervalProvider,$http:$HttpProvider,$httpBackend:$HttpBackendProvider,$location:$LocationProvider,$log:$LogProvider,$parse:$ParseProvider,$rootScope:$RootScopeProvider,$q:$QProvider,$$q:$$QProvider,$sce:$SceProvider,$sceDelegate:$SceDelegateProvider,$sniffer:$SnifferProvider,$templateCache:$TemplateCacheProvider,$templateRequest:$TemplateRequestProvider,$$testability:$$TestabilityProvider,$timeout:$TimeoutProvider,$window:$WindowProvider,$$rAF:$$RAFProvider,$$asyncCallback:$$AsyncCallbackProvider,$$jqLite:$$jqLiteProvider},jqId = 1,addEventListenerFn = function(element,type,fn){:element.addEventListener(type,fn,false)},removeEventListenerFn = function(element,type,fn){:element.removeEventListener(type,fn,false)}; JQLite._data = function(node){://jQuery always returns an object on cache miss return this.cache[node[this.expando]]|| {}; function jqNextId(){:return ++jqId}var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g; var MOZ_HACK_REGEXP = /^moz([A-Z])/; var MOUSE_EVENT_MAP={mouseleave:"mouseout",mouseenter:"mouseover"}; var jqLiteMinErr = minErr('jqLite'); function camelCase(name){return name. replace(SPECIAL_CHARS_REGEXP,function(_,separator,letter,offset) { return offset ? letter.toUpperCase():letter}var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/; var HTML_REGEXP = /<|&#?\w+;/; var TAG_NAME_REGEXP = /<([\w:]+)/; var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi; var wrapMap ={'option'[1,'<select multiple="multiple">','</select>'],'thead'[1,'<table>','</table>'],'col'[2,'<table><colgroup>','</colgroup></table>'],'tr'[2,'<table><tbody>','</tbody></table>'],'td'[3,'<table><tbody><tr>','</tr></tbody></table>'],'_default'[0,"",""]}; wrapMap.optgroup = wrapMap.option; wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead; wrapMap.th = wrapMap.td; function jqLiteIsTextNode(html){:return !HTML_REGEXP.test(html)}function jqLiteAcceptsData(node){:// The window object can accept data but has no nodeType // Otherwise we are only interested in elements(1) and documents(9) var nodeType = node.nodeType;:return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT}function jqLiteBuildFragment(html,context){:var tmp,tag,wrap,fragment = context.createDocumentFragment(),nodes =[],i;:if(jqLiteIsTextNode(html)) { // Convert non-html into a text node nodes.push(context.createTextNode(html))}// Remove wrapper from fragment fragment.textContent = ""; fragment.innerHTML = ""; // Clear inner HTML forEach(nodes,function(node){:fragment.appendChild(node)}function jqLiteParseHTML(html,context){:context = context || document;:var parsed;:if((parsed = SINGLE_TAG_REGEXP.exec(html))) { return[context.createElement(parsed[1])]}if ((parsed = jqLiteBuildFragment(html,context))){:return parsed.childNodes}///////////////////////////////////////////// function JQLite(element){:if(element instanceof JQLite) { return element}var argIsString; if (isString(element)){:element = trim(element);:argIsString = true}if (!(this instanceof JQLite)){:if(argIsString && element.charAt(0) != '<') { throw jqLiteMinErr('nosel','Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element')}if (argIsString){:jqLiteAddNodes(this,jqLiteParseHTML(element))}function jqLiteClone(element){:return element.cloneNode(true)}function jqLiteDealoc(element,onlyDescendants){:if(!onlyDescendants) jqLiteRemoveData(element);:if(element.querySelectorAll) { var descendants = element.querySelectorAll('*');:for(var i = 0,l = descendants.length;:i < l;:i++) { jqLiteRemoveData(descendants[i])}function jqLiteOff(element,type,fn,unsupported){:if(isDefined(unsupported)) throw jqLiteMinErr('offargs','jqLite#off() does not support the `selector` argument');:var expandoStore = jqLiteExpandoStore(element);:var events = expandoStore && expandoStore.events;:var handle = expandoStore && expandoStore.handle;:if(!handle) return;://no listeners registered if(!type) { for(type in events) { if(type !== '$destroy') { removeEventListenerFn(element,type,handle)}function jqLiteRemoveData(element,name){:var expandoId = element.ng339;:var expandoStore = expandoId && jqCache[expandoId];:if(expandoStore) { if(name) { delete expandoStore.data[name];:return}if (expandoStore.handle){:if(expandoStore.events.$destroy) { expandoStore.handle({}function jqLiteExpandoStore(element,createIfNecessary){:var expandoId = element.ng339,expandoStore = expandoId && jqCache[expandoId];:if(createIfNecessary && !expandoStore) { element.ng339 = expandoId = jqNextId();expandoStore = jqCache[expandoId]= {events:{}function jqLiteData(element,key,value){:if(jqLiteAcceptsData(element)) { var isSimpleSetter = isDefined(value);:var isSimpleGetter = !isSimpleSetter && key && !isObject(key);:var massGetter = !key;:var expandoStore = jqLiteExpandoStore(element,!isSimpleGetter);:var data = expandoStore && expandoStore.data;:if(isSimpleSetter) { // data('key',value) data[key]= value}else{// mass-setter:data({key1:val1,key2:val2}function jqLiteHasClass(element,selector){:if(!element.getAttribute) return false;:return((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g," "). indexOf(" " + selector + " ") > -1)}function jqLiteRemoveClass(element,cssClasses){:if(cssClasses && element.setAttribute) { forEach(cssClasses.split(' '),function(cssClass) { element.setAttribute('class',trim(" " + (element.getAttribute('class') || '') + " ") .replace(/[\n\t]/g," ") .replace(" " + trim(cssClass) + " "," ")))}function jqLiteAddClass(element,cssClasses){:if(cssClasses && element.setAttribute) { var existingClasses =(' ' + (element.getAttribute('class') || '') + ' ') .replace(/[\n\t]/g," ");:forEach(cssClasses.split(' '),function(cssClass) { cssClass = trim(cssClass);:if(existingClasses.indexOf(' ' + cssClass + ' ') === -1) { existingClasses += cssClass + ' '}function jqLiteAddNodes(root,elements){:// THIS CODE IS VERY HOT. Don't make changes without benchmarking.

  if (elements) {

    // if a Node (the most common case)
    if (elements.nodeType) {
      root[root.length++] = elements;
    } else {
      var length = elements.length;

      // if an Array or NodeList and not a Window
      if (typeof length === 'number' && elements.window !== elements) {
        if (length) {
          for (var i = 0; i < length; i++) {
            root[root.length++] = elements[i];
          }
        }
      } else {
        root[root.length++] = elements;
      }
    }
  }
}


function jqLiteController(element, name) {
  return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
}

function jqLiteInheritedData(element, name, value) {
  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if (element.nodeType == NODE_TYPE_DOCUMENT) {
    element = element.documentElement;
  }
  var names = isArray(name) ? name : [name];

  while (element) {
    for (var i = 0, ii = names.length; i < ii; i++) {
      if ((value = jqLite.data(element, names[i])) !== undefined) return value;
    }

    // If dealing with a document fragment node with a host element, and no parent, use the host
    // element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
    // to lookup parent controllers.
    element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
  }
}

function jqLiteEmpty(element) {
  jqLiteDealoc(element, true);
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

function jqLiteRemove(element, keepData) {
  if (!keepData) jqLiteDealoc(element);
  var parent = element.parentNode;
  if (parent) parent.removeChild(element);
}


function jqLiteDocumentLoaded(action, win) {
  win = win || window;
  if (win.document.readyState === 'complete') {
    // Force the action to be run async for consistent behaviour
    // from the action's point of view // i.e. it will definitely not be in a $apply win.setTimeout(action)}////////////////////////////////////////// // Functions which are declared directly. ////////////////////////////////////////// var JQLitePrototype = JQLite.prototype ={ready:function(fn) { var fired = false;:function trigger() { if(fired) return;:fired = true;:fn()}// check if document is already loaded if (document.readyState === 'complete'){:setTimeout(trigger)},toString: function(){:var value =[];:forEach(this,function(e) { value.push('' + e)},eq: function(index){return(index >= 0) ? jqLite(this[index]):jqLite(this[this.length + index])}; forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','),function(value){:BOOLEAN_ATTR[lowercase(value)]= value}; forEach('input,select,option,textarea,button,form,details'.split(','),function(value){:BOOLEAN_ELEMENTS[value]= true}); var ALIASED_ATTR ={'ngMinlength':'minlength','ngMaxlength':'maxlength','ngMin':'min','ngMax':'max','ngPattern':'pattern'}; function getBooleanAttrName(element,name){:// check dom last since we will most likely fail on name var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];:// booleanAttr is here twice to minimize DOM access return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)]&& booleanAttr}function getAliasedAttrName(element,name){:var nodeName = element.nodeName;:return(nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name]}forEach({data:jqLiteData,removeData:jqLiteRemoveData}); forEach({data:jqLiteData,inheritedData:jqLiteInheritedData,scope:function(element) { // Can't use jqLiteData here directly so we stay compatible with jQuery!
    return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
  },

  isolateScope: function(element) {
    // Can't use jqLiteData here directly so we stay compatible with jQuery! return jqLite.data(element,'$isolateScope') || jqLite.data(element,'$isolateScopeNoTemplate')},controller: jqLiteController,injector: function(element){:return jqLiteInheritedData(element,'$injector')},removeAttr: function(element,name){:element.removeAttribute(name)},hasClass: jqLiteHasClass,css: function(element,name,value){:name = camelCase(name);:if(isDefined(value)) { element.style[name]= value},attr: function(element,name,value){:var lowercasedName = lowercase(name);:if(BOOLEAN_ATTR[lowercasedName]) { if(isDefined(value)) { if(!!value) { element[name]= true;:element.setAttribute(name,lowercasedName)}else{return(element[name]||(element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName:undefined}else if (isDefined(value)){:element.setAttribute(name,value)}else if (element.getAttribute){// the extra argument "2" is to get the right thing for a.href in IE,see jQuery code // some elements(e.g. Document) don't have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: (function() {
    getText.$dv = '';
    return getText;

    function getText(element, value) {
      if (isUndefined(value)) {
        var nodeType = element.nodeType;
        return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
      }
      element.textContent = value;
    }
  })(),

  val: function(element, value) {
    if (isUndefined(value)) {
      if (element.multiple && nodeName_(element) === 'select') {
        var result = [];
        forEach(element.options, function(option) {
          if (option.selected) {
            result.push(option.value || option.text);
          }
        });
        return result.length === 0 ? null : result;
      }
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    jqLiteDealoc(element, true);
    element.innerHTML = value;
  },

  empty: jqLiteEmpty
}, function(fn, name) {
  /**
   * Properties: writes return selection, reads return first value
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;
    var nodeCount = this.length;

    // jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    // jqLiteEmpty takes no arguments but is a setter.
    if (fn !== jqLiteEmpty &&
        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for (i = 0; i < nodeCount; i++) {
          if (fn === jqLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        // TODO: do we still need this?
        var value = fn.$dv;
        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
          var nodeValue = fn(this[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        }
        return value;
      }
    } else {
      // we are a write, so apply to all children
      for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
  };
});

function createEventHandler(element, events) {
  var eventHandler = function(event, type) {
    // jQuery specific api
    event.isDefaultPrevented = function() {
      return event.defaultPrevented;
    };

    var eventFns = events[type || event.type];
    var eventFnsLength = eventFns ? eventFns.length : 0;

    if (!eventFnsLength) return;

    if (isUndefined(event.immediatePropagationStopped)) {
      var originalStopImmediatePropagation = event.stopImmediatePropagation;
      event.stopImmediatePropagation = function() {
        event.immediatePropagationStopped = true;

        if (event.stopPropagation) {
          event.stopPropagation();
        }

        if (originalStopImmediatePropagation) {
          originalStopImmediatePropagation.call(event);
        }
      };
    }

    event.isImmediatePropagationStopped = function() {
      return event.immediatePropagationStopped === true;
    };

    // Copy event handlers in case event handlers array is modified during execution.
    if ((eventFnsLength > 1)) {
      eventFns = shallowCopy(eventFns);
    }

    for (var i = 0; i < eventFnsLength; i++) {
      if (!event.isImmediatePropagationStopped()) {
        eventFns[i].call(element, event);
      }
    }
  };

  // TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all
  //       events on `element`
  eventHandler.elem = element;
  return eventHandler;
}

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
forEach({
  removeData: jqLiteRemoveData,

  on: function jqLiteOn(element, type, fn, unsupported) {
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');

    // Do not add event handlers to non-elements because they will not be cleaned up.
    if (!jqLiteAcceptsData(element)) {
      return;
    }

    var expandoStore = jqLiteExpandoStore(element, true);
    var events = expandoStore.events;
    var handle = expandoStore.handle;

    if (!handle) {
      handle = expandoStore.handle = createEventHandler(element, events);
    }

    // http://jsperf.com/string-indexof-vs-split
    var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
    var i = types.length;

    while (i--) {
      type = types[i];
      var eventFns = events[type];

      if (!eventFns) {
        events[type] = [];

        if (type === 'mouseenter' || type === 'mouseleave') {
          // Refer to jQuery's implementation of mouseenter & mouseleave // Read about mouseenter and mouseleave:// http://www.quirksmode.org/js/events_mouse.html#link8 jqLiteOn(element,MOUSE_EVENT_MAP[type],function(event) { var target = this,related = event.relatedTarget;// For mousenter/leave call the handler if related is outside the target. // NB:No relatedTarget if the mouse left/entered the browser window if(!related ||(related !== target && !target.contains(related))) { handle(event,type)},off: jqLiteOff,one: function(element,type,fn){:element = jqLite(element);://add the listener twice so that when it is called //you can remove the original function and still be //able to call element.off(ev,fn) normally element.on(type,function onFn() { element.off(type,fn);:element.off(type,onFn)},replaceWith: function(element,replaceNode){:var index,parent = element.parentNode;:jqLiteDealoc(element);:forEach(new JQLite(replaceNode),function(node) { if(index) { parent.insertBefore(node,index.nextSibling)},children: function(element){:var children =[];:forEach(element.childNodes,function(element) { if(element.nodeType === NODE_TYPE_ELEMENT) children.push(element)},contents: function(element){:return element.contentDocument || element.childNodes ||[]},append: function(element,node){:var nodeType = element.nodeType;:if(nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;:node = new JQLite(node);:for(var i = 0,ii = node.length;:i < ii;:i++) { var child = node[i];:element.appendChild(child)},prepend: function(element,node){:if(element.nodeType === NODE_TYPE_ELEMENT) { var index = element.firstChild;:forEach(new JQLite(node),function(child) { element.insertBefore(child,index)},wrap: function(element,wrapNode){:wrapNode = jqLite(wrapNode).eq(0).clone()[0];:var parent = element.parentNode;:if(parent) { parent.replaceChild(wrapNode,element)},remove: jqLiteRemove,detach: function(element){:jqLiteRemove(element,true)},after: function(element,newElement){:var index = element,parent = element.parentNode;:newElement = new JQLite(newElement);:for(var i = 0,ii = newElement.length;:i < ii;:i++) { var node = newElement[i];:parent.insertBefore(node,index.nextSibling);:index = node},addClass: jqLiteAddClass,removeClass: jqLiteRemoveClass,toggleClass: function(element,selector,condition){:if(selector) { forEach(selector.split(' '),function(className) { var classCondition = condition;:if(isUndefined(classCondition)) { classCondition = !jqLiteHasClass(element,className)},parent: function(element){:var parent = element.parentNode;return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent:null},next: function(element){:return element.nextElementSibling},find: function(element,selector){:if(element.getElementsByTagName) { return element.getElementsByTagName(selector)},clone: jqLiteClone,triggerHandler: function(element,event,extraParameters){:var dummyEvent,eventFnsCopy,handlerArgs;:var eventName = event.type || event;:var expandoStore = jqLiteExpandoStore(element);:var events = expandoStore && expandoStore.events;:var eventFns = events && events[eventName];if(eventFns) { // Create a dummy event to pass to the handlers dummyEvent = { preventDefault:function() { this.defaultPrevented = true},isDefaultPrevented: function(){:return this.defaultPrevented === true},stopImmediatePropagation: function(){:this.immediatePropagationStopped = true},isImmediatePropagationStopped: function(){:return this.immediatePropagationStopped === true}; // If a custom event was provided then extend our dummy event with it if (event.type){:dummyEvent = extend(dummyEvent,event)}// Copy event handlers in case event handlers array is modified during execution. eventFnsCopy = shallowCopy(eventFns); handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent]; forEach(eventFnsCopy,function(fn){:if(!dummyEvent.isImmediatePropagationStopped()) { fn.apply(element,handlerArgs)},function(fn,name){:JQLite.prototype[name]= function(arg1,arg2,arg3) { var value;:for(var i = 0,ii = this.length;:i < ii;:i++) { if(isUndefined(value)) { value = fn(this[i],arg1,arg2,arg3);:if(isDefined(value)) { // any function which returns a value needs to be wrapped value = jqLite(value)}); // Provider for private $$jqLite service function $$jqLiteProvider(){this.$get = function $$jqLite() { return extend(JQLite,{ hasClass:function(node,classes) { if(node.attr) node = node[0];:return jqLiteHasClass(node,classes)},addClass: function(node,classes){:if(node.attr) node = node[0];:return jqLiteAddClass(node,classes)},removeClass: function(node,classes){:if(node.attr) node = node[0];:return jqLiteRemoveClass(node,classes)}function hashKey(obj,nextUidFn){:var key = obj && obj.$$hashKey;:if(key) { if(typeof key === 'function') { key = obj.$$hashKey()}var objType = typeof obj; if (objType == 'function' || (objType == 'object' && obj !== null)){:key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)()}function HashMap(array,isolatedUid){:if(isolatedUid) { var uid = 0;:this.nextUid = function() { return ++uid}HashMap.prototype ={put:function(key,value) { this[hashKey(key,this.nextUid)]= value},get: function(key){:return this[hashKey(key,this.nextUid)]},remove: function(key){:var value = this[key = hashKey(key,this.nextUid)];:delete this[key];:return value}/; var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/; var STRIP_COMMENTS = /((\/\/.*$)|(\/\[\s\S]*?\*\/))/mg; var $injectorMinErr = minErr('$injector'); function anonFn(fn),; var FN_ARGS = /^function\s[^\(]*\(\s*([^\)]*)\)/m; var FN_ARG_SPLIT = /{:// For anonymous functions,showing at the very least the function signature can help in // debugging. var fnText = fn.toString().replace(STRIP_COMMENTS,''),args = fnText.match(FN_ARGS);:if(args) { return 'function(' + (args[1]|| '').replace(/[\s\r\n]+/,' ') + ')'}function annotate(fn,strictDi,name){:var $inject,fnText,argDecl,last;:if(typeof fn === 'function') { if(!($inject = fn.$inject)) { $inject =[];:if(fn.length) { if(strictDi) { if(!isString(name) || !name) { name = fn.name || anonFn(fn)}fnText = fn.toString().replace(STRIP_COMMENTS,''); argDecl = fnText.match(FN_ARGS); forEach(argDecl[1].split(FN_ARG_SPLIT),function(arg){:arg.replace(FN_ARG,function(all,underscore,name) { $inject.push(name)}else if (isArray(fn)){:last = fn.length - 1;:assertArgFn(fn[last],'fn');:$inject = fn.slice(0,last)}/////////////////////////////////////// function createInjector(modulesToLoad,strictDi){:strictDi =(strictDi === true);:var INSTANTIATING = {},providerSuffix = 'Provider',loadedModules = new HashMap([],true),path = [],providerCache ={$provide:{ provider:supportObject(provider),factory:supportObject(factory),service:supportObject(service),value:supportObject(value),constant:supportObject(constant),decorator:decorator},providerInjector = (providerCache.$injector = createInternalInjector(providerCache,function(serviceName,caller){:if(angular.isString(caller)) { path.push(caller)},instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache,function(serviceName,caller){:var provider = providerInjector.get(serviceName + providerSuffix,caller);:return instanceInjector.invoke(provider.$get,provider,undefined,serviceName)})); forEach(loadModules(modulesToLoad),function(fn){:instanceInjector.invoke(fn || noop)}); return instanceInjector; //////////////////////////////////// // $provider //////////////////////////////////// function supportObject(delegate){:return function(key,value) { if(isObject(key)) { forEach(key,reverseParams(delegate))}function provider(name,provider_){:assertNotHasOwnProperty(name,'service');:if(isFunction(provider_) || isArray(provider_)) { provider_ = providerInjector.instantiate(provider_)}if (!provider_.$get){:throw $injectorMinErr('pget',"Provider '{0}' must define $get factory method.",name)}function enforceReturnValue(name,factory){:return function enforcedReturnValue() { var result = instanceInjector.invoke(factory,this);:if(isUndefined(result)) { throw $injectorMinErr('undef',"Provider '{0}' must return a value from $get factory method.",name)}function factory(name,factoryFn,enforce){return provider(name,{ $get:enforce !== false ? enforceReturnValue(name,factoryFn):factoryFn}function service(name,constructor){:return factory(name['$injector',function($injector) { return $injector.instantiate(constructor)}function value(name,val){:return factory(name,valueFn(val),false)}function constant(name,value){:assertNotHasOwnProperty(name,'constant');:providerCache[name]= value;:instanceCache[name]= value}function decorator(serviceName,decorFn){:var origProvider = providerInjector.get(serviceName + providerSuffix),orig$get = origProvider.$get;:origProvider.$get = function() { var origInstance = instanceInjector.invoke(orig$get,origProvider);return instanceInjector.invoke(decorFn,null,{$delegate:origInstance}//////////////////////////////////// // Module Loading //////////////////////////////////// function loadModules(modulesToLoad){:var runBlocks =[],moduleFn;:forEach(modulesToLoad,function(module) { if(loadedModules.get(module)) return;:loadedModules.put(module,true);:function runInvokeQueue(queue) { var i,ii;:for(i = 0,ii = queue.length;:i < ii;:i++) { var invokeArgs = queue[i],provider = providerInjector.get(invokeArgs[0]);:provider[invokeArgs[1]].apply(provider,invokeArgs[2])}else if (isArray(module)),else if (isFunction(module)){:runBlocks.push(providerInjector.invoke(module))}if (e.message && e.stack && e.stack.indexOf(e.message) == -1){:// Safari & FF's stack traces don't contain error.message content // unlike those of Chrome and IE // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here. e = e.message + '\n' + e.stack}//////////////////////////////////// // internal Injector //////////////////////////////////// function createInternalInjector(cache,factory){:function getService(serviceName,caller) { if(cache.hasOwnProperty(serviceName)) { if(cache[serviceName]=== INSTANTIATING) { throw $injectorMinErr('cdep','Circular dependency found: {0}',serviceName + ' <- ' + path.join(' <- '))}catch (err){:if(cache[serviceName]=== INSTANTIATING) { delete cache[serviceName]}function invoke(fn,self,locals,serviceName){:if(typeof locals === 'string') { serviceName = locals;:locals = null}$inject = annotate(fn,strictDi,serviceName),i,key; for (i = 0,length = $inject.length; i < length; i++),length,var args = []{:key = $inject[i];:if(typeof key !== 'string') { throw $injectorMinErr('itkn','Incorrect injection token! Expected service name as string, got {0}',key)}if (isArray(fn)){:fn = fn[length]}function instantiate(Type,locals,serviceName){:// Check if Type is annotated and use just the given function at n-1 as parameter // e.g. someModule.factory('greeter'['$window',function(renamed$window) {}return{invoke:invoke,instantiate:instantiate,get:getService,annotate:annotate,has:function(name) { return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)}createInjector.$$annotate = annotate; function $AnchorScrollProvider(){:var autoScrollingEnabled = true;:this.disableAutoScrolling = function() { autoScrollingEnabled = false}; this.$get = ['$window','$location''$rootScope'function($window,$location,$rootScope){:var document = $window.document;:// Helper function to get first anchor from a NodeList // (using `Array#some()` instead of `angular#forEach()` since it's more performant
    //  and working in all supported browsers.)
    function getFirstAnchor(list) {
      var result = null;
      Array.prototype.some.call(list, function(element) {
        if (nodeName_(element) === 'a') {
          result = element;
          return true;
        }
      });
      return result;
    }

    function getYOffset() {

      var offset = scroll.yOffset;

      if (isFunction(offset)) {
        offset = offset();
      } else if (isElement(offset)) {
        var elem = offset[0];
        var style = $window.getComputedStyle(elem);
        if (style.position !== 'fixed') {
          offset = 0;
        } else {
          offset = elem.getBoundingClientRect().bottom;
        }
      } else if (!isNumber(offset)) {
        offset = 0;
      }

      return offset;
    }

    function scrollTo(elem) {
      if (elem) {
        elem.scrollIntoView();

        var offset = getYOffset();

        if (offset) {
          // `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
          // This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
          // top of the viewport.
          //
          // IF the number of pixels from the top of `elem` to the end of the page's content is less // than the height of the viewport,then `elem.scrollIntoView()` will align the `elem` some // way down the page. // // This is often the case for elements near the bottom of the page. // // In such cases we do not need to scroll the whole `offset` up,just the difference between // the top of the element and the offset,which is enough to align the top of `elem` at the // desired position. var elemTop = elem.getBoundingClientRect().top;:$window.scrollBy(0,elemTop - offset)}function scroll(){:var hash = $location.hash(),elm;:// empty hash,scroll to the top of the page if(!hash) scrollTo(null);:// element with given id else if((elm = document.getElementById(hash))) scrollTo(elm);// first anchor with given name:-D else if((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);:// no element and hash == 'top',scroll to the top of the page else if(hash === 'top') scrollTo(null)}// does not scroll when user clicks on anchor link that is currently on // (no url change,no $location.hash() change),browser native does scroll if (autoScrollingEnabled){:$rootScope.$watch(function autoScrollWatch() {return $location.hash()},function autoScrollWatchAction(newVal,oldVal){:// skip the initial scroll if $location.hash is empty if(newVal === oldVal && newVal === '') return;:jqLiteDocumentLoaded(function() { $rootScope.$evalAsync(scroll)}function($provide),var $animateMinErr = minErr('$animate'); var $AnimateProvider = ['$provide'{:this.$$selectors = {}; this.register = function(name,factory){:var key = name + '-animation';:if(name && name.charAt(0) != '.') throw $animateMinErr('notcsel',"Expecting class selector starting with '.' got '{0}'.",name);:this.$$selectors[name.substr(1)]= key;:$provide.factory(key,factory)}; this.classNameFilter = function(expression){if(arguments.length === 1) { this.$$classNameFilter =(expression instanceof RegExp) ? expression:null}; this.$get = ['$$q','$rootScope''$$asyncCallback'function($$q,$$asyncCallback,$rootScope){:var currentDefer;:function runAnimationPostDigest(fn) { var cancelFn,defer = $$q.defer();:defer.promise.$$cancelFn = function ngAnimateMaybeCancel() { cancelFn && cancelFn()}; $rootScope.$$postDigest(function ngAnimatePostDigest(){:cancelFn = fn(function ngAnimateNotifyComplete() { defer.resolve()}function resolveElementClasses(element,classes){:var toAdd =[],toRemove =[];:var hasClasses = createMap();:forEach((element.attr('class') || '').split(/\s+/),function(className) { hasClasses[className]= true}); forEach(classes,function(status,className){:var hasClass = hasClasses[className];:// If the most recent class manipulation(via $animate) was to remove the class,and the // element currently has the class,the class is scheduled for removal. Otherwise,if // the most recent class manipulation(via $animate) was to add the class,and the // element does not currently have the class,the class is scheduled to be added. if(status === false && hasClass) { toRemove.push(className)}else if (status === true && !hasClass){:toAdd.push(className)}function cachedClassManipulation(cache,classes,op){:for(var i=0,ii = classes.length;:i < ii;:++i) { var className = classes[i];:cache[className]= op}function asyncPromise(){:// only serve one instance of a promise in order to save CPU cycles if(!currentDefer) { currentDefer = $$q.defer();:$$asyncCallback(function() { currentDefer.resolve();:currentDefer = null}function applyStyles(element,options){:if(angular.isObject(options)) { var styles = extend(options.from || {}return{animate:function(element,from,to) { applyStyles(element,{ from:from,to:to},enter: function(element,parent,after,options){:applyStyles(element,options);after ? after.after(element):parent.prepend(element);:return asyncPromise()},leave: function(element,options){:element.remove();:return asyncPromise()},move: function(element,parent,after,options){:// Do not remove element before insert. Removing will cause data associated with the // element to be dropped. Insert will implicitly do the remove. return this.enter(element,parent,after,options)},addClass: function(element,className,options){:return this.setClass(element,className[],options)},$$addClassImmediately: function(element,className,options){:element = jqLite(element);className = !isString(className) ?(isArray(className) ? className.join(' '):''):className;:forEach(element,function(element) { jqLiteAddClass(element,className)},removeClass: function(element,className,options){:return this.setClass(element[],className,options)},$$removeClassImmediately: function(element,className,options){:element = jqLite(element);className = !isString(className) ?(isArray(className) ? className.join(' '):''):className;:forEach(element,function(element) { jqLiteRemoveClass(element,className)},setClass: function(element,add,remove,options){:var self = this;:var STORAGE_KEY = '$$animateClasses';:var createdCache = false;:element = jqLite(element);:var cache = element.data(STORAGE_KEY);if(!cache) { cache = { classes:{}else if (options && cache.options){:cache.options = angular.extend(cache.options || {}var classes = cache.classes; add = isArray(add) ? add : add.split(' '); remove = isArray(remove) ? remove : remove.split(' '); cachedClassManipulation(classes,add,true); cachedClassManipulation(classes,remove,false); if (createdCache){:cache.promise = runAnimationPostDigest(function(done) { var cache = element.data(STORAGE_KEY);:element.removeData(STORAGE_KEY);:// in the event that the element is removed before postDigest // is run then the cache will be undefined and there will be // no need anymore to add or remove and of the element classes if(cache) { var classes = resolveElementClasses(element,cache.classes);:if(classes) { self.$$setClassImmediately(element,classes[0],classes[1],cache.options)},$$setClassImmediately: function(element,add,remove,options){:add && this.$$addClassImmediately(element,add);:remove && this.$$removeClassImmediately(element,remove);:applyStyles(element,options);:return asyncPromise()}]; function $$AsyncCallbackProvider(){:this.$get =['$$rAF','$timeout',function($$rAF,$timeout) { return $$rAF.supported ? function(fn) { return $$rAF(fn)}function Browser(window,document,$log,$sniffer){:var self = this,rawDocument = document[0],location = window.location,history = window.history,setTimeout = window.setTimeout,clearTimeout = window.clearTimeout,pendingDeferIds = {}; self.isMock = false; var outstandingRequestCount = 0; var outstandingRequestCallbacks = []; // TODO(vojta): remove this temporary api self.$$completeOutstandingRequest = completeOutstandingRequest; self.$$incOutstandingRequestCount = function(){:outstandingRequestCount++}; function completeOutstandingRequest(fn){:try { fn.apply(null,sliceArgs(arguments,1))}function getHash(url){:var index = url.indexOf('#');return index === -1 ? '':url.substr(index + 1)}self.notifyWhenNoOutstandingRequests = function(callback){:// force browser to execute all pollFns - this is needed so that cookies and other pollers fire // at some deterministic time in respect to the test runner's actions. Leaving things up to the
    // regular poller would result in flaky tests.
    forEach(pollFns, function(pollFn) { pollFn(); });

    if (outstandingRequestCount === 0) {
      callback();
    } else {
      outstandingRequestCallbacks.push(callback);
    }
  };

  //////////////////////////////////////////////////////////////
  // Poll Watcher API
  //////////////////////////////////////////////////////////////
  var pollFns = [],
      pollTimeout;

  /**
   * @name $browser#addPollFn
   *
   * @param {function()} fn Poll function to add
   *
   * @description
   * Adds a function to the list of functions that poller periodically executes,
   * and starts polling if not started yet.
   *
   * @returns {function()} the added function
   */
  self.addPollFn = function(fn) {
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    return fn;
  };

  /**
   * @param {number} interval How often should browser call poll functions (ms)
   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
   *
   * @description
   * Configures the poller to run in the specified intervals, using the specified
   * setTimeout fn and kicks it off.
   */
  function startPoller(interval, setTimeout) {
    (function check() {
      forEach(pollFns, function(pollFn) { pollFn(); });
      pollTimeout = setTimeout(check, interval);
    })();
  }

  //////////////////////////////////////////////////////////////
  // URL API
  //////////////////////////////////////////////////////////////

  var cachedState, lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      reloadLocation = null;

  cacheState();
  lastHistoryState = cachedState;

  /**
   * @name $browser#url
   *
   * @description
   * GETTER:
   * Without any argument, this method just returns current value of location.href.
   *
   * SETTER:
   * With at least one argument, this method sets url to new value.
   * If html5 history api supported, pushState/replaceState is used, otherwise
   * location.href/location.replace is used.
   * Returns its own instance to allow chaining
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to change url.
   *
   * @param {string} url New url (when used as setter)
   * @param {boolean=} replace Should new url replace current history record?
   * @param {object=} state object to use with pushState/replaceState
   */
  self.url = function(url, replace, state) {
    // In modern browsers `history.state` is `null` by default; treating it separately
    // from `undefined` would cause `$browser.url(/foo)` to change `history.state`
    // to undefined via `pushState`. Instead, let's change `undefined` to `null` here. if(isUndefined(state)) { state = null}// Android Browser BFCache causes location,history reference to become stale. if (location !== window.location) location = window.location; if (history !== window.history) history = window.history; // setter if (url){:var sameState = lastHistoryState === state;// Don't change anything if previous and current URLs and states match. This also prevents
      // IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.
      // See https://github.com/angular/angular.js/commit/ffb2701
      if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
        return self;
      }
      var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
      lastBrowserUrl = url;
      lastHistoryState = state;
      // Don't use history API if only the hash changed // due to a bug in IE10/IE11 which leads // to not firing a `hashchange` nor `popstate` event // in some cases(see #9143). if($sniffer.history &&(!sameBase || !sameState)) { history[replace ? 'replaceState':'pushState'](state,'',url);:cacheState();:// Do the assignment again so that those two variables are referentially identical. lastHistoryState = cachedState}if (replace){:location.replace(url)}else if (!sameBase){:location.href = url}else{expires=Thu,01 Jan 1970 00:00:00 GMT";
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) +
                                ';path=' + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength > 4096) {
            $log.warn("Cookie '" + name +
              "' possibly not set or overflowed because it was too large(" +
              cookieLength + " > 4096 bytes)!");
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split("}parentModel">` and widget definition of
 *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
 *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
 *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
 *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
 *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional. If
 *   you want to shallow watch for changes (i.e. $watchCollection instead of $watch) you can use
 *   `=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).
 *
 * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
 *   If no `attr` name is specified then the attribute name is assumed to be the same as the
 *   local name. Given `<widget my-attr="count = count+value">` and widget definition of
 *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
 *   a function wrapper for the `count = count + value` expression. Often it's desirable to
 *   pass data from the isolated scope via an expression to the parent scope, this can be
 *   done by passing a map of local variable names and values into the expression wrapper fn.
 *   For example, if the expression is `increment(amount)` then we can specify the amount value
 *   by calling the `localFn` as `localFn({amount: 22})`.
 *
 *
 * #### `bindToController`
 * When an isolate scope is used for a component (see above), and `controllerAs` is used, `bindToController: true` will
 * allow a component to have its properties bound to the controller, rather than to scope. When the controller
 * is instantiated, the initial values of the isolate scope bindings are already available.
 *
 * #### `controller`
 * Controller constructor function. The controller is instantiated before the
 * pre-linking phase and it is shared with other directives (see
 * `require` attribute). This allows the directives to communicate with each other and augment
 * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:
 *
 * * `$scope` - Current scope associated with the element
 * * `$element` - Current element
 * * `$attrs` - Current attributes object for the element
 * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:
 *   `function([scope], cloneLinkingFn, futureParentElement)`.
 *    * `scope`: optional argument to override the scope.
 *    * `cloneLinkingFn`: optional argument to create clones of the original transcluded content.
 *    * `futureParentElement`:
 *        * defines the parent to which the `cloneLinkingFn` will add the cloned elements.
 *        * default: `$element.parent()` resp. `$element` for `transclude:'element'` resp. `transclude:true`.
 *        * only needed for transcludes that are allowed to contain non html elements (e.g. SVG elements)
 *          and when the `cloneLinkinFn` is passed,
 *          as those elements need to created and cloned in a special way when they are defined outside their
 *          usual containers (e.g. like `<svg>`).
 *        * See also the `directive.templateNamespace` property.
 *
 *
 * #### `require`
 * Require another directive and inject its controller as the fourth argument to the linking function. The
 * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
 * injected argument will be an array in corresponding order. If no such directive can be
 * found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:
 *
 * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
 * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
 * * `^` - Locate the required controller by searching the element and its parents. Throw an error if not found.
 * * `^^` - Locate the required controller by searching the element's parents. Throw an error if not found.
 * * `?^` - Attempt to locate the required controller by searching the element and its parents or pass
 *   `null` to the `link` fn if not found.
 * * `?^^` - Attempt to locate the required controller by searching the element's parents, or pass
 *   `null` to the `link` fn if not found.
 *
 *
 * #### `controllerAs`
 * Controller alias at the directive scope. An alias for the controller so it
 * can be referenced at the directive template. The directive needs to define a scope for this
 * configuration to be used. Useful in the case when directive is used as component.
 *
 *
 * #### `restrict`
 * String of subset of `EACM` which restricts the directive to a specific directive
 * declaration style. If omitted, the defaults (elements and attributes) are used.
 *
 * * `E` - Element name (default): `<my-directive></my-directive>`
 * * `A` - Attribute (default): `<div my-directive="exp"></div>`
 * * `C` - Class: `<div class="my-directive: exp;"></div>`
 * * `M` - Comment: `<!-- directive: my-directive exp -->`
 *
 *
 * #### `templateNamespace`
 * String representing the document type used by the markup in the template.
 * AngularJS needs this information as those elements need to be created and cloned
 * in a special way when they are defined outside their usual containers like `<svg>` and `<math>`.
 *
 * * `html` - All root nodes in the template are HTML. Root nodes may also be
 *   top-level elements such as `<svg>` or `<math>`.
 * * `svg` - The root nodes in the template are SVG elements (excluding `<math>`).
 * * `math` - The root nodes in the template are MathML elements (excluding `<svg>`).
 *
 * If no `templateNamespace` is specified, then the namespace is considered to be `html`.
 *
 * #### `template`
 * HTML markup that may:
 * * Replace the contents of the directive's element (default).
 * * Replace the directive's element itself (if `replace` is true - DEPRECATED).
 * * Wrap the contents of the directive's element (if `transclude` is true).
 *
 * Value may be:
 *
 * * A string. For example `<div red-on-hover>{{delete_str}}</div>`.
 * * A function which takes two arguments `tElement` and `tAttrs` (described in the `compile`
 *   function api below) and returns a string value.
 *
 *
 * #### `templateUrl`
 * This is similar to `template` but the template is loaded from the specified URL, asynchronously.
 *
 * Because template loading is asynchronous the compiler will suspend compilation of directives on that element
 * for later when the template has been resolved.  In the meantime it will continue to compile and link
 * sibling and parent elements as though this element had not contained any directives.
 *
 * The compiler does not suspend the entire compilation to wait for templates to be loaded because this
 * would result in the whole app "stalling" until all templates are loaded asynchronously - even in the
 * case when only one deeply nested directive has `templateUrl`.
 *
 * Template loading is asynchronous even if the template has been preloaded into the {@link $templateCache}
 *
 * You can specify `templateUrl` as a string representing the URL or as a function which takes two
 * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
 * a string value representing the url.  In either case, the template URL is passed through {@link
 * $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.
 *
 *
 * #### `replace` ([*DEPRECATED*!], will be removed in next major release - i.e. v2.0)
 * specify what the template should replace. Defaults to `false`.
 *
 * * `true` - the template will replace the directive's element.
 * * `false` - the template will replace the contents of the directive's element.
 *
 * The replacement process migrates all of the attributes / classes from the old element to the new
 * one. See the {@link guide/directive#template-expanding-directive
 * Directives Guide} for an example.
 *
 * There are very few scenarios where element replacement is required for the application function,
 * the main one being reusable custom components that are used within SVG contexts
 * (because SVG doesn't work with custom elements in the DOM tree).
 *
 * #### `transclude`
 * Extract the contents of the element where the directive appears and make it available to the directive.
 * The contents are compiled and provided to the directive as a **transclusion function**. See the
 * {@link $compile#transclusion Transclusion} section below.
 *
 * There are two kinds of transclusion depending upon whether you want to transclude just the contents of the
 * directive's element or the entire element:
 *
 * * `true` - transclude the content (i.e. the child nodes) of the directive's element.
 * * `'element'` - transclude the whole of the directive's element including any directives on this
 *   element that defined at a lower priority than this directive. When used, the `template`
 *   property is ignored.
 *
 *
 * #### `compile`
 *
 * ```js
 *   function compile(tElement, tAttrs, transclude) { ... }
 * ```
 *
 * The compile function deals with transforming the template DOM. Since most directives do not do
 * template transformation, it is not used often. The compile function takes the following arguments:
 *
 *   * `tElement` - template element - The element where the directive has been declared. It is
 *     safe to do template transformation on the element and child elements only.
 *
 *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
 *     between all directive compile functions.
 *
 *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`
 *
 * <div class="alert alert-warning">
 * **Note:** The template instance and the link instance may be different objects if the template has
 * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
 * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
 * should be done in a linking function rather than in a compile function.
 * </div>

 * <div class="alert alert-warning">
 * **Note:** The compile function cannot handle directives that recursively use themselves in their
 * own templates or compile functions. Compiling these directives results in an infinite loop and a
 * stack overflow errors.
 *
 * This can be avoided by manually using $compile in the postLink function to imperatively compile
 * a directive's template instead of relying on automatic template compilation via `template` or
 * `templateUrl` declaration or manual compilation inside the compile function.
 * </div>
 *
 * <div class="alert alert-error">
 * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
 *   e.g. does not know about the right outer scope. Please use the transclude function that is passed
 *   to the link function instead.
 * </div>

 * A compile function can have a return value which can be either a function or an object.
 *
 * * returning a (post-link) function - is equivalent to registering the linking function via the
 *   `link` property of the config object when the compile function is empty.
 *
 * * returning an object with function(s) registered via `pre` and `post` properties - allows you to
 *   control when a linking function should be called during the linking phase. See info about
 *   pre-linking and post-linking functions below.
 *
 *
 * #### `link`
 * This property is used only if the `compile` property is not defined.
 *
 * ```js
 *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
 * ```
 *
 * The link function is responsible for registering DOM listeners as well as updating the DOM. It is
 * executed after the template has been cloned. This is where most of the directive logic will be
 * put.
 *
 *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be used by the
 *     directive for registering {@link ng.$rootScope.Scope#$watch watches}.
 *
 *   * `iElement` - instance element - The element where the directive is to be used. It is safe to
 *     manipulate the children of the element only in `postLink` function since the children have
 *     already been linked.
 *
 *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
 *     between all directive linking functions.
 *
 *   * `controller` - a controller instance - A controller instance if at least one directive on the
 *     element defines a controller. The controller is shared among all the directives, which allows
 *     the directives to use the controllers as a communication channel.
 *
 *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
 *     This is the same as the `$transclude`
 *     parameter of directive controllers, see there for details.
 *     `function([scope], cloneLinkingFn, futureParentElement)`.
 *
 * #### Pre-linking function
 *
 * Executed before the child elements are linked. Not safe to do DOM transformation since the
 * compiler linking function will fail to locate the correct elements for linking.
 *
 * #### Post-linking function
 *
 * Executed after the child elements are linked.
 *
 * Note that child elements that contain `templateUrl` directives will not have been compiled
 * and linked since they are waiting for their template to load asynchronously and their own
 * compilation and linking has been suspended until that occurs.
 *
 * It is safe to do DOM transformation in the post-linking function on elements that are not waiting
 * for their async templates to be resolved.
 *
 *
 * ### Transclusion
 *
 * Transclusion is the process of extracting a collection of DOM element from one part of the DOM and
 * copying them to another part of the DOM, while maintaining their connection to the original AngularJS
 * scope from where they were taken.
 *
 * Transclusion is used (often with {@link ngTransclude}) to insert the
 * original contents of a directive's element into a specified place in the template of the directive.
 * The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded
 * content has access to the properties on the scope from which it was taken, even if the directive
 * has isolated scope.
 * See the {@link guide/directive#creating-a-directive-that-wraps-other-elements Directives Guide}.
 *
 * This makes it possible for the widget to have private state for its template, while the transcluded
 * content has access to its originating scope.
 *
 * <div class="alert alert-warning">
 * **Note:** When testing an element transclude directive you must not place the directive at the root of the
 * DOM fragment that is being compiled. See {@link guide/unit-testing#testing-transclusion-directives
 * Testing Transclusion Directives}.
 * </div>
 *
 * #### Transclusion Functions
 *
 * When a directive requests transclusion, the compiler extracts its contents and provides a **transclusion
 * function** to the directive's `link` function and `controller`. This transclusion function is a special
 * **linking function** that will return the compiled contents linked to a new transclusion scope.
 *
 * <div class="alert alert-info">
 * If you are just using {@link ngTransclude} then you don't need to worry about this function, since
 * ngTransclude will deal with it for us.
 * </div>
 *
 * If you want to manually control the insertion and removal of the transcluded content in your directive
 * then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery
 * object that contains the compiled DOM, which is linked to the correct transclusion scope.
 *
 * When you call a transclusion function you can pass in a **clone attach function**. This function accepts
 * two parameters, `function(clone, scope) { ... }`, where the `clone` is a fresh compiled copy of your transcluded
 * content and the `scope` is the newly created transclusion scope, to which the clone is bound.
 *
 * <div class="alert alert-info">
 * **Best Practice**: Always provide a `cloneFn` (clone attach function) when you call a translude function
 * since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.
 * </div>
 *
 * It is normal practice to attach your transcluded content (`clone`) to the DOM inside your **clone
 * attach function**:
 *
 * ```js
 * var transcludedContent, transclusionScope;
 *
 * $transclude(function(clone, scope) {
 *   element.append(clone);
 *   transcludedContent = clone;
 *   transclusionScope = scope;
 * });
 * ```
 *
 * Later, if you want to remove the transcluded content from your DOM then you should also destroy the
 * associated transclusion scope:
 *
 * ```js
 * transcludedContent.remove();
 * transclusionScope.$destroy();
 * ```
 *
 * <div class="alert alert-info">
 * **Best Practice**: if you intend to add and remove transcluded content manually in your directive
 * (by calling the transclude function to get the DOM and and calling `element.remove()` to remove it),
 * then you are also responsible for calling `$destroy` on the transclusion scope.
 * </div>
 *
 * The built-in DOM manipulation directives, such as {@link ngIf}, {@link ngSwitch} and {@link ngRepeat}
 * automatically destroy their transluded clones as necessary so you do not need to worry about this if
 * you are simply using {@link ngTransclude} to inject the transclusion into your directive.
 *
 *
 * #### Transclusion Scopes
 *
 * When you call a transclude function it returns a DOM fragment that is pre-bound to a **transclusion
 * scope**. This scope is special, in that it is a child of the directive's scope (and so gets destroyed
 * when the directive's scope gets destroyed) but it inherits the properties of the scope from which it
 * was taken.
 *
 * For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look
 * like this:
 *
 * ```html
 * <div ng-app>
 *   <div isolate>
 *     <div transclusion>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * The `$parent` scope hierarchy will look like this:
 *
 * ```
 * - $rootScope
 *   - isolate
 *     - transclusion
 * ```
 *
 * but the scopes will inherit prototypically from different scopes to their `$parent`.
 *
 * ```
 * - $rootScope
 *   - transclusion
 * - isolate
 * ```
 *
 *
 * ### Attributes
 *
 * The {@link ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the
 * `link()` or `compile()` functions. It has a variety of uses.
 *
 * accessing *Normalized attribute names:*
 * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
 * the attributes object allows for normalized access to
 *   the attributes.
 *
 * * *Directive inter-communication:* All directives share the same instance of the attributes
 *   object which allows the directives to use the attributes object as inter directive
 *   communication.
 *
 * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object
 *   allowing other directives to read the interpolated value.
 *
 * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
 *   that contain interpolation (e.g. `src="{:{bar}alert alert-warning">
 * **Note**: Typically directives are registered with `module.directive`. The example below is
 * to illustrate how `$compile` works.
 * </div>
 *
 <example module="compileExample">
   <file name="index.html">
    <script>
      angular.module('compileExample', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        });
      })
      .controller('GreeterController', ['$scope', function($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }]);
    </script>
    <div ng-controller="GreeterController">
      <input ng-model="name"> <br>
      <textarea ng-model="html"></textarea> <br>
      <div compile="html"></div>
    </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should auto compile', function() {
       var textarea = $('textarea');
       var output = $('div[compile]');
       // The initial state reads 'Hello Angular'.
       expect(output.getText()).toBe('Hello Angular');
       textarea.clear();
       textarea.sendKeys('{{name}}!');
       expect(output.getText()).toBe('Angular!');
     });
   </file>
 </example>

 *
 *
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
 * @param {function(angular.Scope, cloneAttachFn=)} transclude function available to directives - DEPRECATED.
 *
 * <div class="alert alert-error">
 * **Note:** Passing a `transclude` function to the $compile function is deprecated, as it
 *   e.g. will not use the right outer scope. Please pass the transclude function as a
 *   `parentBoundTranscludeFn` to the link function instead.
 * </div>
 *
 * @param {number} maxPriority only apply directives lower than given priority (Only effects the
 *                 root element(s), not their children)
 * @returns {function(scope, cloneAttachFn=, options=)} a link function which is used to bind template
 * (a DOM element/tree) to a scope. Where:
 *
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
 *  `template` and call the `cloneAttachFn` function allowing the caller to attach the
 *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
 *  called as: <br> `cloneAttachFn(clonedElement, scope)` where:
 *
 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
 *      * `scope` - is the current scope with which the linking function is working with.
 *
 *  * `options` - An optional object hash with linking options. If `options` is provided, then the following
 *  keys may be used to control linking behavior:
 *
 *      * `parentBoundTranscludeFn` - the transclude function made available to
 *        directives; if given, it will be passed through to the link functions of
 *        directives found in `element` during compilation.
 *      * `transcludeControllers` - an object hash with keys that map controller names
 *        to controller instances; if given, it will make the controllers
 *        available to directives.
 *      * `futureParentElement` - defines the parent to which the `cloneAttachFn` will add
 *        the cloned elements; only needed for transcludes that are allowed to contain non html
 *        elements (e.g. SVG elements). See also the directive.controller property.
 *
 * Calling the linking function returns the element of the template. It is either the original
 * element passed in, or the clone of the element if the `cloneAttachFn` is provided.
 *
 * After linking the view is not updated until after a call to $digest which typically is done by
 * Angular automatically.
 *
 * If you need access to the bound view, there are two ways to do it:
 *
 * - If you are not asking the linking function to clone the template, create the DOM element(s)
 *   before you send them to the compiler and keep this reference around.
 *   ```js
 *     var element = $compile('<p>{{total}}</p>')(scope);
 *   ```
 *
 * - if on the other hand, you need the element to be cloned, the view reference from the original
 *   example would not point to the clone, but rather to the original template that was cloned. In
 *   this case, you can access the clone via the cloneAttachFn:
 *   ```js
 *     var templateElement = angular.element('<p>{{total}}</p>'),
 *         scope = ....;
 *
 *     var clonedElement = $compile(templateElement)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
 *
 *     //now we have reference to the cloned DOM via `clonedElement`
 *   ```
 *
 *
 * For information on how the compiler works, see the
 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
 */

var $compileMinErr = minErr('$compile');

/**
 * @ngdoc provider
 * @name $compileProvider
 *
 * @description
 */
$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
function $CompileProvider($provide, $$sanitizeUriProvider) {
  var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
      ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;

  function parseIsolateBindings(scope, directiveName) {
    var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;

    var bindings = {};

    forEach(scope, function(definition, scopeName) {
      var match = definition.match(LOCAL_REGEXP);

      if (!match) {
        throw $compileMinErr('iscp',
            "Invalid isolate scope definition for directive '{0}'." +
            " Definition:{:... {1}class"
        //is set through this function since it may cause $updateClass to
        //become unstable.

        var node = this.$$element[0],
            booleanKey = getBooleanAttrName(node, key),
            aliasedKey = getAliasedAttrName(node, key),
            observer = key,
            nodeName;

        if (booleanKey) {
          this.$$element.prop(key, value);
          attrName = booleanKey;
        } else if (aliasedKey) {
          this[aliasedKey] = value;
          observer = aliasedKey;
        }

        this[key] = value;

        // translate normalized key to actual key
        if (attrName) {
          this.$attr[key] = attrName;
        } else {
          attrName = this.$attr[key];
          if (!attrName) {
            this.$attr[key] = attrName = snake_case(key, '-');
          }
        }

        nodeName = nodeName_(this.$$element);

        if ((nodeName === 'a' && key === 'href') ||
            (nodeName === 'img' && key === 'src')) {
          // sanitize a[href] and img[src] values
          this[key] = value = $$sanitizeUri(value, key === 'src');
        } else if (nodeName === 'img' && key === 'srcset') {
          // sanitize img[srcset] values
          var result = "";

          // first check if there are spaces because it's not the same pattern
          var trimmedSrcset = trim(value);
          //                (   999x   ,|   999w   ,|   ,|,   )
          var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
          var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;

          // split srcset into tuple of uri and descriptor except for the last item
          var rawUris = trimmedSrcset.split(pattern);

          // for each tuples
          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
          for (var i = 0; i < nbrUrisWith2parts; i++) {
            var innerIdx = i * 2;
            // sanitize the uri
            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
            // add the descriptor
            result += (" " + trim(rawUris[innerIdx + 1]));
          }

          // split the last item into uri and descriptor
          var lastTuple = trim(rawUris[i * 2]).split(/\s/);

          // sanitize the last uri
          result += $$sanitizeUri(trim(lastTuple[0]), true);

          // and add the last descriptor if any
          if (lastTuple.length === 2) {
            result += (" " + trim(lastTuple[1]));
          }
          this[key] = value = result;
        }

        if (writeAttr !== false) {
          if (value === null || value === undefined) {
            this.$$element.removeAttr(attrName);
          } else {
            this.$$element.attr(attrName, value);
          }
        }

        // fire observers
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[observer], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      },


      /**
       * @ngdoc method
       * @name $compile.directive.Attributes#$observe
       * @kind function
       *
       * @description
       * Observes an interpolated attribute.
       *
       * The observer function will be invoked once during the next `$digest` following
       * compilation. The observer is then invoked whenever the interpolated value
       * changes.
       *
       * @param {string} key Normalized key. (ie ngAttribute) .
       * @param {function(interpolatedValue)} fn Function that will be called whenever
                the interpolated value of the attribute changes.
       *        See the {@link guide/directive#text-and-attribute-bindings Directives} guide for more info.
       * @returns {function()} Returns a deregistration function for this observer.
       */
      $observe: function(key, fn) {
        var attrs = this,
            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });

        return function() {
          arrayRemove(listeners, fn);
        };
      }
    };


    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch (e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }


    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;

    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
      var bindings = $element.data('$binding') || [];

      if (isArray(binding)) {
        bindings = bindings.concat(binding);
      } else {
        bindings.push(binding);
      }

      $element.data('$binding', bindings);
    } : noop;

    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
      safeAddClass($element, 'ng-binding');
    } : noop;

    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
      var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
      $element.data(dataName, scope);
    } : noop;

    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
      safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
    } : noop;

    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can
        // modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in <span>
      forEach($compileNodes, function(node, index) {
        if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) /* non-empty */ ) {
          $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
        }
      });
      var compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      compile.$$addScopeClass($compileNodes);
      var namespace = null;
      return function publicLinkFn(scope, cloneConnectFn, options) {
        assertArg(scope, 'scope');

        options = options || {};
        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
          transcludeControllers = options.transcludeControllers,
          futureParentElement = options.futureParentElement;

        // When `parentBoundTranscludeFn` is passed, it is a
        // `controllersBoundTransclude` function (it was previously passed
        // as `transclude` to directive.link) so we must unwrap it to get
        // its `boundTranscludeFn`
        if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
        }

        if (!namespace) {
          namespace = detectNamespaceForChildElements(futureParentElement);
        }
        var $linkNode;
        if (namespace !== 'html') {
          // When using a directive with replace:true and templateUrl the $compileNodes
          // (or a child element inside of them)
          // might change, so we need to recreate the namespace adapted compileNodes
          // for call to the link function.
          // Note: This will already clone the nodes...
          $linkNode = jqLite(
            wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html())
          );
        } else if (cloneConnectFn) {
          // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
          // and sometimes changes the structure of the DOM.
          $linkNode = JQLitePrototype.clone.call($compileNodes);
        } else {
          $linkNode = $compileNodes;
        }

        if (transcludeControllers) {
          for (var controllerName in transcludeControllers) {
            $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
          }
        }

        compile.$$addScopeInfo($linkNode, scope);

        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
        return $linkNode;
      };
    }

    function detectNamespaceForChildElements(parentElement) {
      // TODO: Make this detect MathML as well...
      var node = parentElement && parentElement[0];
      if (!node) {
        return 'html';
      } else {
        return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
      }
    }

    /**
     * Compile function matches each node in nodeList against the directives. Once all directives
     * for a particular node are collected their compile functions are executed. The compile
     * functions return values - the linking functions - are combined into a composite linking
     * function, which is the a linking function for the node.
     *
     * @param {NodeList} nodeList an array of nodes or NodeList to compile
     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then
     *        the rootElement must be set the jqLite collection of the compile root. This is
     *        needed so that the jqLite collection items can be replaced with widgets.
     * @param {number=} maxPriority Max directive priority.
     * @returns {Function} A composite linking function of all of the matched directives or null.
     */
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) {
      var linkFns = [],
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;

      for (var i = 0; i < nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                                      null, [], [], previousCompileContext)
            : null;

        if (nodeLinkFn && nodeLinkFn.scope) {
          compile.$$addScopeClass(attrs.$$element);
        }

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                      !(childNodes = nodeList[i].childNodes) ||
                      !childNodes.length)
            ? null
            : compileNodes(childNodes,
                 nodeLinkFn ? (
                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
                     && nodeLinkFn.transclude) : transcludeFn);

        if (nodeLinkFn || childLinkFn) {
          linkFns.push(i, nodeLinkFn, childLinkFn);
          linkFnFound = true;
          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
        }

        //use the previous context only for the first element in the virtual group
        previousCompileContext = null;
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
        var stableNodeList;


        if (nodeLinkFnFound) {
          // copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our
          // offsets don't get screwed up
          var nodeListLength = nodeList.length;
          stableNodeList = new Array(nodeListLength);

          // create a sparse array by only copying the elements which have a linkFn
          for (i = 0; i < linkFns.length; i+=3) {
            idx = linkFns[i];
            stableNodeList[idx] = nodeList[idx];
          }
        } else {
          stableNodeList = nodeList;
        }

        for (i = 0, ii = linkFns.length; i < ii;) {
          node = stableNodeList[linkFns[i++]];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new();
              compile.$$addScopeInfo(jqLite(node), childScope);
            } else {
              childScope = scope;
            }

            if (nodeLinkFn.transcludeOnThisElement) {
              childBoundTranscludeFn = createBoundTranscludeFn(
                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn,
                  nodeLinkFn.elementTranscludeOnThisElement);

            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
              childBoundTranscludeFn = parentBoundTranscludeFn;

            } else if (!parentBoundTranscludeFn && transcludeFn) {
              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);

            } else {
              childBoundTranscludeFn = null;
            }

            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);

          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
          }
        }
      }
    }

    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {

      var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {

        if (!transcludedScope) {
          transcludedScope = scope.$new(false, containingScope);
          transcludedScope.$$transcluded = true;
        }

        return transcludeFn(transcludedScope, cloneFn, {
          parentBoundTranscludeFn: previousBoundTranscludeFn,
          transcludeControllers: controllers,
          futureParentElement: futureParentElement
        });
      };

      return boundTranscludeFn;
    }

    /**
     * Looks for directives on the given node and adds them to the directive collection which is
     * sorted.
     *
     * @param node Node to search.
     * @param directives An array to which the directives are added to. This array is sorted before
     *        the function returns.
     * @param attrs The shared attrs object which is used to populate the normalized attributes.
     * @param {number=} maxPriority Max directive priority.
     */
    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch (nodeType) {
        case NODE_TYPE_ELEMENT: /* Element */
          // use the node name: <directive>
          addDirective(directives,
              directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName = false;
            var attrEndName = false;

            attr = nAttrs[j];
            name = attr.name;
            value = trim(attr.value);

            // support ngAttr attribute binding
            ngAttrName = directiveNormalize(name);
            if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
              name = name.replace(PREFIX_REGEXP, '')
                .substr(8).replace(/_(.)/g, function(match, letter) {
                  return letter.toUpperCase();
                });
            }

            var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
            if (directiveIsMultiElement(directiveNName)) {
              if (ngAttrName === directiveNName + 'Start') {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + 'end';
                name = name.substr(0, name.length - 6);
              }
            }

            nName = directiveNormalize(name.toLowerCase());
            attrsMap[nName] = name;
            if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                attrs[nName] = value;
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true; // presence means true
                }
            }
            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
            addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
                          attrEndName);
          }

          // use class as directive
          className = node.className;
          if (isObject(className)) {
              // Maybe SVGAnimatedString
              className = className.animVal;
          }
          if (isString(className) && className !== '') {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case NODE_TYPE_TEXT: /* Text Node */
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case NODE_TYPE_COMMENT: /* Comment */
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read
            // comment's node value.
            // Just ignore it and continue. (Can't seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }

    /**
     * Given a node with an directive-start it collects all of the siblings until it finds
     * directive-end.
     * @param node
     * @param attrStart
     * @param attrEnd
     * @returns {*}
     */
    function groupScan(node, attrStart, attrEnd) {
      var nodes = [];
      var depth = 0;
      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
        do {
          if (!node) {
            throw $compileMinErr('uterdir',
                      "Unterminated attribute,found '{0}' but no matching '{1}' found.",
                      attrStart, attrEnd);
          }
          if (node.nodeType == NODE_TYPE_ELEMENT) {
            if (node.hasAttribute(attrStart)) depth++;
            if (node.hasAttribute(attrEnd)) depth--;
          }
          nodes.push(node);
          node = node.nextSibling;
        } while (depth > 0);
      } else {
        nodes.push(node);
      }

      return jqLite(nodes);
    }

    /**
     * Wrapper for linking function which converts normal linking function into a grouped
     * linking function.
     * @param linkFn
     * @param attrStart
     * @param attrEnd
     * @returns {Function}
     */
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
      return function(scope, element, attrs, controllers, transcludeFn) {
        element = groupScan(element[0], attrStart, attrEnd);
        return linkFn(scope, element, attrs, controllers, transcludeFn);
      };
    }

    /**
     * Once the directives have been collected, their compile functions are executed. This method
     * is responsible for inlining directive templates as well as terminating the application
     * of the directives if the terminal directive has been reached.
     *
     * @param {Array} directives Array of collected directives to execute their compile function.
     *        this needs to be pre-sorted by priority order.
     * @param {Node} compileNode The raw DOM node to apply the compile functions to
     * @param {Object} templateAttrs The shared attribute function
     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
     *                                                  scope argument is auto-generated to the new
     *                                                  child of the transcluded parent scope.
     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
     *                              argument has the root jqLite array so that we can replace nodes
     *                              on it.
     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
     *                                           compiling the transclusion.
     * @param {Array.<Function>} preLinkFns
     * @param {Array.<Function>} postLinkFns
     * @param {Object} previousCompileContext Context used for previous compilation of the current
     *                                        node
     * @returns {Function} linkFn
     */
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) {
      previousCompileContext = previousCompileContext || {};

      var terminalPriority = -Number.MAX_VALUE,
          newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          controllers,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = false,
          hasTemplate = false,
          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for (var i = 0, ii = directives.length; i < ii; i++) {
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        // collect multiblock sections
        if (attrStart) {
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        }
        $template = undefined;

        if (terminalPriority > directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {

          // skip the check for directives with async templates, we'll check the derived sync
          // directive when the template arrives
          if (!directive.templateUrl) {
            if (isObject(directiveValue)) {
              // This directive is trying to add an isolated scope.
              // Check that there is no scope of any kind already
              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
                                directive, $compileNode);
              newIsolateScopeDirective = directive;
            } else {
              // This directive is trying to add a child scope.
              // Check that there is no isolated scope already
              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
                                $compileNode);
            }
          }

          newScopeDirective = newScopeDirective || directive;
        }

        directiveName = directive.name;

        if (!directive.templateUrl && directive.controller) {
          directiveValue = directive.controller;
          controllerDirectives = controllerDirectives || {};
          assertNoDuplicate("'" + directiveName + "' controller",
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          hasTranscludeDirective = true;

          // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
          // This option should only be used by directives that know how to safely handle element transclusion,
          // where the transcluded nodes are added or replaced after linking.
          if (!directive.$$tlb) {
            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          }

          if (directiveValue == 'element') {
            hasElementTranscludeDirective = true;
            terminalPriority = directive.priority;
            $template = $compileNode;
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(' ' + directiveName + ': ' +
                                              templateAttrs[directiveName] + ' '));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, sliceArgs($template), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name, {
                                          // Don't pass in:
                                          // - controllerDirectives - otherwise we'll create duplicates controllers
                                          // - newIsolateScopeDirective or templateDirective - combining templates with
                                          //   element transclusion doesn't make sense.
                                          //
                                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                                          // on the same element more than once.
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        });
          } else {
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.empty(); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          hasTemplate = true;
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            replaceDirective = directive;
            if (jqLiteIsTextNode(directiveValue)) {
              $template = [];
            } else {
              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
            }
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
              throw $compileMinErr('tplrt',
                  "Template for directive '{0}' must have exactly one root element.{:1}true if directive was added. */ function addDirective(tDirectives,name,location,maxPriority,ignoreDirective,startAttrName,endAttrName){:if(name === ignoreDirective) return null;:var match = null;:if(hasDirectives.hasOwnProperty(name)) { for(var directive,directives = $injector.get(name + Suffix),i = 0,ii = directives.length;:i < ii;:i++) { try { directive = directives[i];if((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) { if(startAttrName) { directive = inherit(directive,{$$start:startAttrName,$$end:endAttrName}function directiveIsMultiElement(name){:if(hasDirectives.hasOwnProperty(name)) { for(var directive,directives = $injector.get(name + Suffix),i = 0,ii = directives.length;:i < ii;:i++) { directive = directives[i];:if(directive.multiElement) { return true}function mergeTemplateAttributes(dst,src){:var srcAttr = src.$attr,dstAttr = dst.$attr,$element = dst.$$element;// reapply the old attributes to the new element forEach(dst,function(value,key) { if(key.charAt(0) != '$') { if(src[key]&& src[key]!== value) { value +=(key === 'style' ? ';':' ') + src[key]}); // copy the new attributes on the old attrs object forEach(src,function(value,key){:if(key == 'class') { safeAddClass($element,value);dst['class']=(dst['class']? dst['class']+ ' ':'') + value}else if (key == 'style'){:$element.attr('style',$element.attr('style') + ';' + value);dst['style']=(dst['style']? dst['style']+ ';':'') + value;:// `dst` will never contain hasOwnProperty as DOM parser won't let it.
          // You will get an "InvalidCharacterError: DOM Exception 5" error if you
          // have an attribute like "has-own-property" or "data-has-own-property", etc.
        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        }
      });
    }


    function compileTemplateUrl(directives, $compileNode, tAttrs,
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          // The fact that we have to copy and patch the directive seems wrong!
          derivedSyncDirective = extend({}, origAsyncDirective, {
            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
          }),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl,
          templateNamespace = origAsyncDirective.templateNamespace;

      $compileNode.empty();

      $templateRequest($sce.getTrustedResourceUrl(templateUrl))
        .then(function(content) {
          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;

          content = denormalizeTemplate(content);

          if (origAsyncDirective.replace) {
            if (jqLiteIsTextNode(content)) {
              $template = [];
            } else {
              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
            }
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
              throw $compileMinErr('tplrt',
                  "Template for directive '{0}multidir', 'Multiple directives [{:0}] asking for{:2}on:{:3}t have a parent and thus need to add the class during linking fn. if (hasCompileParent) compile.$$addBindingClass(templateNodeParent); return function textInterpolateLinkFn(scope,node){:var parent = node.parent();:if(!hasCompileParent) compile.$$addBindingClass(parent);:compile.$$addBindingInfo(parent,interpolateFn.expressions);:scope.$watch(interpolateFn,function interpolateFnWatchAction(value) { node[0].nodeValue = value}function wrapTemplate(type,template){:type = lowercase(type || 'html');switch(type) { case 'svg':case 'math':var wrapper = document.createElement('div');:wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';:return wrapper.childNodes[0].childNodes;default:return template}function getTrustedContext(node,attrNormalizedName){:if(attrNormalizedName == "srcdoc") { return $sce.HTML}// if attribute was updated so that there is no interpolation going on we don't want to
                // register any observers
                if (!interpolateFn) return;

                // initialize attr object so that it's ready in case we need the value for isolate // scope initialization,otherwise the value would not be available from isolate // directive's linking fn during linking phase
                attr[name] = interpolateFn(scope);

                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    //special case for class attribute addition + removal
                    //so that class changes can tap into the animation
                    //hooks provided by the $animate service. Be sure to
                    //skip animations when the first digest occurs (when
                    //both the new and the old values are the same) since
                    //the CSS classes are the non-interpolated values
                    if (name === 'class' && newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
              }
            };
          }
      });
    }


    /**
     * This is a special jqLite.replaceWith, which can replace items which
     * have no parents, provided that the containing jqLite collection is provided.
     *
     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
     *                               in the root of the tree.
     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep
     *                                  the shell, but replace its DOM node reference.
     * @param {Node} newNode The new DOM node.
     */
    function replaceWith($rootElement, elementsToRemove, newNode) {
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      if ($rootElement) {
        for (i = 0, ii = $rootElement.length; i < ii; i++) {
          if ($rootElement[i] == firstElementToRemove) {
            $rootElement[i++] = newNode;
            for (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) {
              if (j2 < jj) {
                $rootElement[j] = $rootElement[j2];
              } else {
                delete $rootElement[j];
              }
            }
            $rootElement.length -= removeCount - 1;

            // If the replaced element is also the jQuery .context then replace it
            // .context is a deprecated jQuery api, so we should set it only when jQuery set it
            // http://api.jquery.com/context/
            if ($rootElement.context === firstElementToRemove) {
              $rootElement.context = newNode;
            }
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, firstElementToRemove);
      }

      // TODO(perf): what's this document fragment for? is it needed? can we at least reuse it? var fragment = document.createDocumentFragment(); fragment.appendChild(firstElementToRemove); // Copy over user data (that includes Angular's $scope etc.). Don't copy private // data here because there's no public interface in jQuery to do that and copying over
      // event listeners (which is the main use of private data) wouldn't work anyway. jqLite(newNode).data(jqLite(firstElementToRemove).data()); // Remove data of the replaced element. We cannot just call .remove() // on the element it since that would deallocate scope that is needed // for the new node. Instead,remove the data "manually". if (!jQuery){:delete jqLite.cache[firstElementToRemove[jqLite.expando]]},but extracted into * a service,so that one can override this service with [BCversion](https://gist.github.com/1649788). */ return function(expression,locals,later,ident){// PRIVATE API:// param `later` --- indicates that the controller's constructor is invoked at a later time.
      //                     If true, $controller will allocate the object with the correct
      //                     prototype chain, but will not invoke the controller until a returned
      //                     callback is invoked.
      //   param `ident` --- An optional label which overrides the label parsed from the controller
      //                     expression, if any.
      var instance, match, constructor, identifier;
      later = later === true;
      if (ident && isString(ident)) {
        identifier = ident;
      }

      if (isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = identifier || match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) ||
                (globals ? getter($window, constructor, true) : undefined);

        assertArgFn(expression, constructor, true);
      }

      if (later) {
        // Instantiate controller later:
        // This machinery is used to create an instance of the object before calling the
        // controller's constructor itself. // // This allows properties to be added to the controller before the constructor is // invoked. Primarily,this is used for isolate scope bindings in $compile. // // This feature is not intended for use by applications,and is thus not documented // publicly. // Object creation:http://jsperf.com/create-constructor/2 var controllerPrototype =(isArray(expression) ? expression[expression.length - 1:expression).prototype;:instance = Object.create(controllerPrototype || null);:if(identifier) { addIdentifier(locals,identifier,instance,constructor || expression.name)}return extend(function(){:$injector.invoke(expression,instance,locals,constructor);:return instance}{instance:instance,identifier:identifier}instance = $injector.instantiate(expression,locals,constructor); if (identifier){:addIdentifier(locals,identifier,instance,constructor || expression.name)}; function addIdentifier(locals,identifier,instance,name){:if(!(locals && isObject(locals.$scope))) { throw minErr('$controller')('noscp',"Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",name,identifier)}function $DocumentProvider(){:this.$get =['$window',function(window) { return jqLite(window.document)}function $ExceptionHandlerProvider(){:this.$get =['$log',function($log) { return function(exception,cause) { $log.error.apply($log,arguments)}var APPLICATION_JSON = 'application/json'; var CONTENT_TYPE_APPLICATION_JSON ={'Content-Type':APPLICATION_JSON + ';charset=utf-8'}; var JSON_START = /^\[|^\{:(?!\{)/;var JSON_ENDS = { '[':/]$/,'{':/}* this.useApplyAsync = function(value),Content-Type');
      if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
        data = fromJson(tempData);
      }
    }
  }

  return data;
}

function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  var parsed = createMap(), key, val, i;

  if (!headers) return parsed;

  forEach(headers.split('\n'), function(line) {
    i = line.indexOf(':');
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ',' + val : val;
    }
  });

  return parsed;
}


/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with single an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      var value = headersObj[lowercase(name)];
      if (value === void 0) {
        value = null;
      }
      return value;
    }

    return headersObj;
  };
}


/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=)} headers HTTP headers getter fn.
 * @param {number} status HTTP status code of the response.
 * @param {(Function|Array.<Function>)} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, status, fns) {
  if (isFunction(fns))
    return fns(data, headers, status);

  forEach(fns, function(fn) {
    data = fn(data, headers, status);
  });

  return data;
}


function isSuccess(status) {
  return 200 <= status && status < 300;
}


/**
 * @ngdoc provider
 * @name $httpProvider
 * @description
 * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
 * */
function $HttpProvider() {
  /**
   * @ngdoc property
   * @name $httpProvider#defaults
   * @description
   *
   * Object containing default values for all {@link ng.$http $http} requests.
   *
   * - **`defaults.cache`** - {Object} - an object built with {@link ng.$cacheFactory `$cacheFactory`}
   * that will provide the cache for all requests who set their `cache` property to `true`.
   * If you set the `default.cache = false` then only requests that specify their own custom
   * cache object will be cached. See {@link $http#caching $http Caching} for more information.
   *
   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
   * Defaults value is `'XSRF-TOKEN'`.
   *
   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
   *
   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
   * setting default headers.
   *     - **`defaults.headers.common`**
   *     - **`defaults.headers.post`**
   *     - **`defaults.headers.put`**
   *     - **`defaults.headers.patch`**
   *
   **/
  var defaults = this.defaults = {
    // transform incoming response data
    transformResponse: [defaultHttpResponseTransform],

    // transform outgoing request data
    transformRequest: [function(d) {
      return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
    }],

    // default headers
    headers: {
      common: {
        'Accept': 'application/jsontext/plain{:if(isDefined(value)) { useApplyAsync = !!value;:return this}; var interceptorFactories = this.interceptors = []; this.$get = ['$httpBackend','$injector''$rootScope''$browser''$cacheFactory''$q'function($httpBackend,$browser,$cacheFactory,$rootScope,$q,$injector){:var defaultCache = $cacheFactory('$http');:var reversedInterceptors =[];forEach(interceptorFactories,function(interceptorFactory) { reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory):$injector.invoke(interceptorFactory))}); function $http(requestConfig){:if(!angular.isObject(requestConfig)) { throw minErr('$http')('badreq','Http request configuration must be an object.  Received: {0}',requestConfig)}var config = extend({method:'get',transformRequest:defaults.transformRequest,transformResponse:defaults.transformResponse},requestConfig); config.headers = mergeHeaders(requestConfig); config.method = uppercase(config.method); var serverRequest = function(config){:var headers = config.headers;:var reqData = transformData(config.data,headersGetter(headers),undefined,config.transformRequest);:// strip content-type if data is undefined if(isUndefined(reqData)) { forEach(headers,function(value,header) { if(lowercase(header) === 'content-type') { delete headers[header]}if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)){:config.withCredentials = defaults.withCredentials}; var chain = [serverRequest,undefined]; var promise = $q.when(config); // apply interceptors forEach(reversedInterceptors,function(interceptor){:if(interceptor.request || interceptor.requestError) { chain.unshift(interceptor.request,interceptor.requestError)}if (interceptor.response || interceptor.responseError){:chain.push(interceptor.response,interceptor.responseError)}); while (chain.length){:var thenFn = chain.shift();:var rejectFn = chain.shift();:promise = promise.then(thenFn,rejectFn)}promise.success = function(fn){:promise.then(function(response) { fn(response.data,response.status,response.headers,config)}; promise.error = function(fn){:promise.then(null,function(response) { fn(response.data,response.status,response.headers,config)}; return promise; function transformResponse(response){:// make a copy since the response must be cacheable var resp = extend({},response); if (!response.data){:resp.data = response.data}function executeHeaderFns(headers){:var headerContent,processedHeaders = {}; forEach(headers,function(headerFn,header){:if(isFunction(headerFn)) { headerContent = headerFn();:if(headerContent != null) { processedHeaders[header]= headerContent}function mergeHeaders(config){:var defHeaders = defaults.headers,reqHeaders = extend({},defHeaders.common,defHeaders[lowercase(config.method)]); // using for-in instead of forEach to avoid unecessary iteration after header has been found defaultHeadersIteration: for (defHeaderName in defHeaders){:lowercaseDefHeaderName = lowercase(defHeaderName);:for(reqHeaderName in reqHeaders) { if(lowercase(reqHeaderName) === lowercaseDefHeaderName) { continue defaultHeadersIteration}$http.pendingRequests = []; createShortMethods('get','delete','head','jsonp'); createShortMethodsWithData('post','put','patch'); $http.defaults = defaults; return $http; function createShortMethods(names){:forEach(arguments,function(name) { $http[name]= function(url,config) { return $http(extend(config || {}function createShortMethodsWithData(name){:forEach(arguments,function(name) { $http[name]= function(url,data,config) { return $http(extend(config || {}{method:name,url:url,data:data}function sendReq(config,reqData){:var deferred = $q.defer(),promise = deferred.promise,cache,cachedResp,reqHeaders = config.headers,url = buildUrl(config.url,config.params);:$http.pendingRequests.push(config);:promise.then(removePendingReq,removePendingReq);if((config.cache || defaults.cache) && config.cache !== false &&(config.method === 'GET' || config.method === 'JSONP')) { cache = isObject(config.cache) ? config.cache:isObject(defaults.cache) ? defaults.cache:defaultCache}if (cache){:cachedResp = cache.get(url);:if(isDefined(cachedResp)) { if(isPromiseLike(cachedResp)) { // cached request has already been sent,but there is no response yet cachedResp.then(resolvePromiseWithResult,resolvePromiseWithResult)}// if we won't have the response in cache, set the xsrf headers and
      // send the request to the backend
      if (isUndefined(cachedResp)) {
        var xsrfValue = urlIsSameOrigin(config.url)
            ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
            : undefined;
        if (xsrfValue) {
          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
        }

        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      }

      return promise;


      /**
       * Callback registered to $httpBackend():
       *  - caches the response if desired
       *  - resolves the raw $http promise
       *  - calls $apply
       */
      function done(status, response, headersString, statusText) {
        if (cache) {
          if (isSuccess(status)) {
            cache.put(url, [status, response, parseHeaders(headersString), statusText]);
          } else {
            // remove promise from the cache
            cache.remove(url);
          }
        }

        function resolveHttpPromise() {
          resolvePromise(response, status, headersString, statusText);
        }

        if (useApplyAsync) {
          $rootScope.$applyAsync(resolveHttpPromise);
        } else {
          resolveHttpPromise();
          if (!$rootScope.$$phase) $rootScope.$apply();
        }
      }


      /**
       * Resolves the raw $http promise.
       */
      function resolvePromise(response, status, headers, statusText) {
        // normalize internal statuses to 0
        status = Math.max(status, 0);

        (isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(headers),
          config: config,
          statusText: statusText
        });
      }

      function resolvePromiseWithResult(result) {
        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
      }

      function removePendingReq() {
        var idx = $http.pendingRequests.indexOf(config);
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
      }
    }


    function buildUrl(url, params) {
      if (!params) return url;
      var parts = [];
      forEachSorted(params, function(value, key) {
        if (value === null || isUndefined(value)) return;
        if (!isArray(value)) value = [value];

        forEach(value, function(v) {
          if (isObject(v)) {
            if (isDate(v)) {
              v = v.toISOString();
            } else {
              v = toJson(v);
            }
          }
          parts.push(encodeUriQuery(key) + '=' +
                     encodeUriQuery(v));
        });
      });
      if (parts.length > 0) {
        url += ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
      }
      return url;
    }
  }];
}

function createXhr() {
    return new window.XMLHttpRequest();
}

/**
 * @ngdoc service
 * @name $httpBackend
 * @requires $window
 * @requires $document
 *
 * @description
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
 *
 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
 * $httpBackend} which can be trained with responses.
 */
function $HttpBackendProvider() {
  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
  }];
}

function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
  // TODO(vojta): fix the signature
  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    if (lowercase(method) == 'jsonp') {
      var callbackId = '_' + (callbacks.counter++).toString(36);
      callbacks[callbackId] = function(data) {
        callbacks[callbackId].data = data;
        callbacks[callbackId].called = true;
      };

      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
          callbackId, function(status, text) {
        completeRequest(callback, status, callbacks[callbackId].data, "", text);
        callbacks[callbackId] = noop;
      });
    } else {

      var xhr = createXhr();

      xhr.open(method, url, true);
      forEach(headers, function(value, key) {
        if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
        }
      });

      xhr.onload = function requestLoaded() {
        var statusText = xhr.statusText || '';

        // responseText is the old-school way of retrieving response (supported by IE8 & 9)
        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
        var response = ('response' in xhr) ? xhr.response : xhr.responseText;

        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
        var status = xhr.status === 1223 ? 204 : xhr.status;

        // fix status code when it is 0 (0 status is undocumented).
        // Occurs when accessing file resources or on Android 4.1 stock browser
        // while retrieving files from application cache.
        if (status === 0) {
          status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
        }

        completeRequest(callback,
            status,
            response,
            xhr.getAllResponseHeaders(),
            statusText);
      };

      var requestError = function() {
        // The response is always empty
        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
        completeRequest(callback, -1, null, null, '');
      };

      xhr.onerror = requestError;
      xhr.onabort = requestError;

      if (withCredentials) {
        xhr.withCredentials = true;
      }

      if (responseType) {
        try {
          xhr.responseType = responseType;
        } catch (e) {
          // WebKit added support for the json responseType value on 09/03/2013
          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
          // known to throw when setting the value "json" as the response type. Other older
          // browsers implementing the responseType
          //
          // The json response type can be ignored if not supported, because JSON payloads are
          // parsed on the client-side regardless.
          if (responseType !== 'json') {
            throw e;
          }
        }
      }

      xhr.send(post || null);
    }

    if (timeout > 0) {
      var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (isPromiseLike(timeout)) {
      timeout.then(timeoutRequest);
    }


    function timeoutRequest() {
      jsonpDone && jsonpDone();
      xhr && xhr.abort();
    }

    function completeRequest(callback, status, response, headersString, statusText) {
      // cancel timeout and subsequent timeout promise resolution
      if (timeoutId !== undefined) {
        $browserDefer.cancel(timeoutId);
      }
      jsonpDone = xhr = null;

      callback(status, response, headersString, statusText);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, callbackId, done) {
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements,callback = null; script.type = "text/javascript"; script.src = url; script.async = true; callback = function(event),e.g.: // - fetches local scripts via XHR and evals them // - adds and immediately removes script elements from the document var script = rawDocument.createElement('script'){:removeEventListenerFn(script,"load",callback);:removeEventListenerFn(script,"error",callback);:rawDocument.body.removeChild(script);:script = null;:var status = -1;:var text = "unknown";if(event) { if(event.type === "load" && !callbacks[callbackId].called) { event = { type:"error"}if (done){:done(status,text)}var $interpolateMinErr = minErr('$interpolate'); function $InterpolateProvider(){:var startSymbol = '{{';:var endSymbol = '}}';:this.startSymbol = function(value) { if(value) { startSymbol = value;:return this}; this.endSymbol = function(value){:if(value) { endSymbol = value;:return this}; this.$get = ['$parse','$exceptionHandler''$sce'function($parse,$exceptionHandler,$sce){:var startSymbolLength = startSymbol.length,endSymbolLength = endSymbol.length,escapedStartRegexp = new RegExp(startSymbol.replace(/./g,escape),'g'),escapedEndRegexp = new RegExp(endSymbol.replace(/./g,escape),'g');:function escape(ch) { return '\\\\\\' + ch}function $interpolate(text,mustHaveExpression,trustedContext,allOrNothing){:allOrNothing = !!allOrNothing;:var startIndex,endIndex,index = 0,expressions =[],parseFns =[],textLength = text.length,exp,concat =[],expressionPositions =[];:while(index < textLength) { if(((startIndex = text.indexOf(startSymbol,index)) != -1) &&((endIndex = text.indexOf(endSymbol,startIndex + startSymbolLength)) != -1)) { if(index !== startIndex) { concat.push(unescapeText(text.substring(index,startIndex)))}// Concatenating expressions makes it hard to reason about whether some combination of // concatenated values are unsafe to use and could easily lead to XSS. By requiring that a // single expression be used for iframe[src],etc.,object[src],we ensure that the value // that's used is assigned or constructed by some JS code somewhere that is more testable or
      // make it obvious that you bound the value to some user controlled value.  This helps reduce
      // the load when auditing for XSS issues.
      if (trustedContext && concat.length > 1) {
          throw $interpolateMinErr('noconcat',
              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
              "interpolations that concatenate multiple expressions when a trusted value is " +
              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      }

      if (!mustHaveExpression || expressions.length) {
        var compute = function(values) {
          for (var i = 0, ii = expressions.length; i < ii; i++) {
            if (allOrNothing && isUndefined(values[i])) return;
            concat[expressionPositions[i]] = values[i];
          }
          return concat.join('');
        };

        var getValue = function(value) {
          return trustedContext ?
            $sce.getTrusted(trustedContext, value) :
            $sce.valueOf(value);
        };

        var stringify = function(value) {
          if (value == null) { // null || undefined
            return '';
          }
          switch (typeof value) {
            case 'string':
              break;
            case 'number':
              value = '' + value;
              break;
            default:
              value = toJson(value);
          }

          return value;
        };

        return extend(function interpolationFn(context) {
            var i = 0;
            var ii = expressions.length;
            var values = new Array(ii);

            try {
              for (; i < ii; i++) {
                values[i] = parseFns[i](context);
              }

              return compute(values);
            } catch (err) {
              var newErr = $interpolateMinErr('interr', "Can't interpolate:{:0}\n{:1}Can't interpolate: {0}\n{1}", text,
            err.toString());
          $exceptionHandler(newErr);
        }
      }
    }


    /**
     * @ngdoc method
     * @name $interpolate#startSymbol
     * @description
     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
     *
     * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.startSymbol = function() {
      return startSymbol;
    };


    /**
     * @ngdoc method
     * @name $interpolate#endSymbol
     * @description
     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
     *
     * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
     * the symbol.
     *
     * @returns {string} end symbol.
     */
    $interpolate.endSymbol = function() {
      return endSymbol;
    };

    return $interpolate;
  }];
}

function $IntervalProvider() {
  this.$get = ['$rootScope', '$window', '$q', '$$q',
       function($rootScope,   $window,   $q,   $$q) {
    var intervals = {};


     /**
      * @ngdoc service
      * @name $interval
      *
      * @description
      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay` * milliseconds. * * The return value of registering an interval function is a promise. This promise will be * notified upon each tick of the interval,and will be resolved after `count` iterations,call `$interval.cancel(promise)`. * * In tests you can use,or * run indefinitely if `count` is not defined. The value of the notification will be the * number of iterations that have run. * To cancel an interval{:@link ngMock.$interval#flush `$interval.flush(millis)`}[invokeApply=true] If set to `false` skips model dirty checking,otherwise * will invoke `fn` within the{:@link ng.$rootScope.Scope#$apply $apply}A promise which will be notified on each iteration. * * @example * <example module="intervalExample"> * <file name="index.html"> * <script> * angular.module('intervalExample',[]) * .controller('ExampleController',['$scope','$interval',* function($scope,$interval){hashPrefix hashbang prefix */ function LocationHashbangUrl(appBase,hashPrefix){:var appBaseNoFile = stripFile(appBase);:parseAbsoluteUrl(appBase,this);:this.$$parse = function(url) { var withoutBaseUrl = beginsWith(appBase,url) || beginsWith(appBaseNoFile,url);:var withoutHashUrl;:if(withoutBaseUrl.charAt(0) === '#') { // The rest of the url starts with a hash so we have // got either a hashbang path or a plain hash fragment withoutHashUrl = beginsWith(hashPrefix,withoutBaseUrl);:if(isUndefined(withoutHashUrl)) { // There was no hashbang prefix so we just have a hash fragment withoutHashUrl = withoutBaseUrl}}else{// There was no hashbang path nor hash fragment:// If we are in HTML5 mode we use what is left as the path;// Otherwise we ignore what is left withoutHashUrl = this.$$html5 ? withoutBaseUrl:''}parseAppUrl(withoutHashUrl,this); this.$$path = removeWindowsDriveName(this.$$path,withoutHashUrl,appBase); this.$$compose(); function removeWindowsDriveName(path,url,base){var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;:var firstPathSegmentMatch;://Get the relative path from the input URL. if(url.indexOf(base) === 0) { url = url.replace(base,'')}// The input URL intentionally contains a first path segment that ends with a colon. if (windowsFilePathExp.exec(url)){:return path}; this.$$compose = function(){this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url:'')}; this.$$parseLinkUrl = function(url,relHref){:if(stripHash(appBase) == stripHash(url)) { this.$$parse(url);:return true}function LocationHashbangInHtml5Url(appBase,hashPrefix){:this.$$html5 = true;:LocationHashbangUrl.apply(this,arguments);:var appBaseNoFile = stripFile(appBase);this.$$parseLinkUrl = function(url,relHref) { if(relHref && relHref[0]=== '#') { // special case for links to hash fragments:// keep the old url and only replace the hash fragment this.hash(relHref.slice(1));:return true}var rewrittenUrl; var appUrl; if (appBase == stripHash(url)){:rewrittenUrl = url}else if ((appUrl = beginsWith(appBaseNoFile,url))){:rewrittenUrl = appBase + hashPrefix + appUrl}else if (appBaseNoFile === url+'/'){:rewrittenUrl = appBaseNoFile}if (rewrittenUrl){:this.$$parse(rewrittenUrl)}; this.$$compose = function(){var search = toKeyValue(this.$$search),hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash):'';this.$$url = encodePath(this.$$path) + (search ? '?' + search:'') + hash;:// include hashPrefix in $$absUrl when $$url is empty so IE8 & 9 do not reload page because of removal of '#' this.$$absUrl = appBase + hashPrefix + this.$$url}var locationPrototype ={$$html5:false,$$replace:false,absUrl:locationGetter('$$absUrl'),url:function(url) { if(isUndefined(url)) return this.$$url;:var match = PATH_MATCH.exec(url);:if(match[1]|| url === '') this.path(decodeURIComponent(match[1]));:if(match[2]|| match[1]|| url === '') this.search(match[3]|| '');:this.hash(match[5]|| '');:return this},protocol: locationGetter('$$protocol'),host: locationGetter('$$host'),path: locationGetterSetter('$$path',function(path),port: locationGetter('$$port'){path = path !== null ? path.toString():'';return path.charAt(0) == '/' ? path:'/' + path}),search: function(search,paramValue){switch(arguments.length) { case 0:return this.$$search;case 1:if(isString(search) || isNumber(search)) { search = search.toString();:this.$$search = parseKeyValue(search)}else if (isObject(search)){:search = copy(search,{}); // remove object undefined or null properties forEach(search,function(value,key){:if(value == null) delete search[key]}break; default: if (isUndefined(paramValue) || paramValue === null){:delete this.$$search[search]},hash: locationGetterSetter('$$hash',function(hash){return hash !== null ? hash.toString():''}),replace: function(){:this.$$replace = true;:return this}; forEach([LocationHashbangInHtml5Url,LocationHashbangUrl,LocationHtml5Url],function(Location){:Location.prototype = Object.create(locationPrototype);:Location.prototype.state = function(state) { if(!arguments.length) return this.$$state;:if(Location !== LocationHtml5Url || !this.$$html5) { throw $locationMinErr('nostate','History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API')}); return $location; function afterLocationChange(oldUrl,oldState){:$rootScope.$broadcast('$locationChangeSuccess',$location.absUrl(),oldUrl,$location.$$state,oldState)}function $LogProvider(){:var debug = true,self = this;:this.debugEnabled = function(flag) { if(isDefined(flag)) { debug = flag;:return this}; this.$get = ['$window',function($window){return { log:consoleLog('log'),info:consoleLog('info'),warn:consoleLog('warn'),error:consoleLog('error'),debug(function() { var fn = consoleLog('debug');:return function() { if(debug) { fn.apply(self,arguments)}; function formatError(arg){if(arg instanceof Error) { if(arg.stack) { arg =(arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack:arg.stack}else if (arg.sourceURL){:arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line}function consoleLog(type){:var console = $window.console || {},hasApply = false; // Note: reading logFn.apply throws an error in IE11 in IE8 document mode. // The reason behind this is that console.log has type "object" in IE8... try,logFn = console[type] || console.log || noop{:hasApply = !!logFn.apply}if (hasApply){:return function() { var args =[];:forEach(arguments,function(arg) { args.push(formatError(arg))}// we are IE which either doesn't have window.console => this is noop and we do nothing,
      // or we are IE where console.log doesn't have apply so we log at least first 2 args return function(arg1,arg2){logFn(arg1,arg2 == null ? '':arg2)}.toString.constructor('alert("evil JS code")') // // This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
// against the expression language, but not to prevent exploits that were enabled by exposing
// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good
// practice and therefore we are not even trying to protect against interaction with an object
// explicitly exposed in this way.
//
// In general, it is not possible to access a Window object from an angular expression unless a
// window or some DOM object that has a reference to window is published onto a Scope.
// Similarly we prevent invocations of function known to be dangerous, as well as assignments to
// native objects.
//
// See https://docs.angularjs.org/guide/security


function ensureSafeMemberName(name, fullExpression) {
  if (name === "__defineGetter__" || name === "__defineSetter__"
      || name === "__lookupGetter__" || name === "__lookupSetter__"
      || name === "__proto__") {
    throw $parseMinErr('isecfld',
        'Attempting to access a disallowed field in Angular expressions! '
        + 'Expression:,isecdom',
          'Referencing DOM nodes in Angular expressions is disallowed! Expression:,isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression:,isecwindow',
          'Referencing the Window in Angular expressions is disallowed! Expression:{:0}t get hold of dangerous Object.* methods obj === Object){:throw $parseMinErr('isecobj','Referencing Object in Angular expressions is disallowed! Expression: {0}',fullExpression)}var CALL = Function.prototype.call; var APPLY = Function.prototype.apply; var BIND = Function.prototype.bind; function ensureSafeFunction(obj,fullExpression){:if(obj) { if(obj.constructor === obj) { throw $parseMinErr('isecfn','Referencing Function in Angular expressions is disallowed! Expression: {0}',fullExpression)}else if (obj === CALL || obj === APPLY || obj === BIND){:throw $parseMinErr('isecff','Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',fullExpression)}//Keyword constants var CONSTANTS = createMap(); forEach({'null':function() { return null},'true': function(){:return true},'false': function(){:return false},function(constantGetter,name){:constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;:CONSTANTS[name]= constantGetter}); //Not quite a constant,but can be lex/parsed the same CONSTANTS['this'] = function(self){:return self}; CONSTANTS['this'].sharedGetter = true; //Operators - will be wrapped by binaryFn/unaryFn/assignment/filter var OPERATORS = extend(createMap(),{'+':function(self,locals,a,b) { a=a(self,locals):b=b(self,locals);:if(isDefined(a)) { if(isDefined(b)) { return a + b},'-':function(self,locals,a,b){:a=a(self,locals);:b=b(self,locals);return(isDefined(a) ? a:0) - (isDefined(b) ? b:0)},'*':function(self,locals,a,b){:return a(self,locals) * b(self,locals)},'/':function(self,locals,a,b){:return a(self,locals) / b(self,locals)},'%':function(self,locals,a,b){:return a(self,locals) % b(self,locals)},'===':function(self,locals,a,b){:return a(self,locals) === b(self,locals)},'!==':function(self,locals,a,b){:return a(self,locals) !== b(self,locals)},'==':function(self,locals,a,b){:return a(self,locals) == b(self,locals)},'!=':function(self,locals,a,b){:return a(self,locals) != b(self,locals)},'<':function(self,locals,a,b){:return a(self,locals) < b(self,locals)},'>':function(self,locals,a,b){:return a(self,locals) > b(self,locals)},'<=':function(self,locals,a,b){:return a(self,locals) <= b(self,locals)},'>=':function(self,locals,a,b){:return a(self,locals) >= b(self,locals)},'&&':function(self,locals,a,b){:return a(self,locals) && b(self,locals)},'||':function(self,locals,a,b){:return a(self,locals) || b(self,locals)},'!':function(self,locals,a){:return !a(self,locals)}); var ESCAPE ={"n":"\n","f":"\f","r":"\r","t":"\t","v":"\v","'":"'",'"':'"'}; ///////////////////////////////////////// var Lexer = function(options){:this.options = options}; Lexer.prototype ={constructor:Lexer,lex:function(text) { this.text = text;:this.index = 0;:this.tokens =[];:while(this.index < this.text.length) { var ch = this.text.charAt(this.index);:if(ch === '"' || ch === "'") { this.readString(ch)}else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())){:this.readNumber()}else if (this.isIdent(ch)){:this.readIdent()}else if (this.is(ch,'(){}[].,;:?')){this.tokens.push({index:this.index,text:ch}else if (this.isWhitespace(ch)){:this.index++}else{if(op1 || op2 || op3) { var token = op3 ? ch3(op2 ? ch2:ch);this.tokens.push({index:this.index,text:token,operator:true},is: function(ch,chars){:return chars.indexOf(ch) !== -1},peek: function(i){:var num = i || 1;return(this.index + num < this.text.length) ? this.text.charAt(this.index + num):false},isNumber: function(ch){:return('0' <= ch && ch <= '9') && typeof ch === "string"},isWhitespace: function(ch){:// IE treats non-breaking space as \u00A0 return(ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0')},isIdent: function(ch){:return('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$')},isExpOperator: function(ch){:return(ch === '-' || ch === '+' || this.isNumber(ch))},throwError: function(error,start,end){:end = end || this.index;var colStr =(isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start,end) + ']':' ' + end);:throw $parseMinErr('lexerr','Lexer Error: {0} at column{1} in expression [{2}].',error,colStr,this.text)},readNumber: function(){:var number = '';:var start = this.index;:while(this.index < this.text.length) { var ch = lowercase(this.text.charAt(this.index));:if(ch == '.' || this.isNumber(ch)) { number += ch}else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e'){:number += ch}else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e'){:this.throwError('Invalid exponent')},readIdent: function(){:var start = this.index;:while(this.index < this.text.length) { var ch = this.text.charAt(this.index);:if(!(this.isIdent(ch) || this.isNumber(ch))) { break}this.tokens.push({index:start,text:this.text.slice(start,this.index),identifier:true},readString: function(quote){:var start = this.index;:this.index++;:var string = '';:var rawString = quote;:var escape = false;:while(this.index < this.text.length) { var ch = this.text.charAt(this.index);:rawString += ch;:if(escape) { if(ch === 'u') { var hex = this.text.substring(this.index + 1,this.index + 5);:if(!hex.match(/[\da-f]{4}else if (ch === '\\'){:escape = true}else if (ch === quote){:this.index++;this.tokens.push({ index:start,text:rawString,constant:true,value:string}; function isConstant(exp){:return exp.constant}var Parser = function(lexer,$filter,options){:this.lexer = lexer;:this.$filter = $filter;:this.options = options}; Parser.ZERO = extend(function(){:return 0}{sharedGetter:true,constant:true}); Parser.prototype ={constructor:Parser,parse:function(text) { this.text = text;:this.tokens = this.lexer.lex(text);:var value = this.statements();:if(this.tokens.length !== 0) { this.throwError('is an unexpected token',this.tokens[0])},primary: function(){:var primary;:if(this.expect('(')) { primary = this.filterChain();:this.consume(')')}else if (this.expect('[')){:primary = this.arrayDeclaration()}else if (this.expect('{')){:primary = this.object()}else if (this.peek().identifier && this.peek().text in CONSTANTS){:primary = CONSTANTS[this.consume().text]}else if (this.peek().identifier){:primary = this.identifier()}else if (this.peek().constant){:primary = this.constant()}context; while ((next = this.expect('(','[','.'))),var next{:if(next.text === '(') { primary = this.functionCall(primary,context);:context = null}else if (next.text === '['){:context = primary;:primary = this.objectIndex(primary)}else if (next.text === '.'){:context = primary;:primary = this.fieldAccess(primary)},throwError: function(msg,token){:throw $parseMinErr('syntax','Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',token.text,msg(token.index + 1),this.text,this.text.substring(token.index))},peekToken: function(){:if(this.tokens.length === 0) throw $parseMinErr('ueoe','Unexpected end of expression: {0}',this.text);:return this.tokens[0]},peek: function(e1,e2,e3,e4){:return this.peekAhead(0,e1,e2,e3,e4)},peekAhead: function(i,e1,e2,e3,e4){:if(this.tokens.length > i) { var token = this.tokens[i];:var t = token.text;:if(t === e1 || t === e2 || t === e3 || t === e4 ||(!e1 && !e2 && !e3 && !e4)) { return token},expect: function(e1,e2,e3,e4){:var token = this.peek(e1,e2,e3,e4);:if(token) { this.tokens.shift();:return token},consume: function(e1){:if(this.tokens.length === 0) { throw $parseMinErr('ueoe','Unexpected end of expression: {0}',this.text)}var token = this.expect(e1); if (!token){:this.throwError('is unexpected, expecting [' + e1 + ']',this.peek())},unaryFn: function(op,right){:var fn = OPERATORS[op];:return extend(function $parseUnaryFn(self,locals) { return fn(self,locals,right)},binaryFn: function(left,op,right,isBranching){:var fn = OPERATORS[op];:return extend(function $parseBinaryFn(self,locals) { return fn(self,locals,left,right)},identifier: function(){:var id = this.consume().text;://Continue reading each `.identifier` unless it is a method invocation while(this.peek('.') && this.peekAhead(1).identifier && !this.peekAhead(2,'(')) { id += this.consume().text + this.consume().text},constant: function(){:var value = this.consume().value;:return extend(function $parseConstant() { return value},statements: function(){:var statements =[];:while(true) { if(this.tokens.length > 0 && !this.peek('}',')',';',']')) statements.push(this.filterChain());if(!this.expect(';')) { // optimize for the common case where there is only one statement. // TODO(size):maybe we should not support multiple statements? return(statements.length === 1) ? statements[0:function $parseStatements(self,locals) { var value;:for(var i = 0,ii = statements.length;:i < ii;:i++) { value = statements[i](self,locals)},filterChain: function(){:var left = this.expression();:var token;:while((token = this.expect('|'))) { left = this.filter(left)},filter: function(inputFn){:var fn = this.$filter(this.consume().text);:var argsFn;:var args;:if(this.peek(':')) { argsFn =[];:args =[];:// we can safely reuse the array while(this.expect(':')) { argsFn.push(this.expression())}var inputs = [inputFn].concat(argsFn || []); return extend(function $parseFilter(self,locals){:var input = inputFn(self,locals);:if(args) { args[0]= input;:var i = argsFn.length;:while(i--) { args[i + 1]= argsFn[i](self,locals)},expression: function(){:return this.assignment()},assignment: function(){:var left = this.ternary();:var right;:var token;:if((token = this.expect('='))) { if(!left.assign) { this.throwError('implies assignment but [' + this.text.substring(0,token.index) + '] can not be assigned to',token)}right = this.ternary(); return extend(function $parseAssignment(scope,locals){:return left.assign(scope,right(scope,locals),locals)},ternary: function(){:var left = this.logicalOR();:var middle;:var token;:if((token = this.expect('?'))) { middle = this.assignment();:if(this.consume(':')) { var right = this.assignment();return extend(function $parseTernary(self,locals) { return left(self,locals) ? middle(self,locals):right(self,locals)}{constant:left.constant && middle.constant && right.constant},logicalOR: function(){:var left = this.logicalAND();:var token;:while((token = this.expect('||'))) { left = this.binaryFn(left,token.text,this.logicalAND(),true)},logicalAND: function(){:var left = this.equality();:var token;:while((token = this.expect('&&'))) { left = this.binaryFn(left,token.text,this.equality(),true)},equality: function(){:var left = this.relational();:var token;:while((token = this.expect('==','!=','===','!=='))) { left = this.binaryFn(left,token.text,this.relational())},relational: function(){:var left = this.additive();:var token;:while((token = this.expect('<','>','<=','>='))) { left = this.binaryFn(left,token.text,this.additive())},additive: function(){:var left = this.multiplicative();:var token;:while((token = this.expect('+','-'))) { left = this.binaryFn(left,token.text,this.multiplicative())},multiplicative: function(){:var left = this.unary();:var token;:while((token = this.expect('*','/','%'))) { left = this.binaryFn(left,token.text,this.unary())},unary: function(){:var token;:if(this.expect('+')) { return this.primary()}else if ((token = this.expect('-'))){:return this.binaryFn(Parser.ZERO,token.text,this.unary())}else if ((token = this.expect('!'))){:return this.unaryFn(token.text,this.unary())},fieldAccess: function(object){:var getter = this.identifier();:return extend(function $parseFieldAccess(scope,locals,self) { var o = self || object(scope,locals);return(o == null) ? undefined:getter(o)},objectIndex: function(obj){:var expression = this.text;:var indexFn = this.expression();:this.consume(']');:return extend(function $parseObjectIndex(self,locals) { var o = obj(self,locals),i = indexFn(self,locals),v;:ensureSafeMemberName(i,expression);:if(!o) return undefined;:v = ensureSafeObject(o[i],expression);:return v}{assign:function(self,value,locals) { var key = ensureSafeMemberName(indexFn(self,locals),expression)},functionCall: function(fnGetter,contextGetter){:var argsFn =[];:if(this.peekToken().text !== ')') { do { argsFn.push(this.expression())}this.consume(')'); var expressionText = this.text; // we can safely reuse the array across invocations var args = argsFn.length ? [] : null; return function $parseFunctionCall(scope,locals){var context = contextGetter ? contextGetter(scope,locals):isDefined(contextGetter) ? undefined:scope;:var fn = fnGetter(scope,locals,context) || noop;:if(args) { var i = argsFn.length;:while(i--) { args[i]= ensureSafeObject(argsFn[i](scope,locals),expressionText)}.'), key;
  for (var i = 0; element.length > 1; i++) {
    key = ensureSafeMemberName(element.shift(), fullExp);
    var propertyObj = (i === 0 && locals && locals[key]) || obj[key];
    if (!propertyObj) {
      propertyObj = {};
      obj[key] = propertyObj;
    }
    obj = ensureSafeObject(propertyObj, fullExp);
  }
  key = ensureSafeMemberName(element.shift(), fullExp);
  ensureSafeObject(obj[key], fullExp);
  obj[key] = setValue;
  return setValue;
}

var getterFnCacheDefault = createMap();
var getterFnCacheExpensive = createMap();

function isPossiblyDangerousMemberName(name) {
  return name == 'constructor';
}

/**
 * Implementation of the "Black Hole" variant from:
 * - http://jsperf.com/angularjs-parse-getter/4
 * - http://jsperf.com/path-evaluation-simplified/7
 */
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);
  var eso = function(o) {
    return ensureSafeObject(o, fullExp);
  };
  var eso0 = (expensiveChecks || isPossiblyDangerousMemberName(key0)) ? eso : identity;
  var eso1 = (expensiveChecks || isPossiblyDangerousMemberName(key1)) ? eso : identity;
  var eso2 = (expensiveChecks || isPossiblyDangerousMemberName(key2)) ? eso : identity;
  var eso3 = (expensiveChecks || isPossiblyDangerousMemberName(key3)) ? eso : identity;
  var eso4 = (expensiveChecks || isPossiblyDangerousMemberName(key4)) ? eso : identity;

  return function cspSafeGetter(scope, locals) {
    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;

    if (pathVal == null) return pathVal;
    pathVal = eso0(pathVal[key0]);

    if (!key1) return pathVal;
    if (pathVal == null) return undefined;
    pathVal = eso1(pathVal[key1]);

    if (!key2) return pathVal;
    if (pathVal == null) return undefined;
    pathVal = eso2(pathVal[key2]);

    if (!key3) return pathVal;
    if (pathVal == null) return undefined;
    pathVal = eso3(pathVal[key3]);

    if (!key4) return pathVal;
    if (pathVal == null) return undefined;
    pathVal = eso4(pathVal[key4]);

    return pathVal;
  };
}

function getterFnWithEnsureSafeObject(fn, fullExpression) {
  return function(s, l) {
    return fn(s, l, ensureSafeObject, fullExpression);
  };
}

function getterFn(path, options, fullExp) {
  var expensiveChecks = options.expensiveChecks;
  var getterFnCache = (expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault);
  var fn = getterFnCache[path];
  if (fn) return fn;


  var pathKeys = path.split('.'),
      pathKeysLength = pathKeys.length;

  // http://jsperf.com/angularjs-parse-getter/6
  if (options.csp) {
    if (pathKeysLength < 6) {
      fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
    } else {
      fn = function cspSafeGetter(scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++],
                                pathKeys[i++], fullExp, expensiveChecks)(scope, locals);

          locals = undefined; // clear after first iteration
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    }
  } else {
    var code = '';
    if (expensiveChecks) {
      code += 's = eso(s,fe);\nl = eso(l,fe);\n';
    }
    var needsEnsureSafeObject = expensiveChecks;
    forEach(pathKeys, function(key, index) {
      ensureSafeMemberName(key, fullExp);
      var lookupJs = (index
                      // we simply dereference 's' on any .dot notation
                      ? 's'
                      // but if we are first then we check locals first, and if so read it first
                      : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + '.' + key;
      if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
        lookupJs = 'eso(' + lookupJs + ',fe)';
        needsEnsureSafeObject = true;
      }
      code += 'if(s == null) return undefined;\n' +
              's=' + lookupJs + ';\n';
    });
    code += 'return s;';

    /* jshint -W054 */
    var evaledFnGetter = new Function('s', 'l', 'eso', 'fe', code); // s=scope, l=locals, eso=ensureSafeObject
    /* jshint +W054 */
    evaledFnGetter.toString = valueFn(code);
    if (needsEnsureSafeObject) {
      evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
    }
    fn = evaledFnGetter;
  }

  fn.sharedGetter = true;
  fn.assign = function(self, value, locals) {
    return setter(self, locals, path, value, path);
  };
  getterFnCache[path] = fn;
  return fn;
}

var objectValueOf = Object.prototype.valueOf;

function getValueOf(value) {
  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
}

///////////////////////////////////

/**
 * @ngdoc service
 * @name $parse
 * @kind function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * ```js
 *   var getter = $parse('user.name');
 *   var setter = getter.assign;
 *   var context = {user:{name:'angular'}};
 *   var locals = {user:{name:'local'}};
 *
 *   expect(getter(context)).toEqual('angular');
 *   setter(context, 'newValue');
 *   expect(context.user.name).toEqual('newValue');
 *   expect(getter(context, locals)).toEqual('local');
 * ```
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
 *      `context`.
 *
 *    The returned function also has the following properties:
 *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript * literal. * * `constant`  `{:boolean}`  whether the expression is made entirely of JavaScript * constant literals. * * `assign`  `{:?function(context,value)}`  if the expression is assignable,this will be * set to a function to change its value on the given context. * */ function $ParseProvider(){:var cacheDefault = createMap();:var cacheExpensive = createMap();this.$get =['$filter','$sniffer',function($filter,$sniffer) { var $parseOptions = { csp:$sniffer.csp,expensiveChecks:false},$parseOptionsExpensive ={csp:$sniffer.csp,expensiveChecks:true}; function wrapSharedExpression(exp){:var wrapped = exp;:if(exp.sharedGetter) { wrapped = function $parseWrapper(self,locals) { return exp(self,locals)}return function $parse(exp,interceptorFn,expensiveChecks){:var parsedExpression,oneTime,cacheKey;switch(typeof exp) { case 'string':cacheKey = exp = exp.trim();var cache =(expensiveChecks ? cacheExpensive:cacheDefault);:parsedExpression = cache[cacheKey];:if(!parsedExpression) { if(exp.charAt(0) === ':' && exp.charAt(1) === ':') { oneTime = true;:exp = exp.substring(2)}var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions; var lexer = new Lexer(parseOptions); var parser = new Parser(lexer,$filter,parseOptions); parsedExpression = parser.parse(exp); if (parsedExpression.constant){:parsedExpression.$$watchDelegate = constantWatchDelegate}else if (oneTime){://oneTime is not part of the exp passed to the Parser so we may have to //wrap the parsedExpression before adding a $$watchDelegate parsedExpression = wrapSharedExpression(parsedExpression);parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate:oneTimeWatchDelegate}else if (parsedExpression.inputs){:parsedExpression.$$watchDelegate = inputsWatchDelegate}; function collectExpressionInputs(inputs,list){:for(var i = 0,ii = inputs.length;:i < ii;:i++) { var input = inputs[i];:if(!input.constant) { if(input.inputs) { collectExpressionInputs(input.inputs,list)}else if (list.indexOf(input) === -1){:// TODO(perf) can we do better? list.push(input)}function expressionInputDirtyCheck(newValue,oldValueOfValue){:if(newValue == null || oldValueOfValue == null) { // null/undefined return newValue === oldValueOfValue}if (typeof newValue === 'object'){// attempt to convert the value to a primitive type // TODO(docs):add a note to docs that by implementing valueOf even objects and arrays can // be cheaply dirty-checked newValue = getValueOf(newValue);:if(typeof newValue === 'object') { // objects/arrays are not supported - deep-watching them would be too expensive return false}function inputsWatchDelegate(scope,listener,objectEquality,parsedExpression){:var inputExpressions = parsedExpression.$$inputs ||(parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs[]));:var lastResult;:if(inputExpressions.length === 1) { var oldInputValue = expressionInputDirtyCheck;:// init to something unique so that equals check fails inputExpressions = inputExpressions[0];:return scope.$watch(function expressionInputWatch(scope) { var newInputValue = inputExpressions(scope);:if(!expressionInputDirtyCheck(newInputValue,oldInputValue)) { lastResult = parsedExpression(scope);:oldInputValue = newInputValue && getValueOf(newInputValue)}var oldInputValueOfValues = []; for (var i = 0,ii = inputExpressions.length; i < ii; i++){:oldInputValueOfValues[i]= expressionInputDirtyCheck;:// init to something unique so that equals check fails}return scope.$watch(function expressionInputsWatch(scope){:var changed = false;:for(var i = 0,ii = inputExpressions.length;:i < ii;:i++) { var newInputValue = inputExpressions[i](scope);:if(changed ||(changed = !expressionInputDirtyCheck(newInputValue,oldInputValueOfValues[i]))) { oldInputValueOfValues[i]= newInputValue && getValueOf(newInputValue)}if (changed){:lastResult = parsedExpression(scope)}function oneTimeWatchDelegate(scope,listener,objectEquality,parsedExpression){:var unwatch,lastValue;:return unwatch = scope.$watch(function oneTimeWatch(scope) { return parsedExpression(scope)}if (isDefined(value)){:scope.$$postDigest(function() { if(isDefined(lastValue)) { unwatch()}function oneTimeLiteralWatchDelegate(scope,listener,objectEquality,parsedExpression){:var unwatch,lastValue;:return unwatch = scope.$watch(function oneTimeWatch(scope) { return parsedExpression(scope)},function oneTimeListener(value,old,scope){:lastValue = value;:if(isFunction(listener)) { listener.call(this,value,old,scope)}if (isAllDefined(value)){:scope.$$postDigest(function() { if(isAllDefined(lastValue)) unwatch()},objectEquality); function isAllDefined(value){:var allDefined = true;:forEach(value,function(val) { if(!isDefined(val)) allDefined = false}function constantWatchDelegate(scope,listener,objectEquality,parsedExpression){:var unwatch;:return unwatch = scope.$watch(function constantWatch(scope) { return parsedExpression(scope)},function constantListener(value,old,scope){:if(isFunction(listener)) { listener.apply(this,arguments)}function addInterceptor(parsedExpression,interceptorFn){:if(!interceptorFn) return parsedExpression;:var watchDelegate = parsedExpression.$$watchDelegate;:var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;:var fn = regularWatch ? function regularInterceptedExpression(scope,locals) { var value = parsedExpression(scope,locals);:return interceptorFn(value,scope,locals)}: function oneTimeInterceptedExpression(scope,locals){:var value = parsedExpression(scope,locals);:var result = interceptorFn(value,scope,locals);// we only return the interceptor's result if the
        // initial value is defined (for bind-once)
        return isDefined(value) ? result : value;
      };

      // Propagate $$watchDelegates other then inputsWatchDelegate
      if (parsedExpression.$$watchDelegate &&
          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
        fn.$$watchDelegate = parsedExpression.$$watchDelegate;
      } else if (!interceptorFn.$stateful) {
        // If there is an interceptor, but no watchDelegate then treat the interceptor like
        // we treat filters - it is assumed to be a pure function unless flagged with $stateful
        fn.$$watchDelegate = inputsWatchDelegate;
        fn.inputs = [parsedExpression];
      }

      return fn;
    }
  }];
}

/**
 * @ngdoc service
 * @name $q
 * @requires $rootScope
 *
 * @description
 * A service that helps you run functions asynchronously, and use their return values (or exceptions)
 * when they are done processing.
 *
 * This is an implementation of promises/deferred objects inspired by
 * [Kris Kowal's Q](https://github.com/kriskowal/q). * * $q can be used in two fashions --- one which is more similar to Kris Kowal's Q or jQuery's Deferred * implementations,and the other which resembles ES6 promises to some degree. * * # $q constructor * * The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver` * function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,* see[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). * * While the constructor-style use is supported,not all of the supporting methods from ES6 Harmony promises are * available yet. * * It can be used like so:* * ```js * // for the purpose of this example let's assume that variables `$q` and `okToGreet`
 *   // are available in the current lexical scope (they could have been injected or passed in).
 *
 *   function asyncGreet(name) {
 *     // perform some asynchronous operation, resolve or reject the promise when appropriate.
 *     return $q(function(resolve, reject) {
 *       setTimeout(function() {
 *         if (okToGreet(name)) {
 *           resolve('Hello,' + name + '!');
 *         } else {
 *           reject('Greeting ' + name + ' is not allowed.');
 *         }
 *       }, 1000);
 *     });
 *   }
 *
 *   var promise = asyncGreet('Robin Hood');
 *   promise.then(function(greeting) {
 *     alert('Success:' + greeting);
 *   }, function(reason) {
 *     alert('Failed:' + reason);
 *   });
 * ```
 *
 * Note: progress/notify callbacks are not currently supported via the ES6-style interface.
 *
 * However, the more traditional CommonJS-style usage is still available, and documented below.
 *
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
 * interface for interacting with an object that represents the result of an action that is
 * performed asynchronously, and may or may not be finished at any given point in time.
 *
 * From the perspective of dealing with error handling, deferred and promise APIs are to
 * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
 *
 * ```js
 *   // for the purpose of this example let's assume that variables `$q` and `okToGreet` * // are available in the current lexical scope(they could have been injected or passed in). * * function asyncGreet(name) { * var deferred = $q.defer();:* * setTimeout(function() { * deferred.notify('About to greet ' + name + '.');:* * if(okToGreet(name)) { * deferred.resolve('Hello, ' + name + '!');:*}* * var promise = asyncGreet('Robin Hood'); * promise.then(function(greeting){:* alert('Success: ' + greeting);:*},function(update){:* alert('Got notification: ' + update);:*}); * ``` * * At first it might not be obvious why this extra complexity is worth the trouble. The payoff * comes in the way of guarantees that promise and deferred APIs make,as well as the status * of the task. * * **Methods** * * - `resolve(value)`  resolves the derived promise with the `value`. If the value is a rejection * constructed via `$q.reject`,see * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md. * * Additionally the promise api allows for composition that is very hard to do with the * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach. * For more on this please see the [Qdocumentation](https://github.com/kriskowal/q) especially the * section on serial or parallel joining of promises. * * # The Deferred API * * A new instance of deferred is constructed by calling `$q.defer()`. * * The purpose of the deferred object is to expose the associated Promise instance as well as APIs * that can be used for signaling the successful or unsuccessful completion,the promise will be rejected instead. * - `reject(reason)`  rejects the derived promise with the `reason`. This is equivalent to * resolving it with a rejection constructed via `$q.reject`. * - `notify(value)` - provides updates on the status of the promise's execution. This may be called
 *   multiple times before the promise is either resolved or rejected.
 *
 * **Properties**
 *
 * - promise  `{Promise}`  promise object associated with this deferred.
 *
 *
 * # The Promise API
 *
 * A new promise instance is created when a deferred instance is created and can be retrieved by
 * calling `deferred.promise`.
 *
 * The purpose of the promise object is to allow for interested parties to get access to the result
 * of the deferred task when it completes.
 *
 * **Methods**
 *
 * - `then(successCallback, errorCallback, notifyCallback)`  regardless of when the promise was or
 *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
 *   as soon as the result is available. The callbacks are called with a single argument: the result
 *   or rejection reason. Additionally, the notify callback may be called zero or more times to
 *   provide a progress indication, before the promise is resolved or rejected.
 *
 *   This method *returns a new promise* which is resolved or rejected via the return value of the
 *   `successCallback`, `errorCallback`. It also notifies via the return value of the
 *   `notifyCallback` method. The promise cannot be resolved or rejected from the notifyCallback
 *   method.
 *
 * - `catch(errorCallback)`  shorthand for `promise.then(null, errorCallback)`
 *
 * - `finally(callback, notifyCallback)`  allows you to observe either the fulfillment or rejection of a promise,
 *   but to do so without modifying the final value. This is useful to release resources or do some
 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
 *   more information.
 *
 * # Chaining promises
 *
 * Because calling the `then` method of a promise returns a new derived promise, it is easily
 * possible to create a chain of promises:
 *
 * ```js
 *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
 *
 *   // promiseB will be resolved immediately after promiseA is resolved and its value
 *   // will be the result of promiseA incremented by 1
 * ```
 *
 * It is possible to create chains of any length and since a promise can be resolved with another
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
 * the promises at any point in the chain. This makes it possible to implement powerful APIs like
 * $http's response interceptors. * * * # Differences between Kris Kowal's Q and $q
 *
 *  There are two main differences:
 *
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
 *   mechanism in angular, which means faster propagation of resolution or rejection into your
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
 *   all the important functionality needed for common async tasks.
 *
 *  # Testing
 *
 *  ```js
 *    it('should simulate promise', inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 *
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the 'then' function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Propagate promise resolution to 'then' functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    }));
 *  ```
 *
 * @param {function(function, function)} resolver Function which is responsible for resolving or
 *   rejecting the newly created promise. The first parameter is a function which resolves the
 *   promise, the second parameter is a function which rejects the promise.
 *
 * @returns {Promise} The newly created promise.
 */
function $QProvider() {

  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
    return qFactory(function(callback) {
      $rootScope.$evalAsync(callback);
    }, $exceptionHandler);
  }];
}

function $$QProvider() {
  this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
    return qFactory(function(callback) {
      $browser.defer(callback);
    }, $exceptionHandler);
  }];
}

/**
 * Constructs a promise manager.
 *
 * @param {function(function)} nextTick Function for executing functions in the next turn.
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
 *     debugging purposes.
 * @returns {object} Promise manager.
 */
function qFactory(nextTick, exceptionHandler) {
  var $qMinErr = minErr('$q', TypeError);
  function callOnce(self, resolveFn, rejectFn) {
    var called = false;
    function wrap(fn) {
      return function(value) {
        if (called) return;
        called = true;
        fn.call(self, value);
      };
    }

    return [wrap(resolveFn), wrap(rejectFn)];
  }

  /**
   * @ngdoc method
   * @name ng.$q#defer
   * @kind function
   *
   * @description
   * Creates a `Deferred` object which represents a task which will finish in the future.
   *
   * @returns {Deferred} Returns a new instance of deferred.
   */
  var defer = function() {
    return new Deferred();
  };

  function Promise() {
    this.$$state = { status: 0 };
  }

  Promise.prototype = {
    then: function(onFulfilled, onRejected, progressBack) {
      var result = new Deferred();

      this.$$state.pending = this.$$state.pending || [];
      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
      if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);

      return result.promise;
    },

    "catch": function(callback) {
      return this.then(null, callback);
    },

    "finally": function(callback, progressBack) {
      return this.then(function(value) {
        return handleCallback(value, true, callback);
      }, function(error) {
        return handleCallback(error, false, callback);
      }, progressBack);
    }
  };

  //Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native
  function simpleBind(context, fn) {
    return function(value) {
      fn.call(context, value);
    };
  }

  function processQueue(state) {
    var fn, promise, pending;

    pending = state.pending;
    state.processScheduled = false;
    state.pending = undefined;
    for (var i = 0, ii = pending.length; i < ii; ++i) {
      promise = pending[i][0];
      fn = pending[i][state.status];
      try {
        if (isFunction(fn)) {
          promise.resolve(fn(state.value));
        } else if (state.status === 1) {
          promise.resolve(state.value);
        } else {
          promise.reject(state.value);
        }
      } catch (e) {
        promise.reject(e);
        exceptionHandler(e);
      }
    }
  }

  function scheduleProcessQueue(state) {
    if (state.processScheduled || !state.pending) return;
    state.processScheduled = true;
    nextTick(function() { processQueue(state); });
  }

  function Deferred() {
    this.promise = new Promise();
    //Necessary to support unbound execution :/
    this.resolve = simpleBind(this, this.resolve);
    this.reject = simpleBind(this, this.reject);
    this.notify = simpleBind(this, this.notify);
  }

  Deferred.prototype = {
    resolve: function(val) {
      if (this.promise.$$state.status) return;
      if (val === this.promise) {
        this.$$reject($qMinErr(
          'qcycle',
          "Expected promise to be resolved with value other than itself '{:0},function(reason),t need to worry about it. * * When comparing deferreds/promises to the familiar behavior of try/catch/throw,think of * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via * a promise error callback and you want to forward the error to the promise derived from the * current promise,you have to "rethrow" the error by returning a rejection constructed via * `reject`. * * ```js * promiseB = promiseA.then(function(result){:*}Returns a promise that was already resolved as rejected with the `reason`. */ var reject = function(reason){:var result = new Deferred();:result.reject(reason);:return result.promise}; var makePromise = function makePromise(value,resolved){:var result = new Deferred();:if(resolved) { result.resolve(value)}; var handleCallback = function handleCallback(value,isResolved,callback){:var callbackOutput = null;:try { if(isFunction(callback)) callbackOutput = callback()}if (isPromiseLike(callbackOutput)){:return callbackOutput.then(function() { return makePromise(value,isResolved)},function(error){:return makePromise(error,false)}; var when = function(value,callback,errback,progressBack){:var result = new Deferred();:result.resolve(value);:return result.promise.then(callback,errback,progressBack)}; function all(promises){var deferred = new Deferred(),counter = 0,results = isArray(promises) ?[:{}; forEach(promises,function(promise,key){:counter++;:when(promise).then(function(value) { if(results.hasOwnProperty(key)) return;:results[key]= value;:if(!(--counter)) deferred.resolve(results)},function(reason){:if(results.hasOwnProperty(key)) return;:deferred.reject(reason)}); if (counter === 0){:deferred.resolve(results)}var $Q = function Q(resolver){:if(!isFunction(resolver)) { throw $qMinErr('norslvr',"Expected resolverFn, got '{0}'",resolver)}if (!(this instanceof Q)){:// More useful when $Q is the Promise itself. return new Q(resolver)}var deferred = new Deferred(); function resolveFn(value){:deferred.resolve(value)}function rejectFn(reason){:deferred.reject(reason)}function $$RAFProvider(){://rAF this.$get =['$window','$timeout',function($window,$timeout) { var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;:var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;:var rafSupported = !!requestAnimationFrame;:var raf = rafSupported ? function(fn) { var id = requestAnimationFrame(fn);:return function() { cancelAnimationFrame(id)}: function(fn){:var timer = $timeout(fn,16.66,false);:// 1000 / 60 = 16.666 return function() { $timeout.cancel(timer)}function $RootScopeProvider(){:var TTL = 10;:var $rootScopeMinErr = minErr('$rootScope');:var lastDirtyWatch = null;:var applyAsyncId = null;:this.digestTtl = function(value) { if(arguments.length) { TTL = value}; this.$get = ['$injector','$browser''$parse''$exceptionHandler'function($injector,$exceptionHandler,$parse,$browser){:function Scope() { this.$id = nextUid();:this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;:this.$root = this;:this.$$destroyed = false;:this.$$listeners = {}Scope.prototype ={constructor:Scope,$new:function(isolate,parent) { var child;:parent = parent || this;:if(isolate) { child = new Scope();:child.$root = this.$root}child.$parent = parent; child.$$prevSibling = parent.$$childTail; if (parent.$$childHead){:parent.$$childTail.$$nextSibling = child;:parent.$$childTail = child}// When the new scope is not isolated or we inherit from `this`,and // the parent scope is destroyed,the property `$$destroyed` is inherited // prototypically. In all other cases,this property needs to be set // when the parent scope is destroyed. // The listener needs to be added after the parent is set if (isolate || parent != this) child.$on('$destroy',destroyChild); return child; function destroyChild(){:child.$$destroyed = true},$watch: function(watchExp,listener,objectEquality){:var get = $parse(watchExp);:if(get.$$watchDelegate) { return get.$$watchDelegate(this,listener,objectEquality,get)}array = scope.$$watchers,var scope = this,watcher ={fn:listener,last:initWatchVal,get:get,exp:watchExp,eq:!!objectEquality}; lastDirtyWatch = null; if (!isFunction(listener)){:watcher.fn = noop}if (!array){:array = scope.$$watchers =[]}// we use unshift since we use a while loop in $digest for speed. // the while loop reads in reverse order. array.unshift(watcher); return function deregisterWatch(){:arrayRemove(array,watcher);:lastDirtyWatch = null},$watchGroup: function(watchExpressions,listener){:var oldValues = new Array(watchExpressions.length);:var newValues = new Array(watchExpressions.length);:var deregisterFns =[];:var self = this;:var changeReactionScheduled = false;:var firstRun = true;:if(!watchExpressions.length) { // No expressions means we call the listener ASAP var shouldCall = true;:self.$evalAsync(function() { if(shouldCall) listener(newValues,newValues,self)}); return function deregisterWatchGroup(){:shouldCall = false}if (watchExpressions.length === 1){:// Special case size of one return this.$watch(watchExpressions[0],function watchGroupAction(value,oldValue,scope) { newValues[0]= value;:oldValues[0]= oldValue;listener(newValues(value === oldValue) ? newValues:oldValues,scope)}forEach(watchExpressions,function(expr,i){:var unwatchFn = self.$watch(expr,function watchGroupSubAction(value,oldValue) { newValues[i]= value;:oldValues[i]= oldValue;:if(!changeReactionScheduled) { changeReactionScheduled = true;:self.$evalAsync(watchGroupAction)}); function watchGroupAction(){:changeReactionScheduled = false;:if(firstRun) { firstRun = false;:listener(newValues,newValues,self)}return function deregisterWatchGroup(){:while(deregisterFns.length) { deregisterFns.shift()()},$watchCollection: function(obj,listener){:$watchCollectionInterceptor.$stateful = true;:var self = this;:// the current value,updated on each dirty-check run var newValue;:// a shallow copy of the newValue from the last dirty-check run,// updated to match newValue during dirty-check run var oldValue;:// a shallow copy of the newValue from when the last change happened var veryOldValue;:// only track veryOldValue if the listener is asking for it var trackVeryOldValue =(listener.length > 1);:var changeDetected = 0;:var changeDetector = $parse(obj,$watchCollectionInterceptor);:var internalArray =[];:var internalObject = {}; var initRun = true; var oldLength = 0; function $watchCollectionInterceptor(_value){:newValue = _value;:var newLength,key,bothNaN,newItem,oldItem;:// If the new value is undefined,then return undefined as the watch may be a one-time watch if(isUndefined(newValue)) return;:if(!isObject(newValue)) { // if primitive if(oldValue !== newValue) { oldValue = newValue;:changeDetected++}newLength = newValue.length; if (oldLength !== newLength){:// if lengths do not match we need to trigger change notification changeDetected++;:oldValue.length = oldLength = newLength}// copy the items to oldValue and look for changes. for (var i = 0; i < newLength; i++){:oldItem = oldValue[i];:newItem = newValue[i];:bothNaN =(oldItem !== oldItem) &&(newItem !== newItem);:if(!bothNaN &&(oldItem !== newItem)) { changeDetected++;:oldValue[i]= newItem}// copy the items to oldValue and look for changes. newLength = 0; for (key in newValue){:if(newValue.hasOwnProperty(key)) { newLength++;:newItem = newValue[key];:oldItem = oldValue[key];:if(key in oldValue) { bothNaN =(oldItem !== oldItem) &&(newItem !== newItem);:if(!bothNaN &&(oldItem !== newItem)) { changeDetected++;:oldValue[key]= newItem}if (oldLength>newLength){:// we used to have more keys,need to find them and destroy them. changeDetected++;:for(key in oldValue) { if(!newValue.hasOwnProperty(key)) { oldLength--;:delete oldValue[key]}function $watchCollectionAction(){:if(initRun) { initRun = false;:listener(newValue,newValue,self)}// make a copy for the next time a collection is changed if (trackVeryOldValue){:if(!isObject(newValue)) { //primitive veryOldValue = newValue}else if (isArrayLike(newValue)){:veryOldValue = new Array(newValue.length);:for(var i = 0;:i < newValue.length;:i++) { veryOldValue[i]= newValue[i]}; for (var key in newValue){:if(hasOwnProperty.call(newValue,key)) { veryOldValue[key]= newValue[key]},$digest: function(){:var watch,value,last,watchers,length,dirty,ttl = TTL,next,current,target = this,watchLog =[],logIdx,logMsg,asyncTask;:beginPhase('$digest');:// Check for changes to browser url that happened in sync before the call to $digest $browser.$$checkUrlChange();:if(this === $rootScope && applyAsyncId !== null) { // If this is the root scope,and $applyAsync has scheduled a deferred $apply(),then // cancel the scheduled $apply and flush the queue of expressions to be evaluated. $browser.defer.cancel(applyAsyncId);:flushApplyAsync()}lastDirtyWatch = null; do{:// "while dirty" loop dirty = false;:current = target;:while(asyncQueue.length) { try { asyncTask = asyncQueue.shift();:asyncTask.scope.$eval(asyncTask.expression,asyncTask.locals)}traverseScopesLoop: do{:// "traverse the scopes" loop if((watchers = current.$$watchers)) { // process our watches length = watchers.length;:while(length--) { try { watch = watchers[length];:// Most common watches are on primitives,in which case we can short // circuit it with === operator,only when === fails do we use .equals if(watch) { if((value = watch.get(current)) !==(last = watch.last) && !(watch.eq ? equals(value,last)(typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) { dirty = true;:lastDirtyWatch = watch;watch.last = watch.eq ? copy(value,null):value;watch.fn(value((last === initWatchVal) ? value:last),current);:if(ttl < 5) { logIdx = 4 - ttl;:if(!watchLog[logIdx]) watchLog[logIdx]=[];watchLog[logIdx].push({ msg:isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()):watch.exp,newVal:value,oldVal:last}else if (watch === lastDirtyWatch){:// If the most recently dirty watcher is now clean,short circuit since the remaining watchers // have already been tested. dirty = false;:break traverseScopesLoop}// Insanity Warning: scope depth-first traversal // yes,but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $broadcast if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))),this code is a bit crazy{:while(current !== target && !(next = current.$$nextSibling)) { current = current.$parent}while ((current = next)); // `break traverseScopesLoop;` takes us to here if ((dirty || asyncQueue.length) && !(ttl--)){:clearPhase();:throw $rootScopeMinErr('infdig','{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}',TTL,watchLog)}while (dirty || asyncQueue.length); clearPhase(); while (postDigestQueue.length){:try { postDigestQueue.shift()()},$destroy: function(){// we can't destroy the root scope or a scope that has been already destroyed
        if (this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast('$destroy');
        this.$$destroyed = true;
        if (this === $rootScope) return;

        for (var eventName in this.$$listenerCount) {
          decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
        }

        // sever all the references to parent scopes (after this cleanup, the current scope should
        // not be retained by any of our references and should be eligible for garbage collection)
        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // Disable listeners, watchers and apply/digest methods
        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
        this.$on = this.$watch = this.$watchGroup = function() { return noop; };
        this.$$listeners = {};

        // All of the code below is bogus code that works around V8's memory leak via optimized code // and inline caches. // // see:// - https://code.google.com/p/v8/issues/detail?id=2073#c26 // - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909 // - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451 this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null},$eval: function(expr,locals){:return $parse(expr)(this,locals)},$evalAsync: function(expr,locals){:// if we are outside of an $digest loop and this is the first time we are scheduling async // task also schedule async auto-flush if(!$rootScope.$$phase && !asyncQueue.length) { $browser.defer(function() { if(asyncQueue.length) { $rootScope.$digest()}asyncQueue.push({scope:this,expression:expr,locals:locals},$$postDigest: function(fn){:postDigestQueue.push(fn)},$apply: function(expr){:try { beginPhase('$apply');:return this.$eval(expr)},$applyAsync: function(expr){:var scope = this;:expr && applyAsyncQueue.push($applyAsyncExpression);:scheduleApplyAsync();:function $applyAsyncExpression() { scope.$eval(expr)},$on: function(name,listener){:var namedListeners = this.$$listeners[name];:if(!namedListeners) { this.$$listeners[name]= namedListeners =[]}namedListeners.push(listener); var current = this; do{:if(!current.$$listenerCount[name]) { current.$$listenerCount[name]= 0}while ((current = current.$parent)); var self = this; return function(){:var indexOfListener = namedListeners.indexOf(listener);:if(indexOfListener !== -1) { namedListeners[indexOfListener]= null;:decrementListenerCount(self,1,name)},$emit: function(name,args){var empty =[],namedListeners,scope = this,stopPropagation = false,event = { name:name,targetScope:scope,stopPropagation:function() {stopPropagation = true},preventDefault: function(){:event.defaultPrevented = true},listenerArgs = concat([event],arguments,1),i,length; do{:namedListeners = scope.$$listeners[name]|| empty;:event.currentScope = scope;:for(i = 0,length = namedListeners.length;:i < length;:i++) { // if listeners were deregistered,defragment the array if(!namedListeners[i]) { namedListeners.splice(i,1);:i--;:length--;:continue}//if any listener on the current scope stops propagation,prevent bubbling if (stopPropagation){:event.currentScope = null;:return event},$broadcast: function(name,args){var target = this,current = target,next = target,event = { name:name,targetScope:target,preventDefault:function() { event.defaultPrevented = true}; if (!target.$$listenerCount[name]) return event; var listenerArgs = concat([event],arguments,1),i,length; //down while you can,listeners,then up and next sibling or up and next sibling until back at root while ((current = next)){:event.currentScope = current;:listeners = current.$$listeners[name]||[];:for(i = 0,length = listeners.length;:i < length;:i++) { // if listeners were deregistered,defragment the array if(!listeners[i]) { listeners.splice(i,1);:i--;:length--;:continue}try{:listeners[i].apply(null,listenerArgs)}// Insanity Warning: scope depth-first traversal // yes,but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $digest // (though it differs due to having the extra check for $$listenerCount) if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))),this code is a bit crazy{:while(current !== target && !(next = current.$$nextSibling)) { current = current.$parent}; var $rootScope = new Scope(); //The internal queues. Expose them on the $rootScope for debugging/testing purposes. var asyncQueue = $rootScope.$$asyncQueue = []; var postDigestQueue = $rootScope.$$postDigestQueue = []; var applyAsyncQueue = $rootScope.$$applyAsyncQueue = []; return $rootScope; function beginPhase(phase){:if($rootScope.$$phase) { throw $rootScopeMinErr('inprog','{0} already in progress',$rootScope.$$phase)}function clearPhase(){:$rootScope.$$phase = null}function decrementListenerCount(current,count,name){:do { current.$$listenerCount[name]-= count;:if(current.$$listenerCount[name]=== 0) { delete current.$$listenerCount[name]}function flushApplyAsync(){:while(applyAsyncQueue.length) { try { applyAsyncQueue.shift()()}function scheduleApplyAsync(){:if(applyAsyncId === null) { applyAsyncId = $browser.defer(function() { $rootScope.$apply(flushApplyAsync)}function $$SanitizeUriProvider(){var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;:this.aHrefSanitizationWhitelist = function(regexp) { if(isDefined(regexp)) { aHrefSanitizationWhitelist = regexp;:return this}; this.imgSrcSanitizationWhitelist = function(regexp){:if(isDefined(regexp)) { imgSrcSanitizationWhitelist = regexp;:return this}; this.$get = function(){return function sanitizeUri(uri,isImage) { var regex = isImage ? imgSrcSanitizationWhitelist:aHrefSanitizationWhitelist;:var normalizedVal;:normalizedVal = urlResolve(uri).href;:if(normalizedVal !== '' && !normalizedVal.match(regex)) { return 'unsafe:' + normalizedVal}var $sceMinErr = minErr('$sce'); var SCE_CONTEXTS ={HTML:'html',CSS:'css',URL:'url',// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a // url.(e.g. ng-include,script src,templateUrl) RESOURCE_URL:'resourceUrl',JS:'js'}; // Helper functions follow. function adjustMatcher(matcher){:if(matcher === 'self') { return matcher}else if (isString(matcher)){:// Strings match exactly except for 2 wildcards - '*' and '**'. // '*' matches any character except those from the set ':/.?&'. // '**' matches any character(like .* in a RegExp). // More than 2 *'s raises an error as it's ill defined. if(matcher.indexOf('***') > -1) { throw $sceMinErr('iwcard','Illegal sequence *** in string matcher.  String: {0}',matcher)}else if (isRegExp(matcher)){:// The only other type of matcher allowed is a Regexp. // Match entire URL / disallow partial matches. // Flags are reset(i.e. no global,ignoreCase or multiline) return new RegExp('^' + matcher.source + '$')}function adjustMatchers(matchers){:var adjustedMatchers =[];:if(isDefined(matchers)) { forEach(matchers,function(matcher) { adjustedMatchers.push(adjustMatcher(matcher))}function $SceDelegateProvider(){:this.SCE_CONTEXTS = SCE_CONTEXTS;:// Resource URLs can also be trusted by policy. var resourceUrlWhitelist =['self'],resourceUrlBlacklist =[];:this.resourceUrlWhitelist = function(value) { if(arguments.length) { resourceUrlWhitelist = adjustMatchers(value)}; this.resourceUrlBlacklist = function(value){:if(arguments.length) { resourceUrlBlacklist = adjustMatchers(value)}; this.$get = ['$injector',function($injector){:var htmlSanitizer = function htmlSanitizer(html) { throw $sceMinErr('unsafe','Attempting to use an unsafe value in a safe context.')}; if ($injector.has('$sanitize')){:htmlSanitizer = $injector.get('$sanitize')}function matchUrl(matcher,parsedUrl){:if(matcher === 'self') { return urlIsSameOrigin(parsedUrl)}function isResourceUrlAllowedByPolicy(url){:var parsedUrl = urlResolve(url.toString());:var i,n,allowed = false;:// Ensure that at least one item from the whitelist allows this url. for(i = 0,n = resourceUrlWhitelist.length;:i < n;:i++) { if(matchUrl(resourceUrlWhitelist[i],parsedUrl)) { allowed = true;:break}if (allowed){:// Ensure that no item from the blacklist blocked this url. for(i = 0,n = resourceUrlBlacklist.length;:i < n;:i++) { if(matchUrl(resourceUrlBlacklist[i],parsedUrl)) { allowed = false;:break}function generateHolderType(Base){:var holderType = function TrustedValueHolderType(trustedValue) { this.$$unwrapTrustedValue = function() { return trustedValue}; if (Base){:holderType.prototype = new Base()}holderType.prototype.valueOf = function sceValueOf(){:return this.$$unwrapTrustedValue()}; holderType.prototype.toString = function sceToString(){:return this.$$unwrapTrustedValue().toString()}; byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]); function trustAs(type,trustedValue){var Constructor =(byType.hasOwnProperty(type) ? byType[type:null);:if(!Constructor) { throw $sceMinErr('icontext','Attempted to trust a value in invalid context. Context: {0}; Value: {1}',type,trustedValue)}if (trustedValue === null || trustedValue === undefined || trustedValue === ''){:return trustedValue}// All the current contexts in SCE_CONTEXTS happen to be strings. In order to avoid trusting // mutable objects,we ensure here that the value passed in is actually a string. if (typeof trustedValue !== 'string'){:throw $sceMinErr('itype','Attempted to trust a non-string value in a content requiring a string: Context: {0}',type)}function valueOf(maybeTrusted){:if(maybeTrusted instanceof trustedValueHolderBase) { return maybeTrusted.$$unwrapTrustedValue()}function getTrusted(type,maybeTrusted){:if(maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') { return maybeTrusted}var constructor = (byType.hasOwnProperty(type) ? byType[type] : null); if (constructor && maybeTrusted instanceof constructor){:return maybeTrusted.$$unwrapTrustedValue()}// If we get here,or // 2. throw an exception. if (type === SCE_CONTEXTS.RESOURCE_URL),then we may only take one of two actions. // 1. sanitize the value for the requested type{:if(isResourceUrlAllowedByPolicy(maybeTrusted)) { return maybeTrusted}else if (type === SCE_CONTEXTS.HTML){:return htmlSanitizer(maybeTrusted)}return{trustAs:trustAs,getTrusted:getTrusted,valueOf:valueOf}function $SceProvider(){:var enabled = true;:this.enabled = function(value) { if(arguments.length) { enabled = !!value}; this.$get = ['$parse','$sceDelegate'function( $parse,$sceDelegate){// Prereq:Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow
    // the "expression(javascript expression)" syntax which is insecure.
    if (enabled && msie < 8) {
      throw $sceMinErr('iequirks',
        'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' +
        'mode. You can fix this by adding the text <!doctype html> to the top of your HTML ' +
        'document. See http://docs.angularjs.org/api/ng.$sce for more information.');
    }

    var sce = shallowCopy(SCE_CONTEXTS);

    /**
     * @ngdoc method
     * @name $sce#isEnabled
     * @kind function
     *
     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
     *
     * @description
     * Returns a boolean indicating if SCE is enabled.
     */
    sce.isEnabled = function() {
      return enabled;
    };
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    if (!enabled) {
      sce.trustAs = sce.getTrusted = function(type, value) { return value; };
      sce.valueOf = identity;
    }

    /**
     * @ngdoc method
     * @name $sce#parseAs
     *
     * @description
     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
     * *result*)}
     *
     * @param {string} type The kind of SCE context in which this result will be used.
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */
    sce.parseAs = function sceParseAs(type, expr) {
      var parsed = $parse(expr);
      if (parsed.literal && parsed.constant) {
        return parsed;
      } else {
        return $parse(expr, function(value) {
          return sce.getTrusted(type, value);
        });
      }
    };

    /**
     * @ngdoc method
     * @name $sce#trustAs
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,
     * returns an object that is trusted by angular for use in specified strict contextual
     * escaping contexts (such as ng-bind-html, ng-include, any src attribute
     * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)
     * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual
     * escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resource_url, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */

    /**
     * @ngdoc method
     * @name $sce#trustAsHtml
     *
     * @description
     * Shorthand method.  `$sce.trustAsHtml(value)` 
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name $sce#trustAsUrl
     *
     * @description
     * Shorthand method.  `$sce.trustAsUrl(value)` 
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name $sce#trustAsResourceUrl
     *
     * @description
     * Shorthand method.  `$sce.trustAsResourceUrl(value)` 
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the return
     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name $sce#trustAsJs
     *
     * @description
     * Shorthand method.  `$sce.trustAsJs(value)` 
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name $sce#getTrusted
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
     * takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the
     * originally supplied value if the queried context type is a supertype of the created type.
     * If this condition isn't satisfied,throws an exception. * * @param {string}The value the was originally provided to *,maybeTrusted The result of a prior{:@link ng.$sce#trustAs `$sce.trustAs`}getTrusted = sce.getTrusted,if valid in this context. * Otherwise,throws an exception. */ // Shorthand delegations. var parse = sce.parseAs,trustAs = sce.trustAs; forEach(SCE_CONTEXTS,function(enumValue,name){:var lName = lowercase(name);:sce[camelCase("parse_as_" + lName)]= function(expr) { return parse(enumValue,expr)}; sce[camelCase("get_trusted_"+lName)] = function(value){:return getTrusted(enumValue,value)}; sce[camelCase("trust_as_"+lName)] = function(value){:return trustAs(enumValue,value)}function $SnifferProvider(){:this.$get =['$window','$document',function($window,$document) { var eventSupport = {},vendorPrefix,animations = false,bodyStyle = document.body && document.body.style,match; if (bodyStyle),transitions = false,vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/{:for(var prop in bodyStyle) { if(match = vendorRegex.exec(prop)) { vendorPrefix = match[0];:vendorPrefix = vendorPrefix.substr(0,1).toUpperCase() + vendorPrefix.substr(1);:break}if (!vendorPrefix){:vendorPrefix =('WebkitOpacity' in bodyStyle) && 'webkit'}transitions = !!(('transition' in bodyStyle) || (vendorPrefix+'Transition' in bodyStyle)); animations = !!(('animation' in bodyStyle) || (vendorPrefix+'Animation' in bodyStyle)); if (android && (!transitions || !animations)){:transitions = isString(document.body.style.webkitTransition);:animations = isString(document.body.style.webkitAnimation)}return{// Android has history.pushState,but it does not update location correctly // so let's not use the history API at all.
      // http://code.google.com/p/android/issues/detail?id=17471
      // https://github.com/angular/angular.js/issues/904

      // older webkit browser (533.9) on Boxee box has exactly the same problem as Android has
      // so let's not use the history API also // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined // jshint -W018 history:!!($window.history && $window.history.pushState && !(android < 4) && !boxee),// jshint +W018 hasEvent:function(event) { // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have // it. In particular the event is not fired when backspace or delete key are pressed or // when cut operation is performed. // IE10+ implements 'input' event but it erroneously fires under various situations,// e.g. when placeholder changes,or a form is focused. if(event === 'input' && msie <= 11) return false;:if(isUndefined(eventSupport[event])) { var divElm = document.createElement('div');:eventSupport[event]= 'on' + event in divElm}var $compileMinErr = minErr('$compile'); function $TemplateRequestProvider(){:this.$get =['$templateCache','$http','$q',function($templateCache,$http,$q) { function handleRequestFn(tpl,ignoreRequestError) { handleRequestFn.totalPendingRequests++;:var transformResponse = $http.defaults && $http.defaults.transformResponse;:if(isArray(transformResponse)) { transformResponse = transformResponse.filter(function(transformer) { return transformer !== defaultHttpResponseTransform}else if (transformResponse === defaultHttpResponseTransform){:transformResponse = null}var httpOptions ={cache:$templateCache,transformResponse:transformResponse}; return $http.get(tpl,httpOptions) .finally(function(){:handleRequestFn.totalPendingRequests--}) .then(function(response){:return response.data},handleError); function handleError(resp){:if(!ignoreRequestError) { throw $compileMinErr('tpload','Failed to load template: {0}',tpl)}function $$TestabilityProvider(){:this.$get =['$rootScope','$browser','$location',function($rootScope,$browser,$location) { var testability = {}; testability.findBindings = function(element,expression,opt_exactMatch){:var bindings = element.getElementsByClassName('ng-binding');:var matches =[];:forEach(bindings,function(binding) { var dataBinding = angular.element(binding).data('$binding');:if(dataBinding) { forEach(dataBinding,function(bindingName) { if(opt_exactMatch) { var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');:if(matcher.test(bindingName)) { matches.push(binding)}; testability.findModels = function(element,expression,opt_exactMatch){:var prefixes =['ng-','data-ng-','ng\\:'];:for(var p = 0;:p < prefixes.length;++p) { var attributeEquals = opt_exactMatch ? '=':'*=';:var selector = '[' + prefixes[p]+ 'model' + attributeEquals + '"' + expression + '"]';:var elements = element.querySelectorAll(selector);:if(elements.length) { return elements}; testability.getLocation = function(){:return $location.url()}; testability.setLocation = function(url){:if(url !== $location.url()) { $location.url(url);:$rootScope.$digest()}; testability.whenStable = function(callback){:$browser.notifyWhenNoOutstandingRequests(callback)}function $TimeoutProvider(){:this.$get =['$rootScope','$browser','$q','$$q','$exceptionHandler',function($rootScope,$browser,$q,$$q,$exceptionHandler) { var deferreds = {}; function timeout(fn,delay,invokeApply){var skipApply =(isDefined(invokeApply) && !invokeApply),deferred =(skipApply ? $$q:$q).defer(),promise = deferred.promise,timeoutId;:timeoutId = $browser.defer(function() { try { deferred.resolve(fn())}finally{:delete deferreds[promise.$$timeoutId]}timeout.cancel = function(promise){:if(promise && promise.$$timeoutId in deferreds) { deferreds[promise.$$timeoutId].reject('canceled');:delete deferreds[promise.$$timeoutId];:return $browser.defer.cancel(promise.$$timeoutId)}// NOTE:The usage of window and document instead of $window and $document here is // deliberate. This service depends on the specific behavior of anchor nodes created by the // browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and // cause us to break tests. In addition,when the browser resolves a URL for XHR,it // doesn't know about mocked locations and resolves URLs to the real document - which is
// exactly the behavior needed here.  There is little value is mocking these out for this
// service.
var urlParsingNode = document.createElement("a");
var originUrl = urlResolve(window.location.href);


/**
 *
 * Implementation Notes for non-IE browsers
 * ----------------------------------------
 * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
 * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
 * URL will be resolved into an absolute URL in the context of the application document.
 * Parsing means that the anchor node's host,hostname,protocol,port,pathname and related * properties are all populated to reflect the normalized URL. This approach has wide * compatibility - Safari 1+,Mozilla 1+,Opera 7+,e etc. See * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html * * Implementation Notes for IE * --------------------------- * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other * browsers. However,the parsed components will not be set if the URL assigned did not specify * them. (e.g. if you assign a.href = "foo",then a.protocol,a.host,etc. will be empty.) We * work around that by performing the parsing in a 2nd step by taking a previously normalized * URL (e.g. by assigning to a.href) and assigning it a.href again. This correctly populates the * properties such as protocol,hostname,port,etc. * * IE7 does not normalize the URL when assigned to an anchor node. (Apparently,it does,if one * uses the inner HTML approach to assign the URL as part of an HTML snippet - * http://stackoverflow.com/a/472729) However,setting img[src] does normalize the URL. * Unfortunately,setting img[src] to something like "javascript:foo" on IE throws an exception. * Since the primary usage for normalizing URLs is to sanitize such URLs,we can't use that
 * method and IE < 8 is unsupported.
 *
 * References:
 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
 *   http://url.spec.whatwg.org/#urlutils
 *   https://github.com/angular/angular.js/pull/2902
 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
 *
 * @kind function
 * @param {string} url The URL to be parsed.
 * @description Normalizes and parses a URL.
 * @returns {object} Returns the normalized URL as a dictionary.
 *
 *   | member name   | Description    |
 *   |---------------|----------------|
 *   | href          | A normalized version of the provided URL if it was not an absolute URL |
 *   | protocol      | The protocol including the trailing colon                              |
 *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
 *   | search        | The search params, minus the question mark                             |
 *   | hash          | The hash string, minus the hash symbol
 *   | hostname      | The hostname
 *   | port          | The port, without ":"
 *   | pathname      | The pathname, beginning with "/"
 *
 */
function urlResolve(url) {
  var href = url;

  if (msie) {
    // Normalize before parse.  Refer Implementation Notes on why this is
    // done in two steps on IE.
    urlParsingNode.setAttribute("href", href);
    href = urlParsingNode.href;
  }

  urlParsingNode.setAttribute('href', href);

  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
  return {
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: (urlParsingNode.pathname.charAt(0) === '/')
      ? urlParsingNode.pathname
      : '/' + urlParsingNode.pathname
  };
}

/**
 * Parse a request URL and determine whether this is a same-origin request as the application document.
 *
 * @param {string|object} requestUrl The url of the request as a string that will be resolved
 * or a parsed URL object.
 * @returns {boolean} Whether the request is for the same origin as the application document.
 */
function urlIsSameOrigin(requestUrl) {
  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
  return (parsed.protocol === originUrl.protocol &&
          parsed.host === originUrl.host);
}

/**
 * @ngdoc service
 * @name $window
 *
 * @description
 * A reference to the browser's `window` object. While `window` * is globally available in JavaScript,it causes testability problems,because * it is a global variable. In angular we always refer to it through the * `$window` service,so it may be overridden,removed or mocked for testing. * * Expressions,like the one defined for the `ngClick` directive in the example * below,are evaluated with respect to the current scope. Therefore,there is * no risk of inadvertently coding in a dependency on a global value in such an * expression. * * @example <example module="windowExample"> <file name="index.html"> <script> angular.module('windowExample',[]) .controller('ExampleController',['$scope','$window',function($scope,$window){$scope.greeting = 'Hello, World!'; $scope.doGreeting = function(greeting){:$window.alert(greeting)}}]); </script><div ng-controller="ExampleController"><input type="text" ng-model="greeting" /><button ng-click="doGreeting(greeting)">ALERT</button></div></file><file name="protractor.js" type="protractor">it('should display the greeting in the input box',function(){:element(by.model('greeting')).sendKeys('Hello, E2E Tests');:// If we click the button it will block the test runner // element(':button').click()}); </file></example>*/ function $WindowProvider(){:this.$get = valueFn(window)}$FilterProvider.$inject = ['$provide']; function $FilterProvider($provide){:var suffix = 'Filter';:function register(name,factory) { if(isObject(name)) { var filters = {}; forEach(name,function(filter,key){:filters[key]= register(key,filter)}function($injector),this.register = register; this.$get = ['$injector'{:return function(name) { return $injector.get(name + suffix)}function filterFilter(){:return function(array,expression,comparator) { if(!isArray(array)) return array;:var predicateFn;:var matchAgainstAnyProp;switch(typeof expression) { case 'function':predicateFn = expression;:break;case 'boolean':case 'number':case 'string':matchAgainstAnyProp = true;//jshint -W086 case 'object'://jshint +W086 predicateFn = createPredicateFn(expression,comparator,matchAgainstAnyProp);:break;default:return array}// Helper functions for `filterFilter` function createPredicateFn(expression,comparator,matchAgainstAnyProp){:var shouldMatchPrimitives = isObject(expression) &&('$' in expression);:var predicateFn;:if(comparator === true) { comparator = equals}else if (!isFunction(comparator)){:comparator = function(actual,expected) { if(isObject(actual) || isObject(expected)) { // Prevent an object to be considered equal to a string like `'[object'` return false}predicateFn = function(item){:if(shouldMatchPrimitives && !isObject(item)) { return deepCompare(item,expression.$,comparator,false)}function deepCompare(actual,expected,comparator,matchAgainstAnyProp,dontMatchWholeObject){:var actualType = typeof actual;:var expectedType = typeof expected;:if((expectedType === 'string') &&(expected.charAt(0) === '!')) { return !deepCompare(actual,expected.substring(1),comparator,matchAgainstAnyProp)}else if (isArray(actual)){:// In case `actual` is an array,consider it a match // if ANY of it's items matches `expected`
    return actual.some(function(item) {
      return deepCompare(item, expected, comparator, matchAgainstAnyProp);
    });
  }

  switch (actualType) {
    case 'object':
      var key;
      if (matchAgainstAnyProp) {
        for (key in actual) {
          if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
            return true;
          }
        }
        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
      } else if (expectedType === 'object') {
        for (key in expected) {
          var expectedVal = expected[key];
          if (isFunction(expectedVal)) {
            continue;
          }

          var matchAnyProperty = key === '$';
          var actualVal = matchAnyProperty ? actual : actual[key];
          if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
            return false;
          }
        }
        return true;
      } else {
        return comparator(actual, expected);
      }
      break;
    case 'function':
      return false;
    default:
      return comparator(actual, expected);
  }
}

/**
 * @ngdoc filter
 * @name currency
 * @kind function
 *
 * @description
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
 * symbol for current locale is used.
 *
 * @param {number} amount Input to filter.
 * @param {string=} symbol Currency symbol or identifier to be displayed.
 * @param {number=} fractionSize Number of decimal places to round the amount to, defaults to default max fraction size for current locale
 * @returns {string} Formatted number.
 *
 *
 * @example
   <example module="currencyExample">
     <file name="index.html">
       <script>
         angular.module('currencyExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.amount = 1234.56;
           }]);
       </script>
       <div ng-controller="ExampleController">
         <input type="number" ng-model="amount"> <br>
         default currency symbol ($): <span id="currency-default">{{amount | currency}}</span><br>
         custom currency identifier (USD$): <span id="currency-custom">{{amount | currency:"USD$"}}</span>
         no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
       </div>
     </file>
     <file name="protractor.js" type="protractor">
       it('should init with 1234.56', function() {
         expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');
         expect(element(by.id('currency-custom')).getText()).toBe('USD$1,234.56');
         expect(element(by.id('currency-no-fractions')).getText()).toBe('USD$1,235');
       });
       it('should update', function() {
         if (browser.params.browser == 'safari') {
           // Safari does not understand the minus key. See
           // https://github.com/angular/protractor/issues/481
           return;
         }
         element(by.model('amount')).clear();
         element(by.model('amount')).sendKeys('-1234');
         expect(element(by.id('currency-default')).getText()).toBe('($1,234)');
         expect(element(by.id('currency-custom')).getText()).toBe('(USD$1,234)');
         expect(element(by.id('currency-no-fractions')).getText()).toBe('(USD$1,234)');
       });
     </file>
   </example>
 */
currencyFilter.$inject = ['$locale'];
function currencyFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(amount, currencySymbol, fractionSize) {
    if (isUndefined(currencySymbol)) {
      currencySymbol = formats.CURRENCY_SYM;
    }

    if (isUndefined(fractionSize)) {
      fractionSize = formats.PATTERNS[1].maxFrac;
    }

    // if null or undefined pass it through
    return (amount == null)
        ? amount
        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
            replace(/\u00A4/g, currencySymbol);
  };
}

/**
 * @ngdoc filter
 * @name number
 * @kind function
 *
 * @description
 * Formats a number as text.
 *
 * If the input is not a number an empty string is returned.
 *
 * @param {number|string} number Number to format.
 * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
 * If this is not provided then the fraction size is computed from the current locale's number * formatting pattern. In the case of the default locale,it will be 3 * @returns {string}]); </script><div ng-controller="ExampleController">Enter number: <input ng-model='val'><br>Default formatting: <span id='number-default'>{:{val | number}</span><br>No fractions: <span>{{val | number:0}</span><br>Negative number: <span>{{-val | number:4}</span></div></file><file name="protractor.js" type="protractor">it('should format numbers',function(){:expect(element(by.id('number-default')).getText()).toBe('1,234.568');:expect(element(by.binding('val | number:0')).getText()).toBe('1,235');:expect(element(by.binding('-val | number:4')).getText()).toBe('-1,234.5679')}); it('should update',function(){:element(by.model('val')).clear();:element(by.model('val')).sendKeys('3374.333');:expect(element(by.id('number-default')).getText()).toBe('3,374.333');:expect(element(by.binding('val | number:0')).getText()).toBe('3,374');:expect(element(by.binding('-val | number:4')).getText()).toBe('-3,374.3330')}); </file></example>*/ numberFilter.$inject = ['$locale']; function numberFilter($locale){:var formats = $locale.NUMBER_FORMATS;return function(number,fractionSize) { // if null or undefined pass it through return(number == null) ? number:formatNumber(number,formats.PATTERNS[0],formats.GROUP_SEP,formats.DECIMAL_SEP,fractionSize)}var DECIMAL_SEP = '.'; function formatNumber(number,pattern,groupSep,decimalSep,fractionSize){:if(!isFinite(number) || isObject(number)) return '';:var isNegative = number < 0;:number = Math.abs(number);:var numStr = number + '',formatedText = '',parts =[];:var hasExponent = false;:if(numStr.indexOf('e') !== -1) { var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);:if(match && match[2]== '-' && match[3]> fractionSize + 1) { number = 0}if (!hasExponent){:var fractionLen =(numStr.split(DECIMAL_SEP)[1]|| '').length;:// determine fractionSize if it is not specified if(isUndefined(fractionSize)) { fractionSize = Math.min(Math.max(pattern.minFrac,fractionLen),pattern.maxFrac)}// safely round numbers in JS without hitting imprecisions of floating-point arithmetics // inspired by: // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round number =+(Math.round(+(number.toString()+'e'+fractionSize)).toString()+'e'+-fractionSize); var fraction = (''+number).split(DECIMAL_SEP); var whole = fraction[0]; fraction = fraction[1] || ''; var i,group = pattern.gSize; if (whole.length>= (lgroup+group)),lgroup = pattern.lgSize,pos = 0{:pos = whole.length - lgroup;:for(i = 0;:i < pos;:i++) { if((pos - i) % group === 0 && i !== 0) { formatedText += groupSep}for (i = pos; i < whole.length; i++){:if((whole.length - i) % lgroup === 0 && i !== 0) { formatedText += groupSep}// format fraction part. while (fraction.length < fractionSize){:fraction += '0'}if (number === 0){:isNegative = false}function padNumber(num,digits,trim){:var neg = '';:if(num < 0) { neg = '-';:num = -num}function dateGetter(name,size,offset,trim){:offset = offset || 0;:return function(date) { var value = date['get' + name]();:if(offset > 0 || value > -offset) value += offset;:if(value === 0 && offset == -12) value = 12;:return padNumber(value,size,trim)}function dateStrGetter(name,shortForm){:return function(date,formats) { var value = date['get' + name]();var get = uppercase(shortForm ?('SHORT' + name):name);:return formats[get][value]}function timeZoneGetter(date){:var zone = -1 * date.getTimezoneOffset();var paddedZone =(zone >= 0) ? "+":"";paddedZone += padNumber(Math[zone > 0 ? 'floor':'ceil'](zone / 60),2) + padNumber(Math.abs(zone % 60),2);:return paddedZone}function getFirstThursdayOfYear(year){:// 0 = index of January var dayOfWeekOnFirst =(new Date(year,0,1)).getDay();// 4 = index of Thursday(+1 to account for 1st = 5) // 11 = index of *next* Thursday(+1 account for 1st = 12) return new Date(year,0((dayOfWeekOnFirst <= 4) ? 5:12) - dayOfWeekOnFirst)}function getThursdayThisWeek(datetime){:return new Date(datetime.getFullYear(),datetime.getMonth(),// 4 = index of Thursday datetime.getDate() + (4 - datetime.getDay()))}function weekGetter(size){:return function(date) { var firstThurs = getFirstThursdayOfYear(date.getFullYear()),thisThurs = getThursdayThisWeek(date);:var diff = +thisThurs - +firstThurs,result = 1 + Math.round(diff / 6.048e8);:// 6.048e8 ms per week return padNumber(result,size)}function ampmGetter(date,formats){return date.getHours() < 12 ? formats.AMPMS[0:formats.AMPMS[1]}var DATE_FORMATS ={yyyy:dateGetter('FullYear',4),yy:dateGetter('FullYear',2,0,true),y:dateGetter('FullYear',1),MMMM:dateStrGetter('Month'),MMM:dateStrGetter('Month',true),MM:dateGetter('Month',2,1),M:dateGetter('Month',1,1),dd:dateGetter('Date',2),d:dateGetter('Date',1),HH:dateGetter('Hours',2),H:dateGetter('Hours',1),hh:dateGetter('Hours',2,-12),h:dateGetter('Hours',1,-12),mm:dateGetter('Minutes',2),m:dateGetter('Minutes',1),ss:dateGetter('Seconds',2),s:dateGetter('Seconds',1),// while ISO 8601 requires fractions to be prefixed with `.` or `,` // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
   sss: dateGetter('Milliseconds', 3),
  EEEE: dateStrGetter('Day'),
   EEE: dateStrGetter('Day', true),
     a: ampmGetter,
     Z: timeZoneGetter,
    ww: weekGetter(2),
     w: weekGetter(1)
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;

/**
 * @ngdoc filter
 * @name date
 * @kind function
 *
 * @description
 *   Formats `date` to a string based on the requested `format`.
 *
 *   `format` string can be composed of the following elements:
 *
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
 *   * `'MMMM'`: Month in year (January-December)
 *   * `'MMM'`: Month in year (Jan-Dec)
 *   * `'MM'`: Month in year, padded (01-12)
 *   * `'M'`: Month in year (1-12)
 *   * `'dd'`: Day in month, padded (01-31)
 *   * `'d'`: Day in month (1-31)
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
 *   * `'EEE'`: Day in Week, (Sun-Sat)
 *   * `'HH'`: Hour in day, padded (00-23)
 *   * `'H'`: Hour in day (0-23)
 *   * `'hh'`: Hour in AM/PM, padded (01-12)
 *   * `'h'`: Hour in AM/PM, (1-12)
 *   * `'mm'`: Minute in hour, padded (00-59)
 *   * `'m'`: Minute in hour (0-59)
 *   * `'ss'`: Second in minute, padded (00-59)
 *   * `'s'`: Second in minute (0-59)
 *   * `'sss'`: Millisecond in second, padded (000-999)
 *   * `'a'`: AM/PM marker
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
 *   * `'ww'`: Week of year, padded (00-53). Week 01 is the week with the first Thursday of the year
 *   * `'w'`: Week of year (0-53). Week 1 is the week with the first Thursday of the year
 *
 *   `format` string can also be one of the following predefined
 *   {@link guide/i18n localizable formats}:
 *
 *   * `'medium'`: equivalent to `'MMM d,y h:mm:ss a'` for en_US locale
 *     (e.g. Sep 3, 2010 12:05:08 PM)
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 PM)
 *   * `'fullDate'`: equivalent to `'EEEE,MMMM d,y'` for en_US  locale
 *     (e.g. Friday, September 3, 2010)
 *   * `'longDate'`: equivalent to `'MMMM d,y'` for en_US  locale (e.g. September 3, 2010)
 *   * `'mediumDate'`: equivalent to `'MMM d,y'` for en_US  locale (e.g. Sep 3, 2010)
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 PM)
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 PM)
 *
 *   `format` string can contain literal values. These need to be escaped by surrounding with single quotes (e.g.
 *   `"h 'in the morning'"`). In order to output a single quote, escape it - i.e., two single quotes in a sequence
 *   (e.g. `"h 'o''clock'"`).
 *
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.sssZ and its
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
 *    specified in the string input, the time is considered to be in the local timezone.
 * @param {string=} format Formatting rules (see Description). If not specified,
 *    `mediumDate` is used.
 * @param {string=} timezone Timezone to be used for formatting. Right now, only `'UTC'` is supported.
 *    If not specified, the timezone of the browser will be used.
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
 *
 * @example
   <example>
     <file name="index.html">
       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
           <span>{{1288323623006 | date:'medium'}}</span><br>
       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
          <span>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span><br>
       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
          <span>{{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}</span><br>
       <span ng-non-bindable>{{1288323623006 | date:"MM/dd/yyyy 'at' h:mma"}}</span>:
          <span>{{'1288323623006' | date:"MM/dd/yyyy 'at' h:mma"}}</span><br>
     </file>
     <file name="protractor.js" type="protractor">
       it('should format date', function() {
         expect(element(by.binding("1288323623006 | date:'medium'")).getText()).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(element(by.binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).getText()).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(element(by.binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).getText()).
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
         expect(element(by.binding("'1288323623006' | date:\"MM/dd/yyyy 'at' h:mma\"")).getText()).
            toMatch(/10\/2\d\/2010 at \d{1,2}:\d{2}(AM|PM)/);
       });
     </file>
   </example>
 */
dateFilter.$inject = ['$locale'];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4] || 0) - tzHour;
      var m = int(match[5] || 0) - tzMin;
      var s = int(match[6] || 0);
      var ms = Math.round(parseFloat('0' + (match[7] || 0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format, timezone) {
    var text = '',
        parts = [],
        fn, match;

    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while (format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    if (timezone && timezone === 'UTC') {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    }
    forEach(parts, function(value) {
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
    });

    return text;
  };
}


/**
 * @ngdoc filter
 * @name json
 * @kind function
 *
 * @description
 *   Allows you to convert a JavaScript object into JSON string.
 *
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
 *   the binding is automatically converted to JSON.
 *
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
 * @param {number=} spacing The number of spaces to use per indentation, defaults to 2.
 * @returns {string} JSON string.
 *
 *
 * @example
   <example>
     <file name="index.html">
       <pre id="default-spacing">{{ {'name':'value'} | json }}</pre>
       <pre id="custom-spacing">{{ {'name':'value'} | json:4 }}</pre>
     </file>
     <file name="protractor.js" type="protractor">
       it('should jsonify filtered objects', function() {
         expect(element(by.id('default-spacing')).getText()).toMatch(/\{\n  "name": ?"value"\n}/);
         expect(element(by.id('custom-spacing')).getText()).toMatch(/\{\n    "name": ?"value"\n}/);
       });
     </file>
   </example>
 *
 */
function jsonFilter() {
  return function(object, spacing) {
    if (isUndefined(spacing)) {
        spacing = 2;
    }
    return toJson(object, spacing);
  };
}


/**
 * @ngdoc filter
 * @name lowercase
 * @kind function
 * @description
 * Converts string to lowercase.
 * @see angular.lowercase
 */
var lowercaseFilter = valueFn(lowercase);


/**
 * @ngdoc filter
 * @name uppercase
 * @kind function
 * @description
 * Converts string to uppercase.
 * @see angular.uppercase
 */
var uppercaseFilter = valueFn(uppercase);

/**
 * @ngdoc filter
 * @name limitTo
 * @kind function
 *
 * @description
 * Creates a new array or string containing only a specified number of elements. The elements
 * are taken from either the beginning or the end of the source array, string or number, as specified by
 * the value and sign (positive or negative) of `limit`. If a number is used as input, it is
 * converted to a string.
 *
 * @param {Array|string|number} input Source array, string or number to be limited.
 * @param {string|number} limit The length of the returned array or string. If the `limit` number
 *     is positive, `limit` number of items from the beginning of the source array/string are copied.
 *     If the number is negative, `limit` number  of items from the end of the source array/string
 *     are copied. The `limit` will be trimmed if it exceeds `array.length`
 * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
 *     had less than `limit` elements.
 *
 * @example
   <example module="limitToExample">
     <file name="index.html">
       <script>
         angular.module('limitToExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.numbers = [1,2,3,4,5,6,7,8,9];
             $scope.letters = "abcdefghi";
             $scope.longNumber = 2345432342;
             $scope.numLimit = 3;
             $scope.letterLimit = 3;
             $scope.longNumberLimit = 3;
           }]);
       </script>
       <div ng-controller="ExampleController">
         Limit {{numbers}} to: <input type="number" step="1" ng-model="numLimit">
         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
         Limit {{letters}} to: <input type="number" step="1" ng-model="letterLimit">
         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
         Limit {{longNumber}} to: <input type="number" step="1" ng-model="longNumberLimit">
         <p>Output long number: {{ longNumber | limitTo:longNumberLimit }}</p>
       </div>
     </file>
     <file name="protractor.js" type="protractor">
       var numLimitInput = element(by.model('numLimit'));
       var letterLimitInput = element(by.model('letterLimit'));
       var longNumberLimitInput = element(by.model('longNumberLimit'));
       var limitedNumbers = element(by.binding('numbers | limitTo:numLimit'));
       var limitedLetters = element(by.binding('letters | limitTo:letterLimit'));
       var limitedLongNumber = element(by.binding('longNumber | limitTo:longNumberLimit'));

       it('should limit the number array to first three items', function() {
         expect(numLimitInput.getAttribute('value')).toBe('3');
         expect(letterLimitInput.getAttribute('value')).toBe('3');
         expect(longNumberLimitInput.getAttribute('value')).toBe('3');
         expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3]');
         expect(limitedLetters.getText()).toEqual('Output letters: abc');
         expect(limitedLongNumber.getText()).toEqual('Output long number: 234');
       });

       // There is a bug in safari and protractor that doesn't like the minus key
       // it('should update the output when -3 is entered', function() {
       //   numLimitInput.clear();
       //   numLimitInput.sendKeys('-3');
       //   letterLimitInput.clear();
       //   letterLimitInput.sendKeys('-3');
       //   longNumberLimitInput.clear();
       //   longNumberLimitInput.sendKeys('-3');
       //   expect(limitedNumbers.getText()).toEqual('Output numbers: [7,8,9]');
       //   expect(limitedLetters.getText()).toEqual('Output letters: ghi');
       //   expect(limitedLongNumber.getText()).toEqual('Output long number: 342');
       // });

       it('should not exceed the maximum size of input array', function() {
         numLimitInput.clear();
         numLimitInput.sendKeys('100');
         letterLimitInput.clear();
         letterLimitInput.sendKeys('100');
         longNumberLimitInput.clear();
         longNumberLimitInput.sendKeys('100');
         expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3,4,5,6,7,8,9]');
         expect(limitedLetters.getText()).toEqual('Output letters: abcdefghi');
         expect(limitedLongNumber.getText()).toEqual('Output long number: 2345432342');
       });
     </file>
   </example>
*/
function limitToFilter() {
  return function(input, limit) {
    if (isNumber(input)) input = input.toString();
    if (!isArray(input) && !isString(input)) return input;

    if (Math.abs(Number(limit)) === Infinity) {
      limit = Number(limit);
    } else {
      limit = int(limit);
    }

    //NaN check on limit
    if (limit) {
      return limit > 0 ? input.slice(0, limit) : input.slice(limit);
    } else {
      return isString(input) ? "" : [];
    }
  };
}

/**
 * @ngdoc filter
 * @name orderBy
 * @kind function
 *
 * @description
 * Orders a specified `array` by the `expression` predicate. It is ordered alphabetically
 * for strings and numerically for numbers. Note: if you notice numbers are not being sorted
 * correctly, make sure they are actually being saved as numbers and not strings.
 *
 * @param {Array} array The array to sort.
 * @param {function(*)|string|Array.<(function(*)|string)>=} expression A predicate to be
 *    used by the comparator to determine the order of elements.
 *
 *    Can be one of:
 *
 *    - `function`: Getter function. The result of this function will be sorted using the
 *      `<`, `=`, `>` operator.
 *    - `string`: An Angular expression. The result of this expression is used to compare elements
 *      (for example `name` to sort by a property called `name` or `name.substr(0, 3)` to sort by
 *      3 first characters of a property called `name`). The result of a constant expression
 *      is interpreted as a property name to be used in comparisons (for example `"special name"`
 *      to sort object by the value of their `special name` property). An expression can be
 *      optionally prefixed with `+` or `-` to control ascending or descending sort order
 *      (for example, `+name` or `-name`). If no property is provided, (e.g. `'+'`) then the array
 *      element itself is used to compare where sorting.
 *    - `Array`: An array of function or string predicates. The first predicate in the array
 *      is used for sorting, but when two items are equivalent, the next predicate is used.
 *
 *    If the predicate is missing or empty then it defaults to `'+'`.
 *
 * @param {boolean=} reverse Reverse the order of the array.
 * @returns {Array} Sorted copy of the source array.
 *
 * @example
   <example module="orderByExample">
     <file name="index.html">
       <script>
         angular.module('orderByExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.friends =
                 [{name:'John', phone:'555-1212', age:10},
                  {name:'Mary', phone:'555-9876', age:19},
                  {name:'Mike', phone:'555-4321', age:21},
                  {name:'Adam', phone:'555-5678', age:35},
                  {name:'Julie', phone:'555-8765', age:29}];
             $scope.predicate = '-age';
           }]);
       </script>
       <div ng-controller="ExampleController">
         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
         <hr/>
         [ <a href="" ng-click="predicate=''">unsorted</a> ]
         <table class="friend">
           <tr>
             <th><a href="" ng-click="predicate = 'name';:reverse=false">Name</a>
                 (<a href="" ng-click="predicate = '-name';:reverse=false">^</a>)</th>
             <th><a href="" ng-click="predicate = 'phone';:reverse=!reverse">Phone Number</a></th>
             <th><a href="" ng-click="predicate = 'age';reverse=!reverse">Age</a></th>
           </tr>
           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
             <td>{{friend.name}}</td>
             <td>{{friend.phone}}</td>
             <td>{{friend.age}}</td>
           </tr>
         </table>
       </div>
     </file>
   </example>
 *
 * It's also possible to call the orderBy filter manually, by injecting `$filter`, retrieving the
 * filter routine with `$filter('orderBy')`, and calling the returned filter routine with the
 * desired parameters.
 *
 * Example:
 *
 * @example
  <example module="orderByExample">
    <file name="index.html">
      <div ng-controller="ExampleController">
        <table class="friend">
          <tr>
            <th><a href="" ng-click="reverse=false;:order('name',false)">Name</a>
              (<a href="" ng-click="order('-name',false)">^</a>)</th>
            <th><a href="" ng-click="reverse=!reverse;:order('phone',reverse)">Phone Number</a></th>
            <th><a href="" ng-click="reverse=!reverse;order('age',reverse)">Age</a></th>
          </tr>
          <tr ng-repeat="friend in friends">
            <td>{{friend.name}}</td>
            <td>{{friend.phone}}</td>
            <td>{{friend.age}}</td>
          </tr>
        </table>
      </div>
    </file>

    <file name="script.js">
      angular.module('orderByExample', [])
        .controller('ExampleController', ['$scope', '$filter', function($scope, $filter) {
          var orderBy = $filter('orderBy');
          $scope.friends = [
            { name: 'John',    phone: '555-1212',    age: 10 },
            { name: 'Mary',    phone: '555-9876',    age: 19 },
            { name: 'Mike',    phone: '555-4321',    age: 21 },
            { name: 'Adam',    phone: '555-5678',    age: 35 },
            { name: 'Julie',   phone: '555-8765',    age: 29 }
          ];
          $scope.order = function(predicate, reverse) {
            $scope.friends = orderBy($scope.friends, predicate, reverse);
          };
          $scope.order('-age',false);
        }]);
    </file>
</example>
 */
orderByFilter.$inject = ['$parse'];
function orderByFilter($parse) {
  return function(array, sortPredicate, reverseOrder) {
    if (!(isArrayLike(array))) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
    if (sortPredicate.length === 0) { sortPredicate = ['+']; }
    sortPredicate = sortPredicate.map(function(predicate) {
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
          descending = predicate.charAt(0) == '-';
          predicate = predicate.substring(1);
        }
        if (predicate === '') {
          // Effectively no predicate was passed so we compare identity
          return reverseComparator(compare, descending);
        }
        get = $parse(predicate);
        if (get.constant) {
          var key = get();
          return reverseComparator(function(a, b) {
            return compare(a[key], b[key]);
          }, descending);
        }
      }
      return reverseComparator(function(a, b) {
        return compare(get(a),get(b));
      }, descending);
    });
    return slice.call(array).sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2) {
      for (var i = 0; i < sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return descending
          ? function(a, b) {return comp(b,a);}
          : comp;
    }

    function isPrimitive(value) {
      switch (typeof value) {
        case 'number': /* falls through */
        case 'boolean': /* falls through */
        case 'string':
          return true;
        default:
          return false;
      }
    }

    function objectToString(value) {
      if (value === null) return 'null';
      if (typeof value.valueOf === 'function') {
        value = value.valueOf();
        if (isPrimitive(value)) return value;
      }
      if (typeof value.toString === 'function') {
        value = value.toString();
        if (isPrimitive(value)) return value;
      }
      return '';
    }

    function compare(v1, v2) {
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 === t2 && t1 === "object") {
        v1 = objectToString(v1);
        v2 = objectToString(v2);
      }
      if (t1 === t2) {
        if (t1 === "string") {
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        }
        if (v1 === v2) return 0;
        return v1 < v2 ? -1 : 1;
      } else {
        return t1 < t2 ? -1 : 1;
      }
    }
  };
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    };
  }
  directive.restrict = directive.restrict || 'AC';
  return valueFn(directive);
}

/**
 * @ngdoc directive
 * @name a
 * @restrict E
 *
 * @description
 * Modifies the default behavior of the html A tag so that the default action is prevented when
 * the href attribute is empty.
 *
 * This change permits the easy creation of action links with the `ngClick` directive
 * without changing the location or causing page reloads, e.g.:
 * `<a href="" ng-click="list.addItem()">Add Item</a>`
 */
var htmlAnchorDirective = valueFn({
  restrict: 'E',
  compile: function(element, attr) {
    if (!attr.href && !attr.xlinkHref && !attr.name) {
      return function(scope, element) {
        // If the linked element is not an anchor tag anymore, do nothing
        if (element[0].nodeName.toLowerCase() !== 'a') return;

        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
                   'xlink:href' : 'href';
        element.on('click', function(event) {
          // if we have no href url, then don't navigate anywhere.
          if (!element.attr(href)) {
            event.preventDefault();
          }
        });
      };
    }
  }
});

/**
 * @ngdoc directive
 * @name ngHref
 * @restrict A
 * @priority 99
 *
 * @description
 * Using Angular markup like `{{hash}}` in an href attribute will
 * make the link go to the wrong URL if the user clicks it before
 * Angular has a chance to replace the `{{hash}}` markup with its
 * value. Until Angular replaces the markup the link will be broken
 * and will most likely return a 404 error. The `ngHref` directive
 * solves this problem.
 *
 * The wrong way to write it:
 * ```html
 * <a href="http://www.gravatar.com/avatar/{{hash}index.html">
        <input ng-model="value" /><br />
        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
        <a id="link-3" ng-href="/{:{'123'}link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
        <a id="link-6" ng-href="{:{value}2x"/>
 * ```
 *
 * The correct way to write it:
 * ```html
 * <img ng-srcset="http://www.gravatar.com/avatar/,http://www.gravatar.com/avatar/,protractor.js" type="protractor">
        it('should execute ng-click but not reload when href without value', function() {
          element(by.id('link-1')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('1');
          expect(element(by.id('link-1')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click but not reload when href empty string', function() {
          element(by.id('link-2')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('2');
          expect(element(by.id('link-2')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click and change url when ng-href specified', function() {
          expect(element(by.id('link-3')).getAttribute('href')).toMatch(/\/123$/);

          element(by.id('link-3')).click();

          // At this point, we navigate away from an Angular page, so we need
          // to use browser.driver to get the base webdriver.

          browser.wait(function() {
            return browser.driver.getCurrentUrl().then(function(url) {
              return url.match(/\/123$/);
            });
          }, 5000, 'page should navigate to /123');
        });

        xit('should execute ng-click but not reload when href empty string and name specified', function() {
          element(by.id('link-4')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('4');
          expect(element(by.id('link-4')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click but not reload when no href but name specified', function() {
          element(by.id('link-5')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('5');
          expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
        });

        it('should only change url when only ng-href', function() {
          element(by.model('value')).clear();
          element(by.model('value')).sendKeys('6');
          expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);

          element(by.id('link-6')).click();

          // At this point, we navigate away from an Angular page, so we need
          // to use browser.driver to get the base webdriver.
          browser.wait(function() {
            return browser.driver.getCurrentUrl().then(function(url) {
              return url.match(/\/6$/);
            });
          }, 5000, 'page should navigate to /6');
        });
      </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name ngSrc
 * @restrict A
 * @priority 99
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrc` directive solves this problem.
 *
 * The buggy way to write it:
 * ```html
 * <img src="http://www.gravatar.com/avatar/{:{hash}2x"/>
 * ```
 *
 * @element IMG
 * @param {template} ngSrcset any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ngDisabled
 * @restrict A
 * @priority 100
 *
 * @description
 *
 * We shouldn't do this, because it will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
 * ```html
 * <div ng-init="scope ={isDisabled:false}{:{scope.isDisabled}index.html">
        Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
        <button ng-model="button" ng-disabled="checked">Button</button>
      </file>
      <file name="protractor.js" type="protractor">
        it('should toggle button', function() {
          expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
          element(by.model('checked')).click();
          expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();
        });
      </file>
    </example>
 *
 * @element INPUT
 * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy,
 *     then special attribute "disabled" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ngChecked
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as checked. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngChecked` directive solves this problem for the `checked` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
    <example>
      <file name="index.html">
        Check me to check both: <input type="checkbox" ng-model="master"><br/>
        <input id="checkSlave" type="checkbox" ng-checked="master">
      </file>
      <file name="protractor.js" type="protractor">
        it('should check both checkBoxes', function() {
          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
          element(by.model('master')).click();
          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy();
        });
      </file>
    </example>
 *
 * @element INPUT
 * @param {expression} ngChecked If the {@link guide/expression expression} is truthy,
 *     then special attribute "checked" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ngReadonly
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as readonly. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngReadonly` directive solves this problem for the `readonly` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
    <example>
      <file name="index.html">
        Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
        <input type="text" ng-readonly="checked" value="I'm Angular"/>
      </file>
      <file name="protractor.js" type="protractor">
        it('should toggle readonly attr', function() {
          expect(element(by.css('[type=text]')).getAttribute('readonly')).toBeFalsy();
          element(by.model('checked')).click();
          expect(element(by.css('[type=text]')).getAttribute('readonly')).toBeTruthy();
        });
      </file>
    </example>
 *
 * @element INPUT
 * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy,
 *     then special attribute "readonly" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ngSelected
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as selected. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngSelected` directive solves this problem for the `selected` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 *
 * @example
    <example>
      <file name="index.html">
        Check me to select: <input type="checkbox" ng-model="selected"><br/>
        <select>
          <option>Hello!</option>
          <option id="greet" ng-selected="selected">Greetings!</option>
        </select>
      </file>
      <file name="protractor.js" type="protractor">
        it('should select Greetings!', function() {
          expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
          element(by.model('selected')).click();
          expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();
        });
      </file>
    </example>
 *
 * @element OPTION
 * @param {expression} ngSelected If the {@link guide/expression expression} is truthy,
 *     then special attribute "selected" will be set on the element
 */

/**
 * @ngdoc directive
 * @name ngOpen
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as open. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngOpen` directive solves this problem for the `open` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
     <example>
       <file name="index.html">
         Check me check multiple: <input type="checkbox" ng-model="open"><br/>
         <details id="details" ng-open="open">
            <summary>Show/Hide me</summary>
         </details>
       </file>
       <file name="protractor.js" type="protractor">
         it('should toggle open', function() {
           expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
           element(by.model('open')).click();
           expect(element(by.id('details')).getAttribute('open')).toBeTruthy();
         });
       </file>
     </example>
 *
 * @element DETAILS
 * @param {expression} ngOpen If the {@link guide/expression expression} is truthy,
 *     then special attribute "open" will be set on the element
 */

var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  // binding to multiple is not supported
  if (propName == "multiple") return;

  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      restrict: 'A',
      priority: 100,
      link: function(scope, element, attr) {
        scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
          attr.$set(attrName, !!value);
        });
      }
    };
  };
});

// aliased input attrs are evaluated
forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
  ngAttributeAliasDirectives[ngAttr] = function() {
    return {
      priority: 100,
      link: function(scope, element, attr) {
        //special case ngPattern when a literal regular expression value
        //is used as the expression (this way we don't have to watch anything). if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/"){:var match = attr.ngPattern.match(REGEX_STRING_REGEXP);:if(match) { attr.$set("ngPattern",new RegExp(match[1],match[2]));:return}scope.$watch(attr[ngAttr],function ngAttrAliasWatchAction(value){:attr.$set(ngAttr,value)}); // ng-src,ng-href are interpolated forEach(['src','srcset','href'],function(attrName),ng-srcset{:var normalized = directiveNormalize('ng-' + attrName);ngAttributeAliasDirectives[normalized]= function() { return { priority:99,// it needs to run after the attributes are interpolated link:function(scope,element,attr) { var propName = attrName,name = attrName;:if(attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') { name = 'xlinkHref';:attr.$attr[name]= 'xlink:href';:propName = null}attr.$observe(normalized,function(value){:if(!value) { if(attrName === 'href') { attr.$set(name,null)}); var nullFormCtrl ={$addControl:noop,$$renameControl:nullFormRenameControl,$removeControl:noop,$setValidity:noop,$setDirty:noop,$setPristine:noop,$setSubmitted:noop},SUBMITTED_CLASS = 'ng-submitted'; function nullFormRenameControl(control,name){:control.$name = name}//asks for $scope to fool the BC controller module FormController.$inject = ['$element','$attrs''$animate''$interpolate'] function FormController(element,attrs,$scope,$animate,$interpolate)'$scope'{:var form = this,controls =[];:var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;:// init state form.$error = {}; form.$pending = undefined; form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope); form.$dirty = false; form.$pristine = true; form.$valid = true; form.$invalid = false; form.$submitted = false; parentForm.$addControl(form); form.$rollbackViewValue = function(){:forEach(controls,function(control) { control.$rollbackViewValue()}; form.$commitViewValue = function(){:forEach(controls,function(control) { control.$commitViewValue()}; form.$addControl = function(control){:// Breaking change - before,inputs whose name was "hasOwnProperty" were quietly ignored // and not added to the scope. Now we throw an error. assertNotHasOwnProperty(control.$name,'input');:controls.push(control);:if(control.$name) { form[control.$name]= control}; // Private API: rename a form control form.$$renameControl = function(control,newName){:var oldName = control.$name;:if(form[oldName]=== control) { delete form[oldName]}; form.$removeControl = function(control){:if(control.$name && form[control.$name]=== control) { delete form[control.$name]}); forEach(form.$$success,function(value,name),); forEach(form.$error,function(value,name),forEach(form.$pending,function(value,name){:form.$setValidity(name,null,control)}; addSetValidityMethod({ctrl:this,$element:element,set:function(object,property,controller) { var list = object[property];:if(!list) { object[property]=[controller]},unset: function(object,property,controller){:var list = object[property];:if(!list) { return}arrayRemove(list,controller); if (list.length === 0){:delete object[property]}); form.$setDirty = function(){:$animate.removeClass(element,PRISTINE_CLASS);:$animate.addClass(element,DIRTY_CLASS);:form.$dirty = true;:form.$pristine = false;:parentForm.$setDirty()}; form.$setPristine = function(){:$animate.setClass(element,PRISTINE_CLASS,DIRTY_CLASS + ' ' + SUBMITTED_CLASS);:form.$dirty = false;:form.$pristine = true;:form.$submitted = false;:forEach(controls,function(control) { control.$setPristine()}; form.$setUntouched = function(){:forEach(controls,function(control) { control.$setUntouched()}; form.$setSubmitted = function(){:$animate.addClass(element,SUBMITTED_CLASS);:form.$submitted = true;:parentForm.$setSubmitted()}var formDirectiveFactory = function(isNgForm){return['$timeout',function($timeout) { var formDirective = { name:'form',restrict:isNgForm ? 'EAC':'E',controller:FormController,compile:function ngFormCompile(formElement) { // Setup initial state of the control formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);return { pre:function ngFormPreLink(scope,formElement,attr,controller) { // if `action` attr is not present on the form,prevent the default action(submission) if(!('action' in attr)) { // we can't use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn't fire a submit event and try to do a full // page reload if the form was destroyed by submission of the form via a click handler // on a button in the form. Looks like an IE9 specific bug. var handleFormSubmission = function(event) { scope.$apply(function() { controller.$commitViewValue();:controller.$setSubmitted()}; addEventListenerFn(formElement[0],'submit',handleFormSubmission); // unregister the preventDefault listener so that we don't not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.on('$destroy', function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                }, 0, false);
              });
            }

            var parentFormCtrl = controller.$$parentForm,
                alias = controller.$name;

            if (alias) {
              setter(scope, null, alias, controller, alias);
              attr.$observe(attr.name ? 'name' : 'ngForm', function(newValue) {
                if (alias === newValue) return;
                setter(scope, null, alias, undefined, alias);
                alias = newValue;
                setter(scope, null, alias, controller, alias);
                parentFormCtrl.$$renameControl(controller, alias);
              });
            }
            formElement.on('$destroy', function() {
              parentFormCtrl.$removeControl(controller);
              if (alias) {
                setter(scope, null, alias, undefined, alias);
              }
              extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
            });
          }
        };
      }
    };

    return formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);

/* global VALID_CLASS: false,
  INVALID_CLASS: false,
  PRISTINE_CLASS: false,
  DIRTY_CLASS: false,
  UNTOUCHED_CLASS: false,
  TOUCHED_CLASS: false,
  $ngModelMinErr: false,
*/

// Regex code is obtained from SO: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231
var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{:|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/; var DATE_REGEXP = /^(\d{:4})-(\d{:2})$/; var DATETIMELOCAL_REGEXP = /^(\d{:4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{:1,3})-W(\d\d)$/; var MONTH_REGEXP = /^(\d,)?)?$/; var WEEK_REGEXP = /^(\d{:4})-(\d\d)$/; var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{:1,3})?)?$/; var inputType ={'text':textInputType,'date':createDateInputType('date',DATE_REGEXP,createDateParser(DATE_REGEXP['yyyy','MM','dd']),'yyyy-MM-dd'),'datetime-local':createDateInputType('datetimelocal',DATETIMELOCAL_REGEXP,createDateParser(DATETIMELOCAL_REGEXP['yyyy','MM','dd','HH','mm','ss','sss']),'yyyy-MM-ddTHH:mm:ss.sss'),'time':createDateInputType('time',TIME_REGEXP,createDateParser(TIME_REGEXP['HH','mm','ss','sss']),'HH:mm:ss.sss'),'week':createDateInputType('week',WEEK_REGEXP,weekParser,'yyyy-Www'),'month':createDateInputType('month',MONTH_REGEXP,createDateParser(MONTH_REGEXP['yyyy','MM']),'yyyy-MM'),'number':numberInputType,'url':urlInputType,'email':emailInputType,'radio':radioInputType,'checkbox':checkboxInputType,'hidden':noop,'button':noop,'submit':noop,'reset':noop,'file':noop}; function stringBasedInputType(ctrl){ctrl.$formatters.push(function(value) { return ctrl.$isEmpty(value) ? value:value.toString()}function textInputType(scope,element,attr,ctrl,$sniffer,$browser){:baseInputType(scope,element,attr,ctrl,$sniffer,$browser);:stringBasedInputType(ctrl)}function baseInputType(scope,element,attr,ctrl,$sniffer,$browser){:var type = lowercase(element[0].type);// In composition mode,users are still inputing intermediate text buffer,// hold the listener until composition is done. // More about composition events:https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent if(!$sniffer.android) { var composing = false;:element.on('compositionstart',function(data) { composing = true}); element.on('compositionend',function(){:composing = false;:listener()}var listener = function(ev){:if(timeout) { $browser.defer.cancel(timeout);:timeout = null}event = ev && ev.type; // By default we will trim the value // If the attribute ng-trim exists we will avoid trimming // If input type is 'password',if (composing) return; var value = element.val(),the value is never trimmed if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')){:value = trim(value)}// If a control is suffering from bad input (due to native validators),browsers discard its // value,delete or cut if ($sniffer.hasEvent('input')),so it may be necessary to revalidate (by calling $setViewValue again) even if the // control's value is the same empty value twice in a row.
    if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
      ctrl.$setViewValue(value, event);
    }
  };

  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the // input event on backspace{:element.on('input',listener)}; element.on('keydown',function(event){:var key = event.keyCode;:// ignore // command modifiers arrows if(key === 91 ||(15 < key && key < 19) ||(37 <= key && key <= 40)) return;:deferListener(event,this,this.value)}); // if user modifies input value using context menu in IE,we need "paste" and "cut" events to catch it if ($sniffer.hasEvent('paste')){:element.on('paste cut',deferListener)}// if user paste into input using mouse on older browser // or form autocomplete on newer browser,we need "change" event to catch it element.on('change',listener); ctrl.$render = function(){element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '':ctrl.$viewValue)}function weekParser(isoWeek,existingDate){:if(isDate(isoWeek)) { return isoWeek}if (isString(isoWeek)){:WEEK_REGEXP.lastIndex = 0;:var parts = WEEK_REGEXP.exec(isoWeek);:if(parts) { var year = +parts[1],week = +parts[2],hours = 0,minutes = 0,seconds = 0,milliseconds = 0,firstThurs = getFirstThursdayOfYear(year),addDays =(week - 1) * 7;:if(existingDate) { hours = existingDate.getHours();:minutes = existingDate.getMinutes();:seconds = existingDate.getSeconds();:milliseconds = existingDate.getMilliseconds()}function createDateParser(regexp,mapping){:return function(iso,date) { var parts,map;:if(isDate(iso)) { return iso}if (isString(iso)){:// When a date is JSON'ified to wraps itself inside of an extra
      // set of double quotes. This makes the date parsing code unable
      // to match the date string and parse it as a date.
      if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
        iso = iso.substring(1, iso.length - 1);
      }
      if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
      }
      regexp.lastIndex = 0;
      parts = regexp.exec(iso);

      if (parts) {
        parts.shift();
        if (date) {
          map = {
            yyyy: date.getFullYear(),
            MM: date.getMonth() + 1,
            dd: date.getDate(),
            HH: date.getHours(),
            mm: date.getMinutes(),
            ss: date.getSeconds(),
            sss: date.getMilliseconds() / 1000
          };
        } else {
          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
        }

        forEach(parts, function(part, index) {
          if (index < mapping.length) {
            map[mapping[index]] = +part;
          }
        });
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
      }
    }

    return NaN;
  };
}

function createDateInputType(type, regexp, parseDate, format) {
  return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
    var previousDate;

    ctrl.$$parserName = type;
    ctrl.$parsers.push(function(value) {
      if (ctrl.$isEmpty(value)) return null;
      if (regexp.test(value)) {
        // Note: We cannot read ctrl.$modelValue, as there might be a different
        // parser/formatter in the processing chain so that the model
        // contains some different data format!
        var parsedDate = parseDate(value, previousDate);
        if (timezone === 'UTC') {
          parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
        }
        return parsedDate;
      }
      return undefined;
    });

    ctrl.$formatters.push(function(value) {
      if (value && !isDate(value)) {
        throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
      }
      if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone === 'UTC') {
          var timezoneOffset = 60000 * previousDate.getTimezoneOffset();
          previousDate = new Date(previousDate.getTime() + timezoneOffset);
        }
        return $filter('date')(value, format, timezone);
      } else {
        previousDate = null;
        return '';
      }
    });

    if (isDefined(attr.min) || attr.ngMin) {
      var minVal;
      ctrl.$validators.min = function(value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
      };
      attr.$observe('min', function(val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
      });
    }

    if (isDefined(attr.max) || attr.ngMax) {
      var maxVal;
      ctrl.$validators.max = function(value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
      };
      attr.$observe('max', function(val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
      });
    }

    function isValidDate(value) {
      // Invalid Date: getTime() returns NaN
      return value && !(value.getTime && value.getTime() !== value.getTime());
    }

    function parseObservedDateValue(val) {
      return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
    }
  };
}

function badInputChecker(scope, element, attr, ctrl) {
  var node = element[0];
  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
  if (nativeValidation) {
    ctrl.$parsers.push(function(value) {
      var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
      // Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):
      // - also sets validity.badInput (should only be validity.typeMismatch).
      // - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)
      // - can ignore this case as we can still read out the erroneous email...
      return validity.badInput && !validity.typeMismatch ? undefined : value;
    });
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  badInputChecker(scope, element, attr, ctrl);
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$$parserName = 'number';
  ctrl.$parsers.push(function(value) {
    if (ctrl.$isEmpty(value))      return null;
    if (NUMBER_REGEXP.test(value)) return parseFloat(value);
    return undefined;
  });

  ctrl.$formatters.push(function(value) {
    if (!ctrl.$isEmpty(value)) {
      if (!isNumber(value)) {
        throw $ngModelMinErr('numfmt', 'Expected `,` to be a number', value);
      }
      value = value.toString();
    }
    return value;
  });

  if (attr.min || attr.ngMin) {
    var minVal;
    ctrl.$validators.min = function(value) {
      return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
    };

    attr.$observe('min', function(val) {
      if (isDefined(val) && !isNumber(val)) {
        val = parseFloat(val, 10);
      }
      minVal = isNumber(val) && !isNaN(val) ? val : undefined;
      // TODO(matsko): implement validateLater to reduce number of validations
      ctrl.$validate();
    });
  }

  if (attr.max || attr.ngMax) {
    var maxVal;
    ctrl.$validators.max = function(value) {
      return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
    };

    attr.$observe('max', function(val) {
      if (isDefined(val) && !isNumber(val)) {
        val = parseFloat(val, 10);
      }
      maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
      // TODO(matsko): implement validateLater to reduce number of validations
      ctrl.$validate();
    });
  }
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  // Note: no badInputChecker here by purpose as `url` is only a validation
  // in browsers, i.e. we can always read out input.value even if it is not valid!
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = 'url';
  ctrl.$validators.url = function(modelValue, viewValue) {
    var value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
  };
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  // Note: no badInputChecker here by purpose as `url` is only a validation
  // in browsers, i.e. we can always read out input.value even if it is not valid!
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = 'email';
  ctrl.$validators.email = function(modelValue, viewValue) {
    var value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
  };
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
  }

  var listener = function(ev) {
    if (element[0].checked) {
      ctrl.$setViewValue(attr.value, ev && ev.type);
    }
  };

  element.on('click', listener);

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe('value', ctrl.$render);
}

function parseConstantExpr($parse, context, name, expression, fallback) {
  var parseFn;
  if (isDefined(expression)) {
    parseFn = $parse(expression);
    if (!parseFn.constant) {
      throw minErr('ngModel')('constexpr', 'Expected constant expression for `{:0}`,but saw ' +
                                   '`{:1}`.', name, expression);
    }
    return parseFn(context);
  }
  return fallback;
}

function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
  var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
  var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);

  var listener = function(ev) {
    ctrl.$setViewValue(element[0].checked, ev && ev.type);
  };

  element.on('click', listener);

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
  // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
  // it to a boolean.
  ctrl.$isEmpty = function(value) {
    return value === false;
  };

  ctrl.$formatters.push(function(value) {
    return equals(value, trueValue);
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}


/**
 * @ngdoc directive
 * @name textarea
 * @restrict E
 *
 * @description
 * HTML textarea element control with angular data-binding. The data-binding and validation
 * properties of this element are exactly the same as those of the
 * {@link ng.directive:input input element}.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
 *    length.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
 */


/**
 * @ngdoc directive
 * @name input
 * @restrict E
 *
 * @description
 * HTML input element control. When used together with {@link ngModel `ngModel`}, it provides data-binding,
 * input state control, and validation.
 * Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.
 *
 * <div class="alert alert-warning">
 * **Note:** Not every feature offered is available for all input types.
 * Specifically, data binding and event handling via `ng-model` is unsupported for `input[file]`.
 * </div>
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {boolean=} ngRequired Sets `required` attribute if set to true
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
 *    length.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
 *    This parameter is ignored for input[type=password] controls, which will never trim the
 *    input.
 *
 * @example
    <example name="input-directive" module="inputExample">
      <file name="index.html">
       <script>
          angular.module('inputExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
              $scope.user = {name: 'guest', last: 'visitor'};
            }]);
       </script>
       <div ng-controller="ExampleController">
         <form name="myForm">
           User name: <input type="text" name="userName" ng-model="user.name" required>
           <span class="error" ng-show="myForm.userName.$error.required">
             Required!</span><br>
           Last name: <input type="text" name="lastName" ng-model="user.last"
             ng-minlength="3" ng-maxlength="10">
           <span class="error" ng-show="myForm.lastName.$error.minlength">
             Too short!</span>
           <span class="error" ng-show="myForm.lastName.$error.maxlength">
             Too long!</span><br>
         </form>
         <hr>
         <tt>user = {{user}}</tt><br/>
         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
       </div>
      </file>
      <file name="protractor.js" type="protractor">
        var user = element(by.exactBinding('user'));
        var userNameValid = element(by.binding('myForm.userName.$valid'));
        var lastNameValid = element(by.binding('myForm.lastName.$valid'));
        var lastNameError = element(by.binding('myForm.lastName.$error'));
        var formValid = element(by.binding('myForm.$valid'));
        var userNameInput = element(by.model('user.name'));
        var userLastInput = element(by.model('user.last'));

        it('should initialize to model', function() {
          expect(user.getText()).toContain('{"name":"guest","last":"visitor"}true');
          expect(formValid.getText()).toContain('true');
        });

        it('should be invalid if empty when required', function() {
          userNameInput.clear();
          userNameInput.sendKeys('');

          expect(user.getText()).toContain('{"last":"visitor"}false');
          expect(formValid.getText()).toContain('false');
        });

        it('should be valid if empty when min length is set', function() {
          userLastInput.clear();
          userLastInput.sendKeys('');

          expect(user.getText()).toContain('{"name":"guest","last":""}false');
          expect(lastNameError.getText()).toContain('minlength');
          expect(formValid.getText()).toContain('false');
        });

        it('should be invalid if longer than max length', function() {
          userLastInput.clear();
          userLastInput.sendKeys('some ridiculously long name');

          expect(user.getText()).toContain(',true');
          expect(formValid.getText()).toContain('true');
        });

        it('should be invalid if less than required min length', function() {
          userLastInput.clear();
          userLastInput.sendKeys('xx');

          expect(user.getText()).toContain('{"name":"guest"}` which is similar but less verbose. * * It is preferable to use `ngBind` instead of `,but instead you use the double curly markup like * `,false');
          expect(lastNameError.getText()).toContain('maxlength');
          expect(formValid.getText()).toContain('false');
        });
      </file>
    </example>
 */
var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
    function($browser, $sniffer, $filter, $parse) {
  return {
    restrict: 'E',
    require: ['?ngModel'],
    link: {
      pre: function(scope, element, attr, ctrls) {
        if (ctrls[0]) {
          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
                                                              $browser, $filter, $parse);
        }
      }
    }
  };
}];



var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
/**
 * @ngdoc directive
 * @name ngValue
 *
 * @description
 * Binds the given expression to the value of `<option>` or {@link input[radio] `input[radio]`},
 * so that when the element is selected, the {@link ngModel `ngModel`} of that element is set to
 * the bound value.
 *
 * `ngValue` is useful when dynamically generating lists of radio buttons using
 * {@link ngRepeat `ngRepeat`}, as shown below.
 *
 * Likewise, `ngValue` can be used to generate `<option>` elements for
 * the {@link select `select`} element. In that case however, only strings are supported
 * for the `value `attribute, so the resulting `ngModel` will always be a string.
 * Support for `select` models with non-string values is available via `ngOptions`.
 *
 * @element input
 * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute
 *   of the `input` element
 *
 * @example
    <example name="ngValue-directive" module="valueExample">
      <file name="index.html">
       <script>
          angular.module('valueExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
              $scope.names = ['pizza', 'unicorns', 'robots'];
              $scope.my = { favorite: 'unicorns' };
            }]);
       </script>
        <form ng-controller="ExampleController">
          <h2>Which is your favorite?</h2>
            <label ng-repeat="name in names" for="{{name}}">
              {{name}}
              <input type="radio"
                     ng-model="my.favorite"
                     ng-value="name"
                     id="{{name}}"
                     name="favorite">
            </label>
          <div>You chose {{my.favorite}}</div>
        </form>
      </file>
      <file name="protractor.js" type="protractor">
        var favorite = element(by.binding('my.favorite'));

        it('should initialize to model', function() {
          expect(favorite.getText()).toContain('unicorns');
        });
        it('should bind the values to the inputs', function() {
          element.all(by.model('my.favorite')).get(0).click();
          expect(favorite.getText()).toContain('pizza');
        });
      </file>
    </example>
 */
var ngValueDirective = function() {
  return {
    restrict: 'A',
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function ngValueConstantLink(scope, elm, attr) {
          attr.$set('value', scope.$eval(attr.ngValue));
        };
      } else {
        return function ngValueLink(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set('value', value);
          });
        };
      }
    }
  };
};

/**
 * @ngdoc directive
 * @name ngBind
 * @restrict AC
 *
 * @description
 * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
 * with the value of a given expression, and to update the text content when the value of that
 * expression changes.
 *
 * Typically, you don't use `ngBind` directly{:{ expression}` if a template is momentarily * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an * element attribute,it makes the bindings invisible to the user while the page is loading. * * An alternative solution to this problem would be using the *{@link ng.directive:ngCloak ngCloak}ngBind{:@link guide/expression Expression}to evaluate. * * @example * Enter a name in the Live Preview text box;the greeting below the text box changes instantly. <example module="bindExample"><file name="index.html"><script>angular.module('bindExample',[]) .controller('ExampleController',['$scope',function($scope){:$scope.name = 'Whirled'}]); </script><div ng-controller="ExampleController">Enter name: <input type="text" ng-model="name"><br>Hello <span ng-bind="name"></span>! </div></file><file name="protractor.js" type="protractor">it('should check ng-bind',function(){:var nameInput = element(by.model('name'));:expect(element(by.binding('name')).getText()).toBe('Whirled');:nameInput.clear();:nameInput.sendKeys('world');:expect(element(by.binding('name')).getText()).toBe('world')}); </file></example>*/ var ngBindDirective = ['$compile',function($compile){return { restrict:'AC',compile:function ngBindCompile(templateElement) { $compile.$$addBindingClass(templateElement);:return function ngBindLink(scope,element,attr) { $compile.$$addBindingInfo(element,attr.ngBind);:element = element[0];scope.$watch(attr.ngBind,function ngBindWatchAction(value) { element.textContent = value === undefined ? '':value}]; var ngBindTemplateDirective = ['$interpolate','$compile'function($interpolate,$compile){return { compile:function ngBindTemplateCompile(templateElement) { $compile.$$addBindingClass(templateElement);:return function ngBindTemplateLink(scope,element,attr) { var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));:$compile.$$addBindingInfo(element,interpolateFn.expressions);:element = element[0];attr.$observe('ngBindTemplate',function(value) { element.textContent = value === undefined ? '':value}]; var ngBindHtmlDirective = ['$sce','$compile''$parse'function($sce,$parse,$compile){return { restrict:'A',compile:function ngBindHtmlCompile(tElement,tAttrs) { var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);:var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml,function getStringValue(value) { return(value || '').toString()}); $compile.$$addBindingClass(tElement); return function ngBindHtmlLink(scope,element,attr){:$compile.$$addBindingInfo(element,attr.ngBindHtml);:scope.$watch(ngBindHtmlWatch,function ngBindHtmlWatchAction() { // we re-evaluate the expr because we want a TrustedValueHolderType // for $sce,not a string element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '')}]; var ngChangeDirective = valueFn({restrict:'A',require:'ngModel',link:function(scope,element,attr,ctrl) { ctrl.$viewChangeListeners.push(function() { scope.$eval(attr.ngChange)}); function classDirective(name,selector){:name = 'ngClass' + name;return['$animate',function($animate) { return { restrict:'AC',link:function(scope,element,attr) { var oldVal;:scope.$watch(attr[name],ngClassWatchAction,true);:attr.$observe('class',function(value) { ngClassWatchAction(scope.$eval(attr[name]))}); if (name !== 'ngClass'){scope.$watch('$index',function($index,old$index) { // jshint bitwise:false var mod = $index & 1;:if(mod !==(old$index & 1)) { var classes = arrayClasses(scope.$eval(attr[name]));mod === selector ? addClasses(classes):removeClasses(classes)}function addClasses(classes){:var newClasses = digestClassCounts(classes,1);:attr.$addClass(newClasses)}function removeClasses(classes){:var newClasses = digestClassCounts(classes,-1);:attr.$removeClass(newClasses)}function digestClassCounts(classes,count){:var classCounts = element.data('$classCounts') || {}; var classesToUpdate = []; forEach(classes,function(className){:if(count > 0 || classCounts[className]) { classCounts[className]=(classCounts[className]|| 0) + count;:if(classCounts[className]=== +(count > 0)) { classesToUpdate.push(className)}function updateClasses(oldClasses,newClasses){:var toAdd = arrayDifference(newClasses,oldClasses);:var toRemove = arrayDifference(oldClasses,newClasses);:toAdd = digestClassCounts(toAdd,1);:toRemove = digestClassCounts(toRemove,-1);:if(toAdd && toAdd.length) { $animate.addClass(element,toAdd)}if (toRemove && toRemove.length){:$animate.removeClass(element,toRemove)}function ngClassWatchAction(newVal){:if(selector === true || scope.$index % 2 === selector) { var newClasses = arrayClasses(newVal ||[]);:if(!oldVal) { addClasses(newClasses)}else if (!equals(newVal,oldVal)){:var oldClasses = arrayClasses(oldVal);:updateClasses(oldClasses,newClasses)}; function arrayDifference(tokens1,tokens2){:var values =[];outer:for(var i = 0;:i < tokens1length;:i++) { var token = tokens1[i];:for(var j = 0;:j < tokens2length;:j++) { if(token == tokens2[j]) continue outer}function arrayClasses(classVal){:if(isArray(classVal)) { return classVal}else if (isString(classVal)){:return classVal.split(' ')}else if (isObject(classVal)){:var classes =[];:forEach(classVal,function(v,k) { if(v) { classes = classes.concat(k.split(' '))}var ngClassDirective = classDirective('',true); var ngClassOddDirective = classDirective('Odd',0); var ngClassEvenDirective = classDirective('Even',1); var ngCloakDirective = ngDirective({compile:function(element,attr) { attr.$set('ngCloak',undefined);:element.removeClass('ng-cloak')}); var ngControllerDirective = [function(){return { restrict:'A',scope:true,controller:'@',priority:500}// so that they are not executed in an inconsistent state. var forceAsyncEvents =,; // For events that might fire synchronously during DOM manipulation // we need to execute their event handlers asynchronously using $evalAsync{'blur':true,'focus':true}; forEach( 'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),function(eventName){:var directiveName = directiveNormalize('ng-' + eventName);ngEventDirectives[directiveName]=['$parse','$rootScope',function($parse,$rootScope) { return { restrict:'A',compile:function($element,attr) { // We expose the powerful $event object on the scope that provides access to the Window,// etc. that isn't protected by the fast paths in $parse.  We explicitly request better
          // checks at the cost of speed since event handler expressions are not executed as
          // frequently as regular change detection.
          var fn = $parse(attr[directiveName], /* interceptorFn */ null, /* expensiveChecks */ true);
          return function ngEventHandler(scope, element) {
            element.on(eventName, function(event) {
              var callback = function() {
                fn(scope, {$event:event});
              };
              if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                scope.$evalAsync(callback);
              } else {
                scope.$apply(callback);
              }
            });
          };
        }
      };
    }];
  }
);

/**
 * @ngdoc directive
 * @name ngDblclick
 *
 * @description
 * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
 * a dblclick. (The Event object is available as `$event`)
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-dblclick="count = count + 1" ng-init="count=0">
        Increment (on double click)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngMousedown
 *
 * @description
 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
 * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mousedown="count = count + 1" ng-init="count=0">
        Increment (on mouse down)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngMouseup
 *
 * @description
 * Specify custom behavior on mouseup event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
 * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mouseup="count = count + 1" ng-init="count=0">
        Increment (on mouse up)
      </button>
      count: {{count}}
     </file>
   </example>
 */

/**
 * @ngdoc directive
 * @name ngMouseover
 *
 * @description
 * Specify custom behavior on mouseover event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
 * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mouseover="count = count + 1" ng-init="count=0">
        Increment (when mouse is over)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngMouseenter
 *
 * @description
 * Specify custom behavior on mouseenter event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
 * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mouseenter="count = count + 1" ng-init="count=0">
        Increment (when mouse enters)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngMouseleave
 *
 * @description
 * Specify custom behavior on mouseleave event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
 * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mouseleave="count = count + 1" ng-init="count=0">
        Increment (when mouse leaves)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngMousemove
 *
 * @description
 * Specify custom behavior on mousemove event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
 * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <button ng-mousemove="count = count + 1" ng-init="count=0">
        Increment (when mouse moves)
      </button>
      count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngKeydown
 *
 * @description
 * Specify custom behavior on keydown event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
 * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <example>
     <file name="index.html">
      <input ng-keydown="count = count + 1" ng-init="count=0">
      key down count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngKeyup
 *
 * @description
 * Specify custom behavior on keyup event.
 *
 * @element ANY
 * @priority 0
 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
 * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <example>
     <file name="index.html">
       <p>Typing in the input box below updates the key count</p>
       <input ng-keyup="count = count + 1" ng-init="count=0"> key up count: {{count}}

       <p>Typing in the input box below updates the keycode</p>
       <input ng-keyup="event=$event">
       <p>event keyCode: {{ event.keyCode }}</p>
       <p>event altKey: {{ event.altKey }}</p>
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngKeypress
 *
 * @description
 * Specify custom behavior on keypress event.
 *
 * @element ANY
 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
 * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
 * and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <example>
     <file name="index.html">
      <input ng-keypress="count = count + 1" ng-init="count=0">
      key press count: {{count}}
     </file>
   </example>
 */


/**
 * @ngdoc directive
 * @name ngSubmit
 *
 * @description
 * Enables binding angular expressions to onsubmit events.
 *
 * Additionally it prevents the default action (which for form means sending the request to the
 * server and reloading the current page), but only if the form does not contain `action`,
 * `data-action`, or `x-action` attributes.
 *
 * <div class="alert alert-warning">
 * **Warning:** Be careful not to cause "double-submission" by using both the `ngClick` and
 * `ngSubmit` handlers together. See the
 * {@link form#submitting-a-form-and-preventing-the-default-action `form` directive documentation}
 * for a detailed discussion of when `ngSubmit` may be triggered.
 * </div>
 *
 * @element form
 * @priority 0
 * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
 * ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example module="submitExample">
     <file name="index.html">
      <script>
        angular.module('submitExample', [])
          .controller('ExampleController', ['$scope', function($scope) {
            $scope.list = [];
            $scope.text = 'hello';
            $scope.submit = function() {
              if ($scope.text) {
                $scope.list.push(this.text);
                $scope.text = '';
              }
            };
          }]);
      </script>
      <form ng-submit="submit()" ng-controller="ExampleController">
        Enter text and hit enter:
        <input type="text" ng-model="text" name="text" />
        <input type="submit" id="submit" value="Submit" />
        <pre>list={{list}}</pre>
      </form>
     </file>
     <file name="protractor.js" type="protractor">
       it('should check ng-submit', function() {
         expect(element(by.binding('list')).getText()).toBe('list=[]');
         element(by.css('#submit')).click();
         expect(element(by.binding('list')).getText()).toContain('hello');
         expect(element(by.model('text')).getAttribute('value')).toBe('');
       });
       it('should ignore empty strings', function() {
         expect(element(by.binding('list')).getText()).toBe('list=[]');
         element(by.css('#submit')).click();
         element(by.css('#submit')).click();
         expect(element(by.binding('list')).getText()).toContain('hello');
        });
     </file>
   </example>
 */

/**
 * @ngdoc directive
 * @name ngFocus
 *
 * @description
 * Specify custom behavior on focus event.
 *
 * Note: As the `focus` event is executed synchronously when calling `input.focus()`
 * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
 * during an `$apply` to ensure a consistent state.
 *
 * @element window, input, select, textarea, a
 * @priority 0
 * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
 * focus. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ngBlur
 *
 * @description
 * Specify custom behavior on blur event.
 *
 * A [blur event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires when
 * an element has lost focus.
 *
 * Note: As the `blur` event is executed synchronously also during DOM manipulations
 * (e.g. removing a focussed input),
 * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
 * during an `$apply` to ensure a consistent state.
 *
 * @element window, input, select, textarea, a
 * @priority 0
 * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
 * blur. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ngCopy
 *
 * @description
 * Specify custom behavior on copy event.
 *
 * @element window, input, select, textarea, a
 * @priority 0
 * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
 * copy. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
      copied: {{copied}}
     </file>
   </example>
 */

/**
 * @ngdoc directive
 * @name ngCut
 *
 * @description
 * Specify custom behavior on cut event.
 *
 * @element window, input, select, textarea, a
 * @priority 0
 * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
 * cut. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
      cut: {{cut}}
     </file>
   </example>
 */

/**
 * @ngdoc directive
 * @name ngPaste
 *
 * @description
 * Specify custom behavior on paste event.
 *
 * @element window, input, select, textarea, a
 * @priority 0
 * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
 * paste. ({@link guide/expression#-event- Event object is available as `$event`})
 *
 * @example
   <example>
     <file name="index.html">
      <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
      pasted: {{paste}}
     </file>
   </example>
 */

/**
 * @ngdoc directive
 * @name ngIf
 * @restrict A
 *
 * @description
 * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
 * {expression}. If the expression assigned to `ngIf` evaluates to a false
 * value then the element is removed from the DOM, otherwise a clone of the
 * element is reinserted into the DOM.
 *
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
 * element in the DOM rather than changing its visibility via the `display` css property.  A common
 * case when this difference is significant is when using css selectors that rely on an element's * position within the DOM,such as the `:first-child` or `:last-child` pseudo-classes. * * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope * is created when the element is restored. The scope created within `ngIf` inherits from * its parent scope using * [prototypal inheritance](https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance). * An important implication of this is if `ngModel` is used within `ngIf` to bind to * a javascript primitive defined in the parent scope. In this case any modifications made to the * variable within the child scope will override(hide) the value in the parent scope. * * Also,`ngIf` recreates elements using their compiled state. An example of this behavior * is if an element's class attribute is directly modified after it's compiled,using something like * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
 * the added class will be lost because the original compiled state is used to regenerate the element.
 *
 * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
 * and `leave` effects.
 *
 * @animations
 * enter - happens just after the `ngIf` contents change and a new DOM element is created and injected into the `ngIf` container
 * leave - happens just before the `ngIf` contents are removed from the DOM
 *
 * @element ANY
 * @scope
 * @priority 600
 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
 *     the element is removed from the DOM tree. If it is truthy a copy of the compiled
 *     element is added to the DOM tree.
 *
 * @example
  <example module="ngAnimate" deps="angular-animate.js" animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
      Show when checked:
      <span ng-if="checked" class="animate-if">
        This is removed when the checkbox is unchecked.
      </span>
    </file>
    <file name="animations.css">
      .animate-if {
        background:white;
        border:1px solid black;
        padding:10px;
      }

      .animate-if.ng-enter, .animate-if.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .animate-if.ng-enter,
      .animate-if.ng-leave.ng-leave-active {
        opacity:0;
      }

      .animate-if.ng-leave,
      .animate-if.ng-enter.ng-enter-active {
        opacity:1;
      }
    </file>
  </example>
 */
var ngIfDirective = ['$animate', function($animate) {
  return {
    multiElement: true,
    transclude: 'element',
    priority: 600,
    terminal: true,
    restrict: 'A',
    $$tlb: true,
    link: function($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {

          if (value) {
            if (!childScope) {
              $transclude(function(clone, newScope) {
                childScope = newScope;
                clone[clone.length++] = document.createComment(' end ngIf:' + $attr.ngIf + ' ');
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when its template arrives.
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {
            if (previousElements) {
              previousElements.remove();
              previousElements = null;
            }
            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }
            if (block) {
              previousElements = getBlockNodes(block.clone);
              $animate.leave(previousElements).then(function() {
                previousElements = null;
              });
              block = null;
            }
          }
        });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ngInclude
 * @restrict ECA
 *
 * @description
 * Fetches, compiles and includes an external HTML fragment.
 *
 * By default, the template URL is restricted to the same domain and protocol as the
 * application document. This is done by calling {@link $sce#getTrustedResourceUrl
 * $sce.getTrustedResourceUrl} on it. To load templates from other domains or protocols
 * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
 * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link * ng.$sce Strict Contextual Escaping}autoscroll Whether `ngInclude` should call{:@link ng.$anchorScroll * $anchorScroll}to scroll the viewport after the content is loaded. * * - If the attribute is not set,disable scrolling. * - If the attribute is set without value,enable scrolling. * - Otherwise enable scrolling only if the expression evaluates to truthy value. * * @example <example module="includeExample" deps="angular-animate.js" animations="true"> <file name="index.html"> <div ng-controller="ExampleController"> <select ng-model="template" ng-options="t.name for t in templates"> <option value="">(blank)</option> </select> url of the template:<code>{{:template.url}}</code><hr/><div class="slide-animate-container"><div class="slide-animate" ng-include="template.url"></div></div></div></file><file name="script.js">angular.module('includeExample',['ngAnimate']) .controller('ExampleController',['$scope',function($scope){$scope.templates =[{ name:'template1.html',url:'template1.html'}{name:'template2.html',url:'template2.html'}]); </file><file name="template1.html">Content of template1.html </file><file name="template2.html">Content of template2.html </file><file name="animations.css">.slide-animate-container{position:relative;background:#fff;border:1px solid #000;height:40px;overflow:hidden}.slide-animate{padding:10px}.slide-animate.ng-enter,.slide-animate.ng-leave{-webkit-transition:all cubic-bezier(.25,.46,.45,.94) .5s;transition:all cubic-bezier(.25,.46,.45,.94) .5s;position:absolute;left:0;right:0;bottom:0;display:block;padding:10px}.slide-animate.ng-enter{top:-50px}.slide-animate.ng-enter.ng-enter-active,.slide-animate.ng-leave{top:0}.slide-animate.ng-leave.ng-leave-active{top:50px}</file><file name="protractor.js" type="protractor">var templateSelect = element(by.model('template')); var includeElem = element(by.css('[ng-include]')); it('should load template1.html',function(){:expect(includeElem.getText()).toMatch(/Content of template1html/)}); it('should load template2.html',function(){:if(browser.params.browser == 'firefox') { // Firefox can't handle using selects
          // See https://github.com/angular/protractor/issues/480
          return;
        }
        templateSelect.click();
        templateSelect.all(by.css('option')).get(2).click();
        expect(includeElem.getText()).toMatch(/Content of template2.html/);
      });

      it('should change to blank', function() {
        if (browser.params.browser == 'firefox') {
          // Firefox can't handle using selects return}); </file></example>*/ var ngIncludeDirective = ['$templateRequest','$anchorScroll''$animate''$sce'function($templateRequest,$anchorScroll,$animate,$sce){return { restrict:'ECA',priority:400,terminal:true,transclude:'element',controller:angular.noop,compile:function(element,attr) { var srcExp = attr.ngInclude || attr.src,onloadExp = attr.onload || '',autoScrollExp = attr.autoscroll;:return function(scope,$element,$attr,ctrl,$transclude) { var changeCounter = 0,currentScope,previousElement,currentElement;:var cleanupLastIncludeContent = function() { if(previousElement) { previousElement.remove();:previousElement = null}if (currentScope){:currentScope.$destroy();:currentScope = null}if (currentElement){:$animate.leave(currentElement).then(function() { previousElement = null}; scope.$watch($sce.parseAsResourceUrl(srcExp),function ngIncludeWatchAction(src){:var afterAnimation = function() { if(isDefined(autoScrollExp) &&(!autoScrollExp || scope.$eval(autoScrollExp))) { $anchorScroll()}; var thisChangeId =++changeCounter; if (src){://set the 2nd param to true to ignore the template request error so that the inner //contents and scope can be cleaned up. $templateRequest(src,true).then(function(response) { if(thisChangeId !== changeCounter) return;:var newScope = scope.$new();:ctrl.template = response;// Note:This will also link all children of ng-include that were contained in the original // html. If that content contains controllers,... they could pollute/change the scope. // However,using ng-include on an element with additional content does not make sense... // Note:We can't remove them in the cloneAttchFn of $transclude as that
              // function is called before linking the content, which would apply child
              // directives to non existing elements.
              var clone = $transclude(newScope, function(clone) {
                cleanupLastIncludeContent();
                $animate.enter(clone, null, $element).then(afterAnimation);
              });

              currentScope = newScope;
              currentElement = clone;

              currentScope.$emit('$includeContentLoaded', src);
              scope.$eval(onloadExp);
            }, function() {
              if (thisChangeId === changeCounter) {
                cleanupLastIncludeContent();
                scope.$emit('$includeContentError', src);
              }
            });
            scope.$emit('$includeContentRequested', src);
          } else {
            cleanupLastIncludeContent();
            ctrl.template = null;
          }
        });
      };
    }
  };
}];

// This directive is called during the $transclude call of the first `ngInclude` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngInclude
// is called.
var ngIncludeFillContentDirective = ['$compile',
  function($compile) {
    return {
      restrict: 'ECA',
      priority: -400,
      require: 'ngInclude',
      link: function(scope, $element, $attr, ctrl) {
        if (/SVG/.test($element[0].toString())) {
          // WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not
          // support innerHTML, so detect this here and try to generate the contents
          // specially.
          $element.empty();
          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
              function namespaceAdaptedClone(clone) {
            $element.append(clone);
          }, {futureParentElement: $element});
          return;
        }

        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      }
    };
  }];

/**
 * @ngdoc directive
 * @name ngInit
 * @restrict AC
 *
 * @description
 * The `ngInit` directive allows you to evaluate an expression in the
 * current scope.
 *
 * <div class="alert alert-error">
 * The only appropriate use of `ngInit` is for aliasing special properties of
 * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you
 * should use {@link guide/controller controllers} rather than `ngInit`
 * to initialize values on a scope.
 * </div>
 * <div class="alert alert-warning">
 * **Note**: If you have assignment in `ngInit` along with {@link ng.$filter `$filter`}, make
 * sure you have parenthesis for correct precedence:
 * <pre class="prettyprint">
 * `<div ng-init="test1 = (data | orderBy:'name')"></div>`
 * </pre>
 * </div>
 *
 * @priority 450
 *
 * @element ANY
 * @param {expression} ngInit {@link guide/expression Expression} to eval.
 *
 * @example
   <example module="initExample">
     <file name="index.html">
   <script>
     angular.module('initExample', [])
       .controller('ExampleController', ['$scope', function($scope) {
         $scope.list = [['a', 'b'], ['c', 'd']];
       }]);
   </script>
   <div ng-controller="ExampleController">
     <div ng-repeat="innerList in list" ng-init="outerIndex = $index">
       <div ng-repeat="value in innerList" ng-init="innerIndex = $index">
          <span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};</span>
       </div>
     </div>
   </div>
     </file>
     <file name="protractor.js" type="protractor">
       it('should alias index positions', function() {
         var elements = element.all(by.css('.example-init'));
         expect(elements.get(0).getText()).toBe('list[0][0]= a;');
         expect(elements.get(1).getText()).toBe('list[0][1]= b');
         expect(elements.get(2).getText()).toBe('list[1][0]= c');
         expect(elements.get(3).getText()).toBe('list[1][1]= d');
       });
     </file>
   </example>
 */
var ngInitDirective = ngDirective({
  priority: 450,
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    };
  }
});

/**
 * @ngdoc directive
 * @name ngList
 *
 * @description
 * Text input that converts between a delimited string and an array of strings. The default
 * delimiter is a comma followed by a space - equivalent to `ng-list=", "`. You can specify a custom
 * delimiter as the value of the `ngList` attribute - for example, `ng-list=" | "`.
 *
 * The behaviour of the directive is affected by the use of the `ngTrim` attribute.
 * * If `ngTrim` is set to `"false"` then whitespace around both the separator and each
 *   list item is respected. This implies that the user of the directive is responsible for
 *   dealing with whitespace but also allows you to use whitespace as a delimiter, such as a
 *   tab or newline character.
 * * Otherwise whitespace around the delimiter is ignored when splitting (although it is respected
 *   when joining the list items back together) and whitespace around each list item is stripped
 *   before it is added to the model.
 *
 * ### Example with Validation
 *
 * <example name="ngList-directive" module="listExample">
 *   <file name="app.js">
 *      angular.module('listExample', [])
 *        .controller('ExampleController', ['$scope', function($scope) {
 *          $scope.names = ['morpheus', 'neo', 'trinity'];
 *        }]);
 *   </file>
 *   <file name="index.html">
 *    <form name="myForm" ng-controller="ExampleController">
 *      List: <input name="namesInput" ng-model="names" ng-list required>
 *      <span class="error" ng-show="myForm.namesInput.$error.required">
 *        Required!</span>
 *      <br>
 *      <tt>names = {{names}}</tt><br/>
 *      <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
 *      <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
 *      <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
 *      <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
 *     </form>
 *   </file>
 *   <file name="protractor.js" type="protractor">
 *     var listInput = element(by.model('names'));
 *     var names = element(by.exactBinding('names'));
 *     var valid = element(by.binding('myForm.namesInput.$valid'));
 *     var error = element(by.css('span.error'));
 *
 *     it('should initialize to model', function() {
 *       expect(names.getText()).toContain('["morpheus","neo","trinity"]');
 *       expect(valid.getText()).toContain('true');
 *       expect(error.getCssValue('display')).toBe('none');
 *     });
 *
 *     it('should be invalid if empty', function() {
 *       listInput.clear();
 *       listInput.sendKeys('');
 *
 *       expect(names.getText()).toContain('');
 *       expect(valid.getText()).toContain('false');
 *       expect(error.getCssValue('display')).not.toBe('none');
 *     });
 *   </file>
 * </example>
 *
 * ### Example - splitting on whitespace
 * <example name="ngList-directive-newlines">
 *   <file name="index.html">
 *    <textarea ng-model="list" ng-list="&#10;" ng-trim="false"></textarea>
 *    <pre>{{ list | json }}</pre>
 *   </file>
 *   <file name="protractor.js" type="protractor">
 *     it("should split the text by newlines", function() {
 *       var listInput = element(by.model('list'));
 *       var output = element(by.binding('list | json'));
 *       listInput.sendKeys('abc\ndef\nghi');
 *       expect(output.getText()).toContain('[\n "abc",\n "def",\n "ghi"\n]');
 *     });
 *   </file>
 * </example>
 *
 * @element input
 * @param {string=} ngList optional delimiter that should be used to split the value.
 */
var ngListDirective = function() {
  return {
    restrict: 'A',
    priority: 100,
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      // We want to control whitespace trimming so we use this convoluted approach
      // to access the ngList attribute, which doesn't pre-trim the attribute var ngList = element.attr(attr.$attr.ngList) || ', ':var trimValues = attr.ngTrim !== 'false';var separator = trimValues ? trim(ngList):ngList;:var parse = function(viewValue) { // If the viewValue is invalid(say required but empty) it will be `undefined` if(isUndefined(viewValue)) return;:var list =[];if(viewValue) { forEach(viewValue.split(separator),function(value) { if(value) list.push(trimValues ? trim(value):value)}; ctrl.$parsers.push(parse); ctrl.$formatters.push(function(value){:if(isArray(value)) { return value.join(ngList)}); // Override the standard $isEmpty because an empty array means the input is empty. ctrl.$isEmpty = function(value){:return !value || !value.length}; var VALID_CLASS = 'ng-valid',DIRTY_CLASS = 'ng-dirty',INVALID_CLASS = 'ng-invalid',PENDING_CLASS = 'ng-pending'; var $ngModelMinErr = new minErr('ngModel'); var NgModelController = ['$scope',PRISTINE_CLASS = 'ng-pristine',TOUCHED_CLASS = 'ng-touched',UNTOUCHED_CLASS = 'ng-untouched','$element''$attrs''$rootScope''$animate''$timeout''$q''$interpolate''$parse''$exceptionHandler'function($scope,$exceptionHandler,$attr,$element,$parse,$animate,$timeout,$rootScope,$q,$interpolate){:this.$viewValue = Number.NaN;:this.$modelValue = Number.NaN;:this.$$rawModelValue = undefined;:// stores the parsed modelValue / model set from scope regardless of validity. this.$validators = {}; // keep valid keys here this.$pending = undefined; // keep pending keys here this.$name = $interpolate($attr.name || '',false)($scope); var parsedNgModel = $parse($attr.ngModel),ctrl = this; this.$$setOptions = function(options),ngModelGet = parsedNgModel,ngModelSet = parsedNgModelAssign,parsedNgModelAssign = parsedNgModel.assign,pendingDebounce = null{:ctrl.$options = options;:if(options && options.getterSetter) { var invokeModelGetter = $parse($attr.ngModel + '()'),invokeModelSetter = $parse($attr.ngModel + '($$$p)');:ngModelGet = function($scope) { var modelValue = parsedNgModel($scope);:if(isFunction(modelValue)) { modelValue = invokeModelGetter($scope)}; ngModelSet = function($scope,newValue){if(isFunction(parsedNgModel($scope))) { invokeModelSetter($scope,{$$$p:ctrl.$modelValue}else if (!parsedNgModel.assign){:throw $ngModelMinErr('nonassign',"Expression '{0}' is non-assignable. Element: {1}",$attr.ngModel,startingTag($element))}; this.$render = noop; this.$isEmpty = function(value){:return isUndefined(value) || value === '' || value === null || value !== value}; var parentForm = $element.inheritedData('$formController') || nullFormCtrl,currentValidationRunId = 0; addSetValidityMethod({ctrl:this,$element:$element,set:function(object,property) { object[property]= true},unset: function(object,property){:delete object[property]}); this.$setPristine = function(){:ctrl.$dirty = false;:ctrl.$pristine = true;:$animate.removeClass($element,DIRTY_CLASS);:$animate.addClass($element,PRISTINE_CLASS)}; this.$setDirty = function(){:ctrl.$dirty = true;:ctrl.$pristine = false;:$animate.removeClass($element,PRISTINE_CLASS);:$animate.addClass($element,DIRTY_CLASS);:parentForm.$setDirty()}; this.$setUntouched = function(){:ctrl.$touched = false;:ctrl.$untouched = true;:$animate.setClass($element,UNTOUCHED_CLASS,TOUCHED_CLASS)}; this.$setTouched = function(){:ctrl.$touched = true;:ctrl.$untouched = false;:$animate.setClass($element,TOUCHED_CLASS,UNTOUCHED_CLASS)}; this.$rollbackViewValue = function(){:$timeout.cancel(pendingDebounce);:ctrl.$viewValue = ctrl.$$lastCommittedViewValue;:ctrl.$render()}; this.$validate = function(){:// ignore $validate before model is initialized if(isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) { return}so we don't unset it accidentially
    var parserName = ctrl.$$parserName || 'parse';
    var parserValid = ctrl.$error[parserName] ? false : undefined;

    var prevValid = ctrl.$valid;
    var prevModelValue = ctrl.$modelValue;

    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;

    ctrl.$$runValidators(parserValid, modelValue, viewValue, function(allValid) {
      // If there was no change in validity, don't update the model // This prevents changing an invalid modelValue to undefined if (!allowInvalid && prevValid !== allValid),var viewValue = ctrl.$$lastCommittedViewValue; // Note: we use the $$rawModelValue as $modelValue might have been // set to undefined during a view ->model update that found validation // errors. We can't parse the view here, since that could change
    // the model although neither viewValue nor the model on the scope changed
    var modelValue = ctrl.$$rawModelValue;

    // Check if the there's a parse error{// Note:Don't check ctrl.$valid here, as we could have
        // external validators (e.g. calculated on the server),
        // that just call $setValidity and need the model value
        // to calculate their validity.
        ctrl.$modelValue = allValid ? modelValue : undefined;

        if (ctrl.$modelValue !== prevModelValue) {
          ctrl.$$writeModelToScope();
        }
      }
    });

  };

  this.$$runValidators = function(parseValid, modelValue, viewValue, doneCallback) {
    currentValidationRunId++;
    var localValidationRunId = currentValidationRunId;

    // check parser error
    if (!processParseErrors(parseValid)) {
      validationDone(false);
      return;
    }
    if (!processSyncValidators()) {
      validationDone(false);
      return;
    }
    processAsyncValidators();

    function processParseErrors(parseValid) {
      var errorKey = ctrl.$$parserName || 'parse';
      if (parseValid === undefined) {
        setValidity(errorKey, null);
      } else {
        setValidity(errorKey, parseValid);
        if (!parseValid) {
          forEach(ctrl.$validators, function(v, name) {
            setValidity(name, null);
          });
          forEach(ctrl.$asyncValidators, function(v, name) {
            setValidity(name, null);
          });
          return false;
        }
      }
      return true;
    }

    function processSyncValidators() {
      var syncValidatorsValid = true;
      forEach(ctrl.$validators, function(validator, name) {
        var result = validator(modelValue, viewValue);
        syncValidatorsValid = syncValidatorsValid && result;
        setValidity(name, result);
      });
      if (!syncValidatorsValid) {
        forEach(ctrl.$asyncValidators, function(v, name) {
          setValidity(name, null);
        });
        return false;
      }
      return true;
    }

    function processAsyncValidators() {
      var validatorPromises = [];
      var allValid = true;
      forEach(ctrl.$asyncValidators, function(validator, name) {
        var promise = validator(modelValue, viewValue);
        if (!isPromiseLike(promise)) {
          throw $ngModelMinErr("$asyncValidators",
            "Expected asynchronous validator to return a promise but got '{0}); function writeToModelIfNeeded(){:if(ctrl.$modelValue !== prevModelValue) { ctrl.$$writeModelToScope()}; this.$$writeModelToScope = function(){:ngModelSet($scope,ctrl.$modelValue);:forEach(ctrl.$viewChangeListeners,function(listener) { try { listener()}catch (e){:$exceptionHandler(e);:$exceptionHandler(e)}; this.$setViewValue = function(value,trigger){:ctrl.$viewValue = value;:if(!ctrl.$options || ctrl.$options.updateOnDefault) { ctrl.$$debounceViewValueCommit(trigger)}; this.$$debounceViewValueCommit = function(trigger){:var debounceDelay = 0,options = ctrl.$options,debounce;:if(options && isDefined(options.debounce)) { debounce = options.debounce;:if(isNumber(debounce)) { debounceDelay = debounce}else if (isNumber(debounce[trigger])){:debounceDelay = debounce[trigger]}else if (isNumber(debounce['default'])){:debounceDelay = debounce['default']}$timeout.cancel(pendingDebounce); if (debounceDelay){:pendingDebounce = $timeout(function() { ctrl.$commitViewValue()}else if ($rootScope.$$phase){:ctrl.$commitViewValue()}; // model ->value // Note: we cannot use a normal scope.$watch as we want to detect the following: // 1. scope value is 'a' // 2. user enters 'b' // 3. ng-change kicks in and reverts scope value to 'a' // ->scope value did not change since the last digest as // ng-change executes in apply phase // 4. view should be changed back to 'a' $scope.$watch(function ngModelWatch(){:var modelValue = ngModelGet($scope);// if scope model value and ngModel value are out of sync // TODO(perf):why not move this to the action fn? if(modelValue !== ctrl.$modelValue) { ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;:var formatters = ctrl.$formatters,idx = formatters.length;:var viewValue = modelValue;:while(idx--) { viewValue = formatters[idx](viewValue)}if (ctrl.$viewValue !== viewValue){:ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;:ctrl.$render();:ctrl.$$runValidators(undefined,modelValue,viewValue,noop)}]; var ngModelDirective = ['$rootScope',function($rootScope){return { restrict:'A',require['ngModel','^?form','^?ngModelOptions'],controller:NgModelController,// Prelink needs to run before any input directive // so that we can set the NgModelOptions in NgModelController // before anyone else uses it. priority:1,compile:function ngModelCompile(element) { // Setup initial state of the control element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);return { pre:function ngModelPreLink(scope,element,attr,ctrls) { var modelCtrl = ctrls[0],formCtrl = ctrls[1]|| nullFormCtrl;:modelCtrl.$$setOptions(ctrls[2]&& ctrls[2].$options);:// notify others,especially parent forms formCtrl.$addControl(modelCtrl);:attr.$observe('name',function(newValue) { if(modelCtrl.$name !== newValue) { formCtrl.$$renameControl(modelCtrl,newValue)}); scope.$on('$destroy',function(){:formCtrl.$removeControl(modelCtrl)},post: function ngModelPostLink(scope,element,attr,ctrls){:var modelCtrl = ctrls[0];:if(modelCtrl.$options && modelCtrl.$options.updateOn) { element.on(modelCtrl.$options.updateOn,function(ev) { modelCtrl.$$debounceViewValueCommit(ev && ev.type)}element.on('blur',function(ev){:if(modelCtrl.$touched) return;:if($rootScope.$$phase) { scope.$evalAsync(modelCtrl.$setTouched)}]; var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/; var ngModelOptionsDirective = function(){return { restrict:'A',controller['$scope','$attrs',function($scope,$attrs) { var that = this;:this.$options = $scope.$eval($attrs.ngModelOptions);:// Allow adding/overriding bound events if(this.$options.updateOn !== undefined) { this.$options.updateOnDefault = false;:// extract "default" pseudo-event from list of events that can trigger a model update this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP,function() { that.$options.updateOnDefault = true;:return ' '}; // helper methods function addSetValidityMethod(context){:var ctrl = context.ctrl,$element = context.$element,classCache = {}$animate = context.$animate; classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)); ctrl.$setValidity = setValidity; function setValidity(validationErrorKey,state,controller),,set = context.set,parentForm = context.parentForm,unset = context.unset{:if(state === undefined) { createAndSet('$pending',validationErrorKey,controller)}if (!isBoolean(state)){:unset(ctrl.$error,validationErrorKey,controller);:unset(ctrl.$$success,validationErrorKey,controller)}if (ctrl.$pending){:cachedToggleClass(PENDING_CLASS,true);:ctrl.$valid = ctrl.$invalid = undefined;:toggleValidationCss('',null)}// and does not replace it. var combinedState; if (ctrl.$pending && ctrl.$pending[validationErrorKey]),// re-read the state as the set/unset methods could have // combined state in ctrl.$error[validationError] (used for forms),// where setting/unsetting only increments/decrements the value{:combinedState = undefined}else if (ctrl.$error[validationErrorKey]){:combinedState = false}else if (ctrl.$$success[validationErrorKey]){:combinedState = true}function createAndSet(name,value,controller){:if(!ctrl[name]) { ctrl[name]= {}function unsetAndCleanup(name,value,controller){:if(ctrl[name]) { unset(ctrl[name],value,controller)}if (isObjectEmpty(ctrl[name])){:ctrl[name]= undefined}function cachedToggleClass(className,switchValue){:if(switchValue && !classCache[className]) { $animate.addClass($element,className);:classCache[className]= true}else if (!switchValue && classCache[className]){:$animate.removeClass($element,className);:classCache[className]= false}function toggleValidationCss(validationErrorKey,isValid){validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey,'-'):'';:cachedToggleClass(VALID_CLASS + validationErrorKey,isValid === true);:cachedToggleClass(INVALID_CLASS + validationErrorKey,isValid === false)}function isObjectEmpty(obj){:if(obj) { for(var prop in obj) { return false}var ngNonBindableDirective = ngDirective({terminal:true,priority:1000}); var ngPluralizeDirective = ['$locale','$interpolate'function($locale,$interpolate){:var BRACE = /{}/g,IS_WHEN = /^when(Minus)?(.+)$/; return{restrict:'EA',link:function(scope,element,attr) { var numberExp = attr.count,whenExp = attr.$attr.when && element.attr(attr.$attr.when),// we have {{},startSymbol = $interpolate.startSymbol(),braceReplacement = startSymbol+numberExp+'-'+offset+endSymbol,endSymbol = $interpolate.endSymbol(),lastCount; forEach(attr,function(expression,attributeName),watchRemover = angular.noop{:var tmpMatch = IS_WHEN.exec(attributeName);if(tmpMatch) { var whenKey =(tmpMatch[1]? '-':'') + lowercase(tmpMatch[2]);:whens[whenKey]= element.attr(attr.$attr[attributeName])}); forEach(whens,function(expression,key){:whensExpFns[key]= $interpolate(expression.replace(BRACE,braceReplacement))}); scope.$watch(numberExp,function ngPluralizeWatchAction(newVal){:var count = parseFloat(newVal);:var countIsNaN = isNaN(count);:if(!countIsNaN && !(count in whens)) { // If an explicit number rule such as 1,2,3.. is defined,just use it. // Otherwise,check it against pluralization rules in $locale service. count = $locale.pluralCat(count - offset)}* </div>* <footer ng-repeat-end>* Footer,* </header>* <div class="body">* Body,// If both `count` and `lastCount` are NaN,we don't need to re-register a watch.
        // In JS `NaN !== NaN`, so we have to exlicitly check.
        if ((count !== lastCount) && !(countIsNaN && isNaN(lastCount))) {
          watchRemover();
          watchRemover = scope.$watch(whensExpFns[count], updateElementText);
          lastCount = count;
        }
      });

      function updateElementText(newText) {
        element.text(newText || '');
      }
    }
  };
}];

/**
 * @ngdoc directive
 * @name ngRepeat
 *
 * @description
 * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
 * instance gets its own scope, where the given loop variable is set to the current collection item,
 * and `$index` is set to the item index or key.
 *
 * Special properties are exposed on the local scope of each template instance, including:
 *
 * | Variable  | Type            | Details                                                                     |
 * |-----------|-----------------|-----------------------------------------------------------------------------|
 * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
 * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
 * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
 * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
 * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
 * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
 *
 * Creating aliases for these properties is possible with {@link ng.directive:ngInit `ngInit`}.
 * This may be useful when, for instance, nesting ngRepeats.
 *
 * # Iterating over object properties
 *
 * It is possible to get `ngRepeat` to iterate over the properties of an object using the following
 * syntax:
 *
 * ```js
 * <div ng-repeat="(key, value) in myObj"> ... </div>
 * ```
 *
 * You need to be aware that the JavaScript specification does not define what order
 * it will return the keys for an object. In order to have a guaranteed deterministic order
 * for the keys, Angular versions up to and including 1.3 **sort the keys alphabetically**.
 *
 * If this is not desired, the recommended workaround is to convert your object into an array
 * that is sorted into the order that you prefer before providing it to `ngRepeat`.  You could
 * do this with a filter such as [toArrayFilter](http://ngmodules.org/modules/angular-toArrayFilter)
 * or implement a `$watch` on the object yourself.
 *
 * In version 1.4 we will remove the sorting, since it seems that browsers generally follow the
 * strategy of providing keys in the order in which they were defined, although there are exceptions
 * when keys are deleted and reinstated.
 *
 *
 * # Special repeat start and end points
 * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
 * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
 * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on) * up to and including the ending HTML tag where **ng-repeat-end** is placed. * * The example below makes use of this feature: * ```html * <header ng-repeat-start="item in items">* Header{:{ item}* </footer>* ``` * * And with an input of{:@type['A','B']}* and `expression` is the scope expression giving the collection to enumerate. * * For example: `(name,age) in,ngRepeat The expression indicating how to enumerate a collection. These * formats are currently supported: * * * `variable in expression`  where variable is the user defined loop variable and `expression` * is a scope expression giving the collection to enumerate. * * For example: `album in artist.albums`. * * * `(key,value) in expression`  where `key` and `value` can be any user defined identifiers{'adam':10,'amalie':12}`. * * * `variable in expression track by tracking_expression`  You can also provide an optional tracking function * which can be used to associate the objects in the collection with the DOM elements. If no tracking function * is specified the ng-repeat associates elements by identity in the collection. It is an error to have * more than one tracking function to resolve to the same key. (This would mean that two distinct objects are * mapped to the same DOM element,which is not possible.) Filters should be applied to the expression,* before specifying a tracking expression. * * For example:`item in items` is equivalent to `item in items track by $id(item)`. This implies that the DOM elements * will be associated by item identity in the array. * * For example:`item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique * `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements * with the corresponding item in the array by identity. Moving the same object in array would move the DOM * element in the same way in the DOM. * * For example:`item in items track by item.id` is a typical pattern when the items come from the database. In this * case the object identity does not matter. Two objects are considered equivalent as long as their `id` * property is same. * * For example:`item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter * to items in conjunction with a tracking expression. * * * `variable in expression as alias_expression`  You can also provide an optional alias expression which will then store the * intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message * when a filter is active on the repeater,but the filtered result set is empty. * * For example:`item in items | filter:x as results` will store the fragment of the repeated items as `results`,but only after * the items have been processed through the filter. * * @example * This example initializes the scope to a list of names and * then uses `ngRepeat` to display every person:<example module="ngAnimate" deps="angular-animate.js" animations="true"> <file name="index.html"> <div ng-init="friends = [
        {name:'John', age:25, gender:'boy'},
        {name:'Jessie', age:30, gender:'girl'},
        {name:'Johanna', age:28, gender:'girl'},
        {name:'Joy', age:15, gender:'girl'},
        {name:'Mary', age:28, gender:'girl'},
        {name:'Peter', age:95, gender:'boy'},
        {name:'Sebastian', age:50, gender:'boy'},
        {name:'Erika', age:27, gender:'girl'},
        {name:'Patrick', age:40, gender:'boy'},
        {name:'Samantha', age:60, gender:'girl'}
      ]"> I have{{:friends.length}}friends. They are: <input type="search" ng-model="q" placeholder="filter friends..." /><ul class="example-animate-container"><li class="animate-repeat" ng-repeat="friend in friends | filter:q as results">[{:{$index + 1}who is{:{friend.age}years old. </li><li class="animate-repeat" ng-if="results.length == 0"><strong>No results found...</strong></li></ul></div></file><file name="animations.css">.example-animate-container{background:#fff;border:1px solid #000;list-style:none;margin:0;padding:0 10px}.animate-repeat{line-height:40px;list-style:none;box-sizing:border-box}.animate-repeat.ng-enter,.animate-repeat.ng-leave,.animate-repeat.ng-move{-webkit-transition:all linear .5s;transition:all linear .5s}.animate-repeat.ng-enter,.animate-repeat.ng-leave.ng-leave-active,.animate-repeat.ng-move{opacity:0;max-height:0}.animate-repeat.ng-enter.ng-enter-active,.animate-repeat.ng-leave,.animate-repeat.ng-move.ng-move-active{opacity:1;max-height:40px}</file><file name="protractor.js" type="protractor">var friends = element.all(by.repeater('friend in friends')); it('should render initial data set',function(){:expect(friends.count()).toBe(10);:expect(friends.get(0).getText()).toEqual('[1] John who is 25 years old.');:expect(friends.get(1).getText()).toEqual('[2] Jessie who is 30 years old.');:expect(friends.last().getText()).toEqual('[10] Samantha who is 60 years old.');:expect(element(by.binding('friends.length')).getText()) .toMatch("I have 10 friends. They are:")}); it('should update repeater when filter predicate changes',function(){:expect(friends.count()).toBe(10);:element(by.model('q')).sendKeys('ma');:expect(friends.count()).toBe(2);:expect(friends.get(0).getText()).toEqual('[1] Mary who is 28 years old.');:expect(friends.last().getText()).toEqual('[2] Samantha who is 60 years old.')}); </file></example>*/ var ngRepeatDirective = ['$parse','$animate'function($parse,$animate){:var NG_REMOVED = '$$NG_REMOVED';:var ngRepeatMinErr = minErr('ngRepeat');var updateScope = function(scope,index,valueIdentifier,value,keyIdentifier,key,arrayLength) { // TODO(perf):generate setters to shave off ~40ms or 1-1.5% scope[valueIdentifier]= value;:if(keyIdentifier) scope[keyIdentifier]= key;:scope.$index = index;:scope.$first =(index === 0);:scope.$last =(index ===(arrayLength - 1));:scope.$middle = !(scope.$first || scope.$last);// jshint bitwise:false scope.$odd = !(scope.$even =(index&1) === 0);// jshint bitwise:true}; var getBlockStart = function(block){:return block.clone[0]}; var getBlockEnd = function(block){:return block.clone[block.clone.length - 1]}; return{:var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);:if(!match) { throw ngRepeatMinErr('iexp',"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",expression)}var lhs = match[1]; var rhs = match[2]; var aliasAs = match[3]; var trackByExp = match[4]; match = lhs.match(/^(?:(\s[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/); if (!match){:throw ngRepeatMinErr('iidexp',"'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",lhs)}var valueIdentifier = match[3] || match[1]; var keyIdentifier = match[2]; if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))){:throw ngRepeatMinErr('badident',"alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",aliasAs)}trackByIdArrayFn,trackByIdExpFn,trackByIdObjFn; var hashFnLocals =,var trackByExpGetter{$id:hashKey}; if (trackByExp){:trackByExpGetter = $parse(trackByExp)}; trackByIdObjFn = function(key){:return key}return function ngRepeatLink($scope,$element,$attr,ctrl,$transclude){:if(trackByExpGetter) { trackByIdExpFn = function(key,value,index) { // assign key,value,and $index to the locals so that they can be used in hash functions if(keyIdentifier) hashFnLocals[keyIdentifier]= key;:hashFnLocals[valueIdentifier]= value;:hashFnLocals.$index = index;:return trackByExpGetter($scope,hashFnLocals)}// Store a list of elements from previous run. This is a hash where key is the item from the // iterator,and the value is objects with following properties. // - scope: bound scope // - element: previous element. // - index: position // // We are using no-proto object so that we don't need to guard against inherited props via
        // hasOwnProperty.
        var lastBlockMap = createMap();

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
          var index, length,
              previousNode = $element[0],     // node that cloned nodes should be inserted after
                                              // initialized to the comment node anchor
              nextNode,
              // Same as lastBlockMap but it has the current state. It will become the
              // lastBlockMap on the next iteration.
              nextBlockMap = createMap(),
              collectionLength,
              key, value, // key/value of iteration
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder,
              elementsToRemove;

          if (aliasAs) {
            $scope[aliasAs] = collection;
          }

          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (var itemKey in collection) {
              if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
                collectionKeys.push(itemKey);
              }
            }
            collectionKeys.sort();
          }

          collectionLength = collectionKeys.length;
          nextBlockOrder = new Array(collectionLength);

          // locate existing items
          for (index = 0; index < collectionLength; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);
            if (lastBlockMap[trackById]) {
              // found previously seen block
              block = lastBlockMap[trackById];
              delete lastBlockMap[trackById];
              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            } else if (nextBlockMap[trackById]) {
              // if collision detected. restore lastBlockMap and throw an error
              forEach(nextBlockOrder, function(block) {
                if (block && block.scope) lastBlockMap[block.id] = block;
              });
              throw ngRepeatMinErr('dupes',
                  "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                  expression, trackById, value);
            } else {
              // new never before seen block
              nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined};
              nextBlockMap[trackById] = true;
            }
          }

          // remove leftover items
          for (var blockKey in lastBlockMap) {
            block = lastBlockMap[blockKey];
            elementsToRemove = getBlockNodes(block.clone);
            $animate.leave(elementsToRemove);
            if (elementsToRemove[0].parentNode) {
              // if the element was not removed yet because of pending animation, mark it as deleted
              // so that we can ignore it later
              for (index = 0, length = elementsToRemove.length; index < length; index++) {
                elementsToRemove[index][NG_REMOVED] = true;
              }
            }
            block.scope.$destroy();
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0; index < collectionLength; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            if (block.scope) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element

              nextNode = previousNode;

              // skip nodes that are already pending removal via leave animation
              do {
                nextNode = nextNode.nextSibling;
              } while (nextNode && nextNode[NG_REMOVED]);

              if (getBlockStart(block) != nextNode) {
                // existing item which got moved
                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
              }
              previousNode = getBlockEnd(block);
              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
            } else {
              // new item which we don't know about $transclude(function ngRepeatTransclude(clone,scope){:block.scope = scope;// http://jsperf.com/clone-vs-createcomment var endNode = ngRepeatEndComment.cloneNode(false);:clone[clone.length++]= endNode;// TODO(perf):support naked previousNode in `enter` to avoid creation of jqLite wrapper? $animate.enter(clone,null,jqLite(previousNode));:previousNode = endNode;// Note:We only need the first/last node of the cloned nodes. // However,we need to keep the reference to the jqlite wrapper as it might be changed later // by a directive with templateUrl when its template arrives. block.clone = clone;:nextBlockMap[block.id]= block;:updateScope(block.scope,index,valueIdentifier,value,keyIdentifier,key,collectionLength)}]; var NG_HIDE_CLASS = 'ng-hide'; var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate'; var ngShowDirective = ['$animate',function($animate){return { restrict:'A',multiElement:true,link:function(scope,element,attr) { scope.$watch(attr.ngShow,function ngShowWatchAction(value) { // we're adding a temporary, animation-specific class for ng-hide since this way
        // we can control when the element is actually displayed on screen without having
        // to have a global/greedy CSS selector that breaks when other animations are run.
        // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
        $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
          tempClasses: NG_HIDE_IN_PROGRESS_CLASS
        });
      });
    }
  };
}];


/**
 * @ngdoc directive
 * @name ngHide
 *
 * @description
 * The `ngHide` directive shows or hides the given HTML element based on the expression
 * provided to the `ngHide` attribute. The element is shown or hidden by removing or adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
 * in AngularJS and sets the display style to none (using an !important flag).
 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
 *
 * ```html
 * <!-- when $scope.myValue is truthy (element is hidden) -->
 * <div ng-hide="myValue" class="ng-hide"></div>
 *
 * <!-- when $scope.myValue is falsy (element is visible) -->
 * <div ng-hide="myValue"></div>
 * ```
 *
 * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class
 * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the * styling to change how to hide an element then it is just a matter of using!important;:this is just another form of hiding an element &#42;/ * display:block!important;:*}); </file></example>*/ var ngStyleDirective = ngDirective(function(scope,element,attr){:scope.$watchCollection(attr.ngStyle,function ngStyleWatchAction(newStyles,oldStyles) { if(oldStyles &&(newStyles !== oldStyles)) { forEach(oldStyles,function(val,style) { element.css(style,'')}); var ngSwitchDirective = ['$animate',function($animate){return { restrict:'EA',require:'ngSwitch',// asks for $scope to fool the BC controller module controller['$scope',function ngSwitchController() { this.cases = {}],link: function(scope,element,attr,ngSwitchController){:var watchExpr = attr.ngSwitch || attr.on,selectedTranscludes =[],selectedElements =[],previousLeaveAnimations =[],selectedScopes =[];:var spliceFactory = function(array,index) { return function() { array.splice(index,1)}; scope.$watch(watchExpr,function ngSwitchWatchAction(value){:var i,ii;:for(i = 0,ii = previousLeaveAnimations.length;:i < ii;:++i) { $animate.cancel(previousLeaveAnimations[i])}previousLeaveAnimations.length = 0; for (i = 0,ii = selectedScopes.length; i < ii;++i){:var selected = getBlockNodes(selectedElements[i].clone);:selectedScopes[i].$destroy();:var promise = previousLeaveAnimations[i]= $animate.leave(selected);:promise.then(spliceFactory(previousLeaveAnimations,i))}selectedElements.length = 0; selectedScopes.length = 0; if ((selectedTranscludes = ngSwitchController.cases['!'+value] || ngSwitchController.cases['?'])){:forEach(selectedTranscludes,function(selectedTransclude) { selectedTransclude.transclude(function(caseElement,selectedScope) { selectedScopes.push(selectedScope);:var anchor = selectedTransclude.element;:caseElement[caseElement.length++]= document.createComment(' end ngSwitchWhen: ');var block = { clone:caseElement}]; var ngSwitchWhenDirective = ngDirective({transclude:'element',priority:1200,require:'^ngSwitch',multiElement:true,link:function(scope,element,attrs,ctrl,$transclude) { ctrl.cases['!' + attrs.ngSwitchWhen]=(ctrl.cases['!' + attrs.ngSwitchWhen]||[]);ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude:$transclude,element:element}); var ngSwitchDefaultDirective = ngDirective({transclude:'element',priority:1200,require:'^ngSwitch',multiElement:true,link:function(scope,element,attr,ctrl,$transclude) { ctrl.cases['?']=(ctrl.cases['?']||[]);ctrl.cases['?'].push({ transclude:$transclude,element:element}); var ngTranscludeDirective = ngDirective({restrict:'EAC',link:function($scope,$element,$attrs,controller,$transclude) { if(!$transclude) { throw minErr('ngTransclude')('orphan','Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}',startingTag($element))}$transclude(function(clone){:$element.empty();:$element.append(clone)}); var scriptDirective = ['$templateCache',function($templateCache){return { restrict:'E',terminal:true,compile:function(element,attr) { if(attr.type == 'text/ng-template') { var templateUrl = attr.id,text = element[0].text;:$templateCache.put(templateUrl,text)}]; var ngOptionsMinErr = minErr('ngOptions'); var ngOptionsDirective = valueFn({restrict:'A',terminal:true}); // jshint maxlen: false var selectDirective = ['$compile','$parse'function($compile,$parse){//000011111111110000000000022222222220000000000000000000003333333333000000000000004444444444444440000000005555555555555550000000666666666666666000000000000000777777777700000000000000000008888888888 var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,nullModelCtrl = {$setViewValue:noop}; // jshint maxlen: 100 return{restrict:'E',require['select','?ngModel'],controller['$element','$scope','$attrs',function($element,$scope,$attrs) { var self = this,optionsMap = {},ngModelCtrl = nullModelCtrl,nullOption,unknownOption; self.databound = $attrs.ngModel; self.init = function(ngModelCtrl_,nullOption_,unknownOption_){:ngModelCtrl = ngModelCtrl_;:nullOption = nullOption_;:unknownOption = unknownOption_}; self.addOption = function(value,element){:assertNotHasOwnProperty(value,'"option value"');:optionsMap[value]= true;:if(ngModelCtrl.$viewValue == value) { $element.val(value);:if(unknownOption.parent()) unknownOption.remove()}// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459 // Adding an <option selected="selected">element to a <select required="required">should // automatically select the new element if (element && element[0].hasAttribute('selected')){:element[0].selected = true}; self.removeOption = function(value){:if(this.hasOption(value)) { delete optionsMap[value];:if(ngModelCtrl.$viewValue === value) { this.renderUnknownOption(value)}; self.renderUnknownOption = function(val){:var unknownVal = '? ' + hashKey(val) + ' ?';:unknownOption.val(unknownVal);:$element.prepend(unknownOption);:$element.val(unknownVal);:unknownOption.prop('selected',true);:// needed for IE}; self.hasOption = function(value){:return optionsMap.hasOwnProperty(value)}; $scope.$on('$destroy',function(){:// disable unknown option so that we don't do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don't need to do anything if(!ctrls[1]) return;:var selectCtrl = ctrls[0],ngModelCtrl = ctrls[1],multiple = attr.multiple,optionsExp = attr.ngOptions,nullOption = false,// if false,user will not be able to select it(used by ngOptions) emptyOption,renderScheduled = false,// we can't just jqLite('<option>') since jqLite is not smart enough
          // to create it in <select> and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement('option')),
          optGroupTemplate =jqLite(document.createElement('optgroup')),
          unknownOption = optionTemplate.clone();

      // find "null" option
      for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
        if (children[i].value === '') {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple) {
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      }

      if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
      else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);
      else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) && emptyOption) {
              selectElement.val('');
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.on('change', function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function setupAsMultiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = shallowCopy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.on('change', function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find('option'), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function setupAsOptions(scope, selectElement, ctrl) {
        var match;

        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw ngOptionsMinErr('iexp',
            "Expected expression in form of " +
            "'_select_(as _label_)? for(_key_,)?_value_ in _collection_'" +
            " but got '{0}; if (nullOption){:// compile the element since there might be bindings in it $compile(nullOption)(scope);:// remove the class,which is added automatically because we recompile the element and it // becomes the compilation root nullOption.removeClass('ng-scope');:// we need to remove it before calling selectElement.empty() because otherwise IE will // remove the label from the element. wtf? nullOption.remove()}// clear contents,we'll add what's needed based on the model selectElement.empty(); selectElement.on('change',selectionChanged); ctrl.$render = render; scope.$watchCollection(valuesFn,scheduleRendering); scope.$watchCollection(getLabels,scheduleRendering); if (multiple){:scope.$watchCollection(function() { return ctrl.$modelValue}// ------------------------------------------------------------------ // function callExpression(exprFn,key,value){:locals[valueName]= value;:if(keyName) locals[keyName]= key;:return exprFn(scope,locals)}function selectionChanged(){:scope.$apply(function() { var collection = valuesFn(scope) ||[];:var viewValue;:if(multiple) { viewValue =[];forEach(selectElement.val(),function(selectedKey) { selectedKey = trackFn ? trackKeysCache[selectedKey:selectedKey;:viewValue.push(getViewValue(selectedKey,collection[selectedKey]))}else{var selectedKey = trackFn ? trackKeysCache[selectElement.val():selectElement.val()}function getViewValue(key,value){:if(key === '?') { return undefined}else if (key === ''){:return null}else{var viewValueFn = selectAsFn ? selectAsFn:valueFn}function getLabels(){:var values = valuesFn(scope);:var toDisplay;:if(values && isArray(values)) { toDisplay = new Array(values.length);:for(var i = 0,ii = values.length;:i < ii;:i++) { toDisplay[i]= callExpression(displayFn,i,values[i])}else if (values){// TODO:Add a test for this case toDisplay = {}; for (var prop in values){:if(values.hasOwnProperty(prop)) { toDisplay[prop]= callExpression(displayFn,prop,values[prop])}function createIsSelectedFn(viewValue){:var selectedSet;:if(multiple) { if(trackFn && isArray(viewValue)) { selectedSet = new HashMap([]);:for(var trackIndex = 0;:trackIndex < viewValue.length;:trackIndex++) { // tracking by key selectedSet.put(callExpression(trackFn,null,viewValue[trackIndex]),true)}else if (trackFn){:viewValue = callExpression(trackFn,null,viewValue)}return function isSelected(key,value){:var compareValueFn;:if(trackFn) { compareValueFn = trackFn}else if (selectAsFn){:compareValueFn = selectAsFn}if (multiple){:return isDefined(selectedSet.remove(callExpression(compareValueFn,key,value)))}function scheduleRendering(){:if(!renderScheduled) { scope.$$postDigest(render);:renderScheduled = true}function updateLabelMap(labelMap,label,added){:labelMap[label]= labelMap[label]|| 0;labelMap[label]+=(added ? 1:-1)}function render(){:renderScheduled = false;// Temporary location for the option groups before we render them var optionGroups = {'':[]}; // We now build up the list of options we need (we merge later) for (index = 0; length = keys.length,index < length; index++){:key = index;:if(keyName) { key = keys[index];:if(key.charAt(0) === '$') continue}value = values[key]; optionGroupName = callExpression(groupByFn,key,value) || ''; if (!(optionGroup = optionGroups[optionGroupName])){:optionGroup = optionGroups[optionGroupName]=[];:optionGroupNames.push(optionGroupName)}selected = isSelected(key,value); anySelected = anySelected || selected; label = callExpression(displayFn,key,value); // what will be seen by the user // doing displayFn(scope,locals) || '' overwrites zero values label = isDefined(label) ? label : ''; optionId = trackFn ? trackFn(scope,locals) : (keyName ? keys[index] : index); if (trackFn){:trackKeysCache[optionId]= key}optionGroup.push({// either the index into array or key from object id:optionId,label:label,selected:selected // determine if we should be selected}if (!multiple){if(nullOption || viewValue === null) { // insert null option if we have a placeholder,or the model is null optionGroups[''].unshift({id:'',label:'',selected:!anySelected}else if (!anySelected){// option could not be found,we have to insert the undefined item optionGroups[''].unshift({id:'?',label:'',selected:true}// Now we need to update the list of DOM nodes to match the optionGroups we computed above for (groupIndex = 0,groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++){:// current option group name or '' if no group optionGroupName = optionGroupNames[groupIndex];:// list of options for that group.(first item has the parent) optionGroup = optionGroups[optionGroupName];if(optionGroupsCache.length <= groupIndex) { // we need to grow the optionGroups existingParent = { element:optGroupTemplate.clone().attr('label',optionGroupName),label:optionGroup.label}lastElement = null; // start at the beginning for (index = 0,length = optionGroup.length; index < length; index++){:option = optionGroup[index];:if((existingOption = existingOptions[index + 1])) { // reuse elements lastElement = existingOption.element;:if(existingOption.label !== option.label) { updateLabelMap(labelMap,existingOption.label,false);:updateLabelMap(labelMap,option.label,true);:lastElement.text(existingOption.label = option.label);:lastElement.prop('label',existingOption.label)}if (existingOption.id !== option.id){:lastElement.val(existingOption.id = option.id)}// lastElement.prop('selected') provided by jQuery has side-effects if (lastElement[0].selected !== option.selected){:lastElement.prop('selected'(existingOption.selected = option.selected));:if(msie) { // See #7692 // The selected item wouldn't visually update on IE without this.
                    // Tested on Win7: IE9, IE10 and IE11. Future IEs should be tested as well
                    lastElement.prop('selected', existingOption.selected);
                  }
                }
              } else {
                // grow elements

                // if it's a null option if(option.id === '' && nullOption) { // put back the pre-compiled element element = nullOption}else{// jQuery(v1.4.2) Bug:We should be able to chain the method calls,but // in this version of jQuery on some browser the .text() returns a string // rather then the element.(element = optionTemplate.clone()) .val(option.id) .prop('selected',option.selected) .attr('selected',option.selected) .prop('label',option.label) .text(option.label)}existingOptions.push(existingOption ={element:element,label:option.label,id:option.id,selected:option.selected}); updateLabelMap(labelMap,option.label,true); if (lastElement){:lastElement.after(element)}// remove any excessive OPTIONs in a group index++; // increment since the existingOptions[0] is parent element not OPTION while (existingOptions.length>index){:option = existingOptions.pop();:updateLabelMap(labelMap,option.label,false);:option.element.remove()}// remove any excessive OPTGROUPs from select while (optionGroupsCache.length>groupIndex){:// remove all the labels in the option group optionGroup = optionGroupsCache.pop();:for(index = 1;:index < optionGroup.length;:++index) { updateLabelMap(labelMap,optionGroup[index].label,false)}forEach(labelMap,function(count,label){:if(count > 0) { selectCtrl.addOption(label)}else if (count < 0){:selectCtrl.removeOption(label)}]; var optionDirective = ['$interpolate',function($interpolate){var nullSelectCtrl = { addOption:noop,removeOption:noop}; return{restrict:'E',priority:100,compile:function(element,attr) { if(isUndefined(attr.value)) { var interpolateFn = $interpolate(element.text(),true);:if(!interpolateFn) { attr.$set('value',element.text())}return function(scope,element,attr){:var selectCtrlName = '$selectController',parent = element.parent(),selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);:// in case we are in optgroup if(!selectCtrl || !selectCtrl.databound) { selectCtrl = nullSelectCtrl}if (interpolateFn){:scope.$watch(interpolateFn,function interpolateWatchAction(newVal,oldVal) { attr.$set('value',newVal);:if(oldVal !== newVal) { selectCtrl.removeOption(oldVal)}element.on('$destroy',function(){:selectCtrl.removeOption(attr.value)}]; var styleDirective = valueFn({restrict:'E',terminal:false}); var requiredDirective = function(){return { restrict:'A',require:'?ngModel',link:function(scope,elm,attr,ctrl) { if(!ctrl) return;:attr.required = true;:// force truthy in case we are on non input element ctrl.$validators.required = function(modelValue,viewValue) { return !attr.required || !ctrl.$isEmpty(viewValue)}; attr.$observe('required',function(){:ctrl.$validate()}; var patternDirective = function(){return { restrict:'A',require:'?ngModel',link:function(scope,elm,attr,ctrl) { if(!ctrl) return;:var regexp,patternExp = attr.ngPattern || attr.pattern;:attr.$observe('pattern',function(regex) { if(isString(regex) && regex.length > 0) { regex = new RegExp('^' + regex + '$')}if (regex && !regex.test){:throw minErr('ngPattern')('noregexp','Expected {0} to be a RegExp but was {1}. Element: {2}',patternExp,regex,startingTag(elm))}); ctrl.$validators.pattern = function(value){:return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value)}; var maxlengthDirective = function(){return { restrict:'A',require:'?ngModel',link:function(scope,elm,attr,ctrl) { if(!ctrl) return;:var maxlength = -1;:attr.$observe('maxlength',function(value) { var intVal = int(value);maxlength = isNaN(intVal) ? -1:intVal;:ctrl.$validate()}); ctrl.$validators.maxlength = function(modelValue,viewValue){:return(maxlength < 0) || ctrl.$isEmpty(modelValue) ||(viewValue.length <= maxlength)}; var minlengthDirective = function(){return { restrict:'A',require:'?ngModel',link:function(scope,elm,attr,ctrl) { if(!ctrl) return;:var minlength = 0;:attr.$observe('minlength',function(value) { minlength = int(value) || 0;:ctrl.$validate()}); ctrl.$validators.minlength = function(modelValue,viewValue){:return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength}; if (window.angular.bootstrap){://AngularJS is already loaded,so we can return here... console.log('WARNING: Tried to load angular more than once.');:return}//try to bind to jquery now so that one can write jqLite(document).ready() //but we will rebind on bootstrap again. bindJQuery(); publishExternalAPI(angular); jqLite(document).ready(function(){:angularInit(document,bootstrap)})(window,document); !window.angular.$$csp() && window.angular.element(document).find('head').prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>'); (function(window,angular,undefined){'use strict':var ngRouteModule = angular.module('ngRoute'['ng']). provider('$route',$RouteProvider),$routeMinErr = angular.$$minErr('ngRoute');:function $RouteProvider() { function inherit(parent,extra) { return angular.extend(Object.create(parent),extra)}; this.when = function(path,route){://copy original route object to preserve params inherited from proto chain var routeCopy = angular.copy(route);:if(angular.isUndefined(routeCopy.reloadOnSearch)) { routeCopy.reloadOnSearch = true}if (angular.isUndefined(routeCopy.caseInsensitiveMatch)){:routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch}routes[path] = angular.extend( routeCopy,path && pathRegExp(path,routeCopy) ); // create redirection for trailing slashes if (path){var redirectPath =(path[path.length - 1]== '/') ? path.substr(0,path.length - 1):path + '/';routes[redirectPath]= angular.extend({redirectTo:path}; this.caseInsensitiveMatch = false; function pathRegExp(path,opts){var insensitive = opts.caseInsensitiveMatch,ret = { originalPath:path,regexp:path},keys = ret.keys = []; path = path .replace(/([().])/g,'\\$1') .replace(/(\/)?:(\w+)([\?\*])?/g,function(_,slash,key,option){var optional = option === '?' ? option:null;var star = option === '*' ? option:null;keys.push({ name:key,optional:!!optional}this.otherwise = function(params){if(typeof params === 'string') { params = {redirectTo:params}; this.$get = ['$rootScope','$templateRequest''$routeParams''$injector''$location''$q''$sce'function($rootScope,$location,$routeParams,$q,$injector,$templateRequest,$sce){var forceReload = false,preparedRoute,preparedRouteIsUpdateOnly,$route = { routes:routes,reload:function() { forceReload = true;$rootScope.$evalAsync(function() { // Don't support cancellation of a reload for now...
              prepareRoute();
              commitRoute();
            });
          },

          /**
           * @ngdoc method
           * @name $route#updateParams
           *
           * @description
           * Causes `$route` service to update the current URL, replacing
           * current route parameters with those specified in `newParams`.
           * Provided property names that match the route's path segment * definitions will be interpolated into the location's path, while
           * remaining properties will be treated as query params.
           *
           * @param {Object} newParams mapping of URL parameter names to values
           */
          updateParams: function(newParams) {
            if (this.current && this.current.$$route) {
              var searchParams = {}, self=this;

              angular.forEach(Object.keys(newParams), function(key) {
                if (!self.current.pathParams[key]) searchParams[key] = newParams[key];
              });

              newParams = angular.extend({}, this.current.params, newParams);
              $location.path(interpolate(this.current.$$route.originalPath, newParams));
              $location.search(angular.extend({}, $location.search(), searchParams));
            }
            else {
              throw $routeMinErr('norout', 'Tried updating route when with no current route');
            }
          }
        };

    $rootScope.$on('$locationChangeStart', prepareRoute);
    $rootScope.$on('$locationChangeSuccess', commitRoute);

    return $route;

    /////////////////////////////////////////////////////

    /**
     * @param on {string} current url
     * @param route {Object} route regexp to match the url against
     * @return {?Object}
     *
     * @description
     * Check if the route matches the current url.
     *
     * Inspired by match in
     * visionmedia/express/lib/router/router.js.
     */
    function switchRouteMatcher(on, route) {
      var keys = route.keys,
          params = {};

      if (!route.regexp) return null;

      var m = route.regexp.exec(on);
      if (!m) return null;

      for (var i = 1, len = m.length; i < len; ++i) {
        var key = keys[i - 1];

        var val = m[i];

        if (key && val) {
          params[key.name] = val;
        }
      }
      return params;
    }

    function prepareRoute($locationEvent) {
      var lastRoute = $route.current;

      preparedRoute = parseRoute();
      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route
          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)
          && !preparedRoute.reloadOnSearch && !forceReload;

      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
          if ($locationEvent) {
            $locationEvent.preventDefault();
          }
        }
      }
    }

    function commitRoute() {
      var lastRoute = $route.current;
      var nextRoute = preparedRoute;

      if (preparedRouteIsUpdateOnly) {
        lastRoute.params = nextRoute.params;
        angular.copy(lastRoute.params, $routeParams);
        $rootScope.$broadcast('$routeUpdate', lastRoute);
      } else if (nextRoute || lastRoute) {
        forceReload = false;
        $route.current = nextRoute;
        if (nextRoute) {
          if (nextRoute.redirectTo) {
            if (angular.isString(nextRoute.redirectTo)) {
              $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)
                       .replace();
            } else {
              $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))
                       .replace();
            }
          }
        }

        $q.when(nextRoute).
          then(function() {
            if (nextRoute) {
              var locals = angular.extend({}, nextRoute.resolve),
                  template, templateUrl;

              angular.forEach(locals, function(value, key) {
                locals[key] = angular.isString(value) ?
                    $injector.get(value) : $injector.invoke(value, null, null, key);
              });

              if (angular.isDefined(template = nextRoute.template)) {
                if (angular.isFunction(template)) {
                  template = template(nextRoute.params);
                }
              } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {
                if (angular.isFunction(templateUrl)) {
                  templateUrl = templateUrl(nextRoute.params);
                }
                templateUrl = $sce.getTrustedResourceUrl(templateUrl);
                if (angular.isDefined(templateUrl)) {
                  nextRoute.loadedTemplateUrl = templateUrl;
                  template = $templateRequest(templateUrl);
                }
              }
              if (angular.isDefined(template)) {
                locals['$template'] = template;
              }
              return $q.all(locals);
            }
          }).
          // after route change
          then(function(locals) {
            if (nextRoute == $route.current) {
              if (nextRoute) {
                nextRoute.locals = locals;
                angular.copy(nextRoute.params, $routeParams);
              }
              $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
            }
          }, function(error) {
            if (nextRoute == $route.current) {
              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
            }
          });
      }
    }


    /**
     * @returns {Object} the current active route, by matching it against the URL
     */
    function parseRoute() {
      // Match a route
      var params, match;
      angular.forEach(routes, function(route, path) {
        if (!match && (params = switchRouteMatcher($location.path(), route))) {
          match = inherit(route, {
            params: angular.extend({}, $location.search(), params),
            pathParams: params});
          match.$$route = route;
        }
      });
      // No route matched; fallback to "otherwise" route
      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});
    }

    /**
     * @returns {string} interpolation of the redirect path with the parameters
     */
    function interpolate(string, params) {
      var result = [];
      angular.forEach((string || '').split(':'), function(segment, i) {
        if (i === 0) {
          result.push(segment);
        } else {
          var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
          var key = segmentMatch[1];
          result.push(params[key]);
          result.push(segmentMatch[2] || '');
          delete params[key];
        }
      });
      return result.join('');
    }
  }];
}

ngRouteModule.provider('$routeParams', $RouteParamsProvider);


/**
 * @ngdoc service
 * @name $routeParams
 * @requires $route
 *
 * @description
 * The `$routeParams` service allows you to retrieve the current set of route parameters.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * The route parameters are a combination of {@link ng.$location `$location`}'s * {@link ng.$location#search `search()`}and{:@link ng.$location#path `path()`}. * The `path` parameters are extracted when the{:@link ngRoute.$route `$route`}`path` params take precedence over `search` params. * * The service guarantees that the identity of the `$routeParams` object will remain unchanged * (but its properties will likely change) even when a route change occurs. * * Note that the `$routeParams` are only updated *after* a route change completes successfully. * This means that you cannot rely on `$routeParams` being correct in route resolve functions. * Instead you can use `$route.current.params` to access the new route's parameters.
 *
 * @example
 * ```js
 *  // Given:
 *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
 *  // Route: /Chapter/:chapterId/Section/:sectionId
 *  //
 *  // Then
 *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}
 * ```
 */
function $RouteParamsProvider() {
  this.$get = function() { return {}; };
}

ngRouteModule.directive('ngView', ngViewFactory);
ngRouteModule.directive('ngView', ngViewFillContentFactory);


/**
 * @ngdoc directive
 * @name ngView
 * @restrict ECA
 *
 * @description
 * # Overview
 * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by
 * including the rendered template of the current route into the main layout (`index.html`) file.
 * Every time the current route changes, the included view changes with it according to the
 * configuration of the `$route` service.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 * @priority 400
 * @param {string=} onload Expression to evaluate whenever the view updates.
 *
 * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the view is updated.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated
 *                    as an expression yields a truthy value.
 * @example
    <example name="ngView-directive" module="ngViewExample"
             deps="angular-route.js;angular-animate.js"
             animations="true" fixBase="true">
      <file name="index.html">
        <div ng-controller="MainCtrl as main">
          Choose:
          <a href="Book/Moby">Moby</a> |
          <a href="Book/Moby/ch/1">Moby: Ch1</a> |
          <a href="Book/Gatsby">Gatsby</a> |
          <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
          <a href="Book/Scarlet">Scarlet Letter</a><br/>

          <div class="view-animate-container">
            <div ng-view class="view-animate"></div>
          </div>
          <hr />

          <pre>$location.path() = {{main.$location.path()}}</pre>
          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>
          <pre>$route.current.params = {{main.$route.current.params}}</pre>
          <pre>$routeParams = {{main.$routeParams}}</pre>
        </div>
      </file>

      <file name="book.html">
        <div>
          controller: {{book.name}}<br />
          Book Id: {{book.params.bookId}}<br />
        </div>
      </file>

      <file name="chapter.html">
        <div>
          controller: {{chapter.name}}<br />
          Book Id: {{chapter.params.bookId}}<br />
          Chapter Id: {{chapter.params.chapterId}}
        </div>
      </file>

      <file name="animations.css">
        .view-animate-container {
          position:relative;
          height:100px!important;
          background:white;
          border:1px solid black;
          height:40px;
          overflow:hidden;
        }

        .view-animate {
          padding:10px;
        }

        .view-animate.ng-enter, .view-animate.ng-leave {
          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;

          display:block;
          width:100%;
          border-left:1px solid black;

          position:absolute;
          top:0;
          left:0;
          right:0;
          bottom:0;
          padding:10px;
        }

        .view-animate.ng-enter {
          left:100%;
        }
        .view-animate.ng-enter.ng-enter-active {
          left:0;
        }
        .view-animate.ng-leave.ng-leave-active {
          left:-100%;
        }
      </file>

      <file name="script.js">
        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])
          .config(['$routeProvider', '$locationProvider',
            function($routeProvider, $locationProvider) {
              $routeProvider
                .when('/Book/:bookId', {
                  templateUrl: 'book.html',
                  controller: 'BookCtrl',
                  controllerAs: 'book'
                })
                .when('/Book/:bookId/ch/:chapterId', {
                  templateUrl: 'chapter.html',
                  controller: 'ChapterCtrl',
                  controllerAs: 'chapter'
                });

              $locationProvider.html5Mode(true);
          }])
          .controller('MainCtrl', ['$route', '$routeParams', '$location',
            function($route, $routeParams, $location) {
              this.$route = $route;
              this.$location = $location;
              this.$routeParams = $routeParams;
          }])
          .controller('BookCtrl', ['$routeParams', function($routeParams) {
            this.name = "BookCtrl";
            this.params = $routeParams;
          }])
          .controller('ChapterCtrl', ['$routeParams', function($routeParams) {
            this.name = "ChapterCtrl";
            this.params = $routeParams;
          }]);

      </file>

      <file name="protractor.js" type="protractor">
        it('should load and compile correct template', function() {
          element(by.linkText('Moby: Ch1')).click();
          var content = element(by.css('[ng-view]')).getText();
          expect(content).toMatch(/controller\: ChapterCtrl/);
          expect(content).toMatch(/Book Id\: Moby/);
          expect(content).toMatch(/Chapter Id\: 1/);

          element(by.partialLinkText('Scarlet')).click();

          content = element(by.css('[ng-view]')).getText();
          expect(content).toMatch(/controller\: BookCtrl/);
          expect(content).toMatch(/Book Id\: Scarlet/);
        });
      </file>
    </example>
 */


/**
 * @ngdoc event
 * @name ngView#$viewContentLoaded
 * @eventType emit on the current ngView scope
 * @description
 * Emitted every time the ngView content is reloaded.
 */
ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];
function ngViewFactory($route, $anchorScroll, $animate) {
  return {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    link: function(scope, $element, attr, ctrl, $transclude) {
        var currentScope,
            currentElement,
            previousLeaveAnimation,
            autoScrollExp = attr.autoscroll,
            onloadExp = attr.onload || '';

        scope.$on('$routeChangeSuccess', update);
        update();

        function cleanupLastView() {
          if (previousLeaveAnimation) {
            $animate.cancel(previousLeaveAnimation);
            previousLeaveAnimation = null;
          }

          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            previousLeaveAnimation = $animate.leave(currentElement);
            previousLeaveAnimation.then(function() {
              previousLeaveAnimation = null;
            });
            currentElement = null;
          }
        }

        function update() {
          var locals = $route.current && $route.current.locals,
              template = locals && locals.$template;

          if (angular.isDefined(template)) {
            var newScope = scope.$new();
            var current = $route.current;

            // Note: This will also link all children of ng-view that were contained in the original
            // html. If that content contains controllers, ... they could pollute/change the scope.
            // However, using ng-view on an element with additional content does not make sense...
            // Note: We can't remove them in the cloneAttchFn of $transclude as that // function is called before linking the content,path is matched. * * In case of parameter name collision,which would apply child // directives to non existing elements. var clone = $transclude(newScope,function(clone){:$animate.enter(clone,null,currentElement || $element).then(function onNgViewEnter() { if(angular.isDefined(autoScrollExp) &&(!autoScrollExp || scope.$eval(autoScrollExp))) { $anchorScroll()}// This directive is called during the $transclude call of the first `ngView` directive. // It will replace and compile the content of the element with the loaded template. // We need this directive so that the element content is already filled when // the link function of another directive on the same element as ngView // is called. ngViewFillContentFactory.$inject = ['$compile','$route'] function ngViewFillContentFactory($compile,$controller,$route)'$controller'{return { restrict:'ECA',priority:-400,link:function(scope,$element) { var current = $route.current,locals = current.locals;:$element.html(locals.$template);:var link = $compile($element.contents());:if(current.controller) { locals.$scope = scope;:var controller = $controller(current.controller,locals);:if(current.controllerAs) { scope[current.controllerAs]= controller})(window,window.angular); (function(window,angular,undefined){'use strict':var $sanitizeMinErr = angular.$$minErr('$sanitize');:function $SanitizeProvider() { this.$get =['$$sanitizeUri',function($$sanitizeUri) { return function(html) { var buf =[];:htmlParser(html,htmlSanitizeWriter(buf,function(uri,isImage) { return !/^unsafe/.test($$sanitizeUri(uri,isImage))}function sanitizeText(chars){:var buf =[];:var writer = htmlSanitizeWriter(buf,angular.noop);:writer.chars(chars);:return buf.join('')}// Regular Expressions for parsing tags and attributes var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
  BEGIN_TAG_REGEXP = /^</,
  BEGING_END_TAGE_REGEXP = /^<\//,
  COMMENT_REGEXP = /<!--(.*?)-->/g,
  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  // Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = makeMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = makeMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
                                            optionalEndTagInlineElements,
                                            optionalEndTagBlockElements);

// Safe Block Elements - HTML5
var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

// Inline Elements - HTML5
var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," +
        "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," +
        "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," +
        "stop,svg,switch,text,title,tspan,use");

// Special Elements (can contain anything)
var specialElements = makeMap("script,style");

var validElements = angular.extend({},
                                   voidElements,
                                   blockElements,
                                   inlineElements,
                                   optionalEndTagElements,
                                   svgElements);

//Attributes that have href and hence need to be sanitized
var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");

var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,target,title,type,' +
    'valign,value,vspace,width');

// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +
    'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +
    'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +
    'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +
    'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +
    'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +
    'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +
    'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +
    'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +
    'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +
    'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +
    'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +
    'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +
    'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +
    'zoomAndPan');

var validAttrs = angular.extend({},
                                uriAttrs,
                                svgAttrs,
                                htmlAttrs);

function makeMap(str) {
  var obj = {}, items = str.split(','), i;
  for (i = 0; i < items.length; i++) obj[items[i]] = true;
  return obj;
}


/**
 * @example
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * @param {string} html string
 * @param {object} handler
 */
function htmlParser(html, handler) {
  if (typeof html !== 'string') {
    if (html === null || typeof html === 'undefined') {
      html = '';
    } else {
      html = '' + html;
    }
  }
  var index, chars, match, stack = [], last = html, text;
  stack.last = function() { return stack[ stack.length - 1 ]; };

  while (html) {
    text = '';
    chars = true;

    // Make sure we're not in a script or style element if (!stack.last() || !specialElements[stack.last()]){:// Comment if(html.indexOf("<!--") === 0) { // comments containing -- are not allowed unless they terminate the comment index = html.indexOf("--",4);:if(index >= 0 && html.lastIndexOf("-->",index) === index) { if(handler.comment) handler.comment(html.substring(4,index));:html = html.substring(index + 3);:chars = false}else if (DOCTYPE_REGEXP.test(html)){:match = html.match(DOCTYPE_REGEXP);:if(match) { html = html.replace(match[0],'');:chars = false}else if (BEGING_END_TAGE_REGEXP.test(html)){:match = html.match(END_TAG_REGEXP);:if(match) { html = html.substring(match[0].length);:match[0].replace(END_TAG_REGEXP,parseEndTag);:chars = false}else if (BEGIN_TAG_REGEXP.test(html)){:match = html.match(START_TAG_REGEXP);:if(match) { // We only have a valid start-tag if there is a '>'. if(match[4]) { html = html.substring(match[0].length);:match[0].replace(START_TAG_REGEXP,parseStartTag)}if (chars){:index = html.indexOf("<");text += index < 0 ? html:html.substring(0,index);html = index < 0 ? "":html.substring(index);:if(handler.chars) handler.chars(decodeEntities(text))}else{:html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>",'i'),function(all,text) { text = text.replace(COMMENT_REGEXP,"$1").replace(CDATA_REGEXP,"$1");:if(handler.chars) handler.chars(decodeEntities(text));:return ""}if (html == last){:throw $sanitizeMinErr('badparse',"The sanitizer was unable to parse the following block " + "of html: {0}",html)}// Clean up any remaining tags parseEndTag(); function parseStartTag(tag,tagName,rest,unary){:tagName = angular.lowercase(tagName);:if(blockElements[tagName]) { while(stack.last() && inlineElements[stack.last()]) { parseEndTag("",stack.last())}if (optionalEndTagElements[tagName] && stack.last() == tagName){:parseEndTag("",tagName)}; rest.replace(ATTR_REGEXP,function(match,name,doubleQuotedValue,singleQuotedValue,unquotedValue){:var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';:attrs[name]= decodeEntities(value)}function parseEndTag(tag,tagName){:var pos = 0,i;:tagName = angular.lowercase(tagName);:if(tagName) // Find the closest opened tag of the same type for(pos = stack.length - 1;:pos >= 0;:pos--) if(stack[pos]== tagName) break;:if(pos >= 0) { // Close all the open elements,up the stack for(i = stack.length - 1;:i >= pos;:i--) if(handler.end) handler.end(stack[i]);:// Remove the open elements from the stack stack.length = pos}var hiddenPre=document.createElement("pre"); var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/; function decodeEntities(value){:if(!value) { return ''}// Note: IE8 does not preserve spaces at the start/end of innerHTML // so we must capture them and reattach them afterward var parts = spaceRe.exec(value); var spaceBefore = parts[1]; var spaceAfter = parts[3]; var content = parts[2]; if (content){:hiddenPre.innerHTML=content.replace(/</g,"&lt;");:// innerText depends on styling as it doesn't display hidden elements.
    // Therefore, it's better to use textContent not to cause unnecessary // reflows. However,IE<9 don't support textContent so the innerText
    // fallback is necessary.
    content = 'textContent' in hiddenPre ?
      hiddenPre.textContent : hiddenPre.innerText;
  }
  return spaceBefore + content + spaceAfter;
}

/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param value
 * @returns {string} escaped text
 */
function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + '';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&#' + value.charCodeAt(0) + '';
    }).
    replace(/</g, '&lt').
    replace(/>/g, '&gt');
}

/**
 * create an HTML/XML writer which writes to buffer
 * @param {Array} buf use buf.jain('') to get out sanitized html string
 * @returns {object} in the form of {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * }
 */
function htmlSanitizeWriter(buf, uriValidator) {
  var ignore = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs, unary) {
      tag = angular.lowercase(tag);
      if (!ignore && specialElements[tag]) {
        ignore = tag;
      }
      if (!ignore && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key) {
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out(unary ? '/>' : '>');
      }
    },
    end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out('</');
          out(tag);
          out('>');
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
    chars: function(chars) {
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
  };
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

/* global sanitizeText: false */

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
 * @returns {string} Html-linkified text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js">
     <file name="index.html">
       <script>
         angular.module('linkyExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.snippet =
               'Pretty text with some links:\n'+
               'http://angularjs.org/,\n'+
               'mailto:us@somewhere.org,\n'+
               'another@somewhere.org,\n'+
               'and one more:ftp://127.0.0.1/.';
             $scope.snippetWithTarget = 'http://angularjs.org/';
           }]);
       </script>
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Filter</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links:http://angularjs.org/,us@somewhere.org,' +
                  'another@somewhere.org,and one more:ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links:http://angularjs.org/,mailto:us@somewhere.org,' +
                  'another@somewhere.org,and one more:ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/,
      MAILTO_REGEXP = /^mailto:/;

  return function(text, target) {
    if (!text) return text;
    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      html.push('<a ');
      if (angular.isDefined(target)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g,'&quot;'),'">'):addText(text);:html.push('</a>')})(window, window.angular);